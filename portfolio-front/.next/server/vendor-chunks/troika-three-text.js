/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-text";
exports.ids = ["vendor-chunks/troika-three-text"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.umd.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\"), __webpack_require__(/*! troika-worker-utils */ \"(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js\"), __webpack_require__(/*! webgl-sdf-generator */ \"(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.js\"), __webpack_require__(/*! bidi-js */ \"(ssr)/./node_modules/bidi-js/dist/bidi.js\"), __webpack_require__(/*! troika-three-utils */ \"(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js\")) :\n  0;\n}(this, (function (exports, three, troikaWorkerUtils, createSDFGenerator, bidiFactory, troikaThreeUtils) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var createSDFGenerator__default = /*#__PURE__*/_interopDefaultLegacy(createSDFGenerator);\n  var bidiFactory__default = /*#__PURE__*/_interopDefaultLegacy(bidiFactory);\n\n  /**\n   * Factory function that creates a self-contained environment for processing text typesetting requests.\n   *\n   * It is important that this function has no closure dependencies, so that it can be easily injected\n   * into the source for a Worker without requiring a build step or complex dependency loading. All its\n   * dependencies must be passed in at initialization.\n   *\n   * @param {function} fontParser - a function that accepts an ArrayBuffer of the font data and returns\n   * a standardized structure giving access to the font and its glyphs:\n   *   {\n   *     unitsPerEm: number,\n   *     ascender: number,\n   *     descender: number,\n   *     capHeight: number,\n   *     xHeight: number,\n   *     lineGap: number,\n   *     forEachGlyph(string, fontSize, letterSpacing, callback) {\n   *       //invokes callback for each glyph to render, passing it an object:\n   *       callback({\n   *         index: number,\n   *         advanceWidth: number,\n   *         xMin: number,\n   *         yMin: number,\n   *         xMax: number,\n   *         yMax: number,\n   *         path: string,\n   *         pathCommandCount: number\n   *       })\n   *     }\n   *   }\n   * @param {object} bidi - the bidi.js implementation object\n   * @param {Object} config\n   * @return {Object}\n   */\n  function createTypesetter(fontParser, bidi, config) {\n\n    const {\n      defaultFontURL\n    } = config;\n\n    /**\n     * Holds parsed font objects by url\n     */\n    const fonts = Object.create(null);\n\n    const INF = Infinity;\n\n    // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n    // eslint-disable-next-line no-misleading-character-class\n    const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n\n    // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n    const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n\n    // Incomplete set of characters that allow line breaking after them\n    // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n    const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n\n    /**\n     * Load a given font url\n     */\n    function doLoadFont(url, callback) {\n      function tryLoad() {\n        const onError = err => {\n          console.error(`Failure loading font ${url}${url === defaultFontURL ? '' : '; trying fallback'}`, err);\n          if (url !== defaultFontURL) {\n            url = defaultFontURL;\n            tryLoad();\n          }\n        };\n        try {\n          const request = new XMLHttpRequest();\n          request.open('get', url, true);\n          request.responseType = 'arraybuffer';\n          request.onload = function () {\n            if (request.status >= 400) {\n              onError(new Error(request.statusText));\n            }\n            else if (request.status > 0) {\n              try {\n                const fontObj = fontParser(request.response);\n                callback(fontObj);\n              } catch (e) {\n                onError(e);\n              }\n            }\n          };\n          request.onerror = onError;\n          request.send();\n        } catch(err) {\n          onError(err);\n        }\n      }\n      tryLoad();\n    }\n\n\n    /**\n     * Load a given font url if needed, invoking a callback when it's loaded. If already\n     * loaded, the callback will be called synchronously.\n     */\n    function loadFont(fontUrl, callback) {\n      if (!fontUrl) fontUrl = defaultFontURL;\n      let font = fonts[fontUrl];\n      if (font) {\n        // if currently loading font, add to callbacks, otherwise execute immediately\n        if (font.pending) {\n          font.pending.push(callback);\n        } else {\n          callback(font);\n        }\n      } else {\n        fonts[fontUrl] = {pending: [callback]};\n        doLoadFont(fontUrl, fontObj => {\n          let callbacks = fonts[fontUrl].pending;\n          fonts[fontUrl] = fontObj;\n          callbacks.forEach(cb => cb(fontObj));\n        });\n      }\n    }\n\n\n    /**\n     * Main entry point.\n     * Process a text string with given font and formatting parameters, and return all info\n     * necessary to render all its glyphs.\n     */\n    function typeset(\n      {\n        text='',\n        font=defaultFontURL,\n        sdfGlyphSize=64,\n        fontSize=1,\n        letterSpacing=0,\n        lineHeight='normal',\n        maxWidth=INF,\n        direction,\n        textAlign='left',\n        textIndent=0,\n        whiteSpace='normal',\n        overflowWrap='normal',\n        anchorX = 0,\n        anchorY = 0,\n        includeCaretPositions=false,\n        chunkedBoundsSize=8192,\n        colorRanges=null\n      },\n      callback,\n      metricsOnly=false\n    ) {\n      const mainStart = now();\n      const timings = {fontLoad: 0, typesetting: 0};\n\n      // Ensure newlines are normalized\n      if (text.indexOf('\\r') > -1) {\n        console.info('Typesetter: got text with \\\\r chars; normalizing to \\\\n');\n        text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      }\n\n      // Ensure we've got numbers not strings\n      fontSize = +fontSize;\n      letterSpacing = +letterSpacing;\n      maxWidth = +maxWidth;\n      lineHeight = lineHeight || 'normal';\n      textIndent = +textIndent;\n\n      loadFont(font, fontObj => {\n        const hasMaxWidth = isFinite(maxWidth);\n        let glyphIds = null;\n        let glyphPositions = null;\n        let glyphData = null;\n        let glyphColors = null;\n        let caretPositions = null;\n        let visibleBounds = null;\n        let chunkedBounds = null;\n        let maxLineWidth = 0;\n        let renderableGlyphCount = 0;\n        let canWrap = whiteSpace !== 'nowrap';\n        const {ascender, descender, unitsPerEm, lineGap, capHeight, xHeight} = fontObj;\n        timings.fontLoad = now() - mainStart;\n        const typesetStart = now();\n\n        // Find conversion between native font units and fontSize units; this will already be done\n        // for the gx/gy values below but everything else we'll need to convert\n        const fontSizeMult = fontSize / unitsPerEm;\n\n        // Determine appropriate value for 'normal' line height based on the font's actual metrics\n        // TODO this does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n        if (lineHeight === 'normal') {\n          lineHeight = (ascender - descender + lineGap) / unitsPerEm;\n        }\n\n        // Determine line height and leading adjustments\n        lineHeight = lineHeight * fontSize;\n        const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;\n        const topBaseline = -(ascender * fontSizeMult + halfLeading);\n        const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);\n        const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;\n\n        // Distribute glyphs into lines based on wrapping\n        let lineXOffset = textIndent;\n        let currentLine = new TextLine();\n        const lines = [currentLine];\n\n        fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex) => {\n          const char = text.charAt(charIndex);\n          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n          const curLineCount = currentLine.count;\n          let nextLine;\n\n          // Calc isWhitespace and isEmpty once per glyphObj\n          if (!('isEmpty' in glyphObj)) {\n            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n          }\n          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n            renderableGlyphCount++;\n          }\n\n          // If a non-whitespace character overflows the max width, we need to soft-wrap\n          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n            // If it's the first char after a whitespace, start a new line\n            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n              nextLine = new TextLine();\n              lineXOffset = -glyphX;\n            } else {\n              // Back up looking for a whitespace character to wrap at\n              for (let i = curLineCount; i--;) {\n                // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n                if (i === 0 && overflowWrap === 'break-word') {\n                  nextLine = new TextLine();\n                  lineXOffset = -glyphX;\n                  break\n                }\n                // Found a soft break point; move all chars since it to a new line\n                else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                  nextLine = currentLine.splitAt(i + 1);\n                  const adjustX = nextLine.glyphAt(0).x;\n                  lineXOffset -= adjustX;\n                  for (let j = nextLine.count; j--;) {\n                    nextLine.glyphAt(j).x -= adjustX;\n                  }\n                  break\n                }\n              }\n            }\n            if (nextLine) {\n              currentLine.isSoftWrapped = true;\n              currentLine = nextLine;\n              lines.push(currentLine);\n              maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n            }\n          }\n\n          let fly = currentLine.glyphAt(currentLine.count);\n          fly.glyphObj = glyphObj;\n          fly.x = glyphX + lineXOffset;\n          fly.width = glyphWidth;\n          fly.charIndex = charIndex;\n\n          // Handle hard line breaks\n          if (char === '\\n') {\n            currentLine = new TextLine();\n            lines.push(currentLine);\n            lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;\n          }\n        });\n\n        // Calculate width of each line (excluding trailing whitespace) and maximum block width\n        lines.forEach(line => {\n          for (let i = line.count; i--;) {\n            let {glyphObj, x, width} = line.glyphAt(i);\n            if (!glyphObj.isWhitespace) {\n              line.width = x + width;\n              if (line.width > maxLineWidth) {\n                maxLineWidth = line.width;\n              }\n              return\n            }\n          }\n        });\n\n        // Find overall position adjustments for anchoring\n        let anchorXOffset = 0;\n        let anchorYOffset = 0;\n        if (anchorX) {\n          if (typeof anchorX === 'number') {\n            anchorXOffset = -anchorX;\n          }\n          else if (typeof anchorX === 'string') {\n            anchorXOffset = -maxLineWidth * (\n              anchorX === 'left' ? 0 :\n              anchorX === 'center' ? 0.5 :\n              anchorX === 'right' ? 1 :\n              parsePercent(anchorX)\n            );\n          }\n        }\n        if (anchorY) {\n          if (typeof anchorY === 'number') {\n            anchorYOffset = -anchorY;\n          }\n          else if (typeof anchorY === 'string') {\n            let height = lines.length * lineHeight;\n            anchorYOffset = anchorY === 'top' ? 0 :\n              anchorY === 'top-baseline' ? -topBaseline :\n              anchorY === 'top-cap' ? -topBaseline - capHeight * fontSizeMult :\n              anchorY === 'top-ex' ? -topBaseline - xHeight * fontSizeMult :\n              anchorY === 'middle' ? height / 2 :\n              anchorY === 'bottom' ? height :\n              anchorY === 'bottom-baseline' ? height - halfLeading + descender * fontSizeMult :\n              parsePercent(anchorY) * height;\n          }\n        }\n\n        if (!metricsOnly) {\n          // Resolve bidi levels\n          const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n\n          // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n          // collecting all renderable glyphs into a single collection.\n          glyphIds = new Uint16Array(renderableGlyphCount);\n          glyphPositions = new Float32Array(renderableGlyphCount * 2);\n          glyphData = {};\n          visibleBounds = [INF, INF, -INF, -INF];\n          chunkedBounds = [];\n          let lineYOffset = topBaseline;\n          if (includeCaretPositions) {\n            caretPositions = new Float32Array(text.length * 3);\n          }\n          if (colorRanges) {\n            glyphColors = new Uint8Array(renderableGlyphCount * 3);\n          }\n          let renderableGlyphIndex = 0;\n          let prevCharIndex = -1;\n          let colorCharIndex = -1;\n          let chunk;\n          let currentColor;\n          lines.forEach((line, lineIndex) => {\n            let {count:lineGlyphCount, width:lineWidth} = line;\n\n            // Ignore empty lines\n            if (lineGlyphCount > 0) {\n              // Count trailing whitespaces, we want to ignore these for certain things\n              let trailingWhitespaceCount = 0;\n              for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {\n                trailingWhitespaceCount++;\n              }\n\n              // Apply horizontal alignment adjustments\n              let lineXOffset = 0;\n              let justifyAdjust = 0;\n              if (textAlign === 'center') {\n                lineXOffset = (maxLineWidth - lineWidth) / 2;\n              } else if (textAlign === 'right') {\n                lineXOffset = maxLineWidth - lineWidth;\n              } else if (textAlign === 'justify' && line.isSoftWrapped) {\n                // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n                let whitespaceCount = 0;\n                for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {\n                  if (line.glyphAt(i).glyphObj.isWhitespace) {\n                    whitespaceCount++;\n                  }\n                }\n                justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n              }\n              if (justifyAdjust || lineXOffset) {\n                let justifyOffset = 0;\n                for (let i = 0; i < lineGlyphCount; i++) {\n                  let glyphInfo = line.glyphAt(i);\n                  const glyphObj = glyphInfo.glyphObj;\n                  glyphInfo.x += lineXOffset + justifyOffset;\n                  // Expand non-trailing whitespaces for justify alignment\n                  if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                    justifyOffset += justifyAdjust;\n                    glyphInfo.width += justifyAdjust;\n                  }\n                }\n              }\n\n              // Perform bidi range flipping\n              const flips = bidi.getReorderSegments(\n                text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex\n              );\n              for (let fi = 0; fi < flips.length; fi++) {\n                const [start, end] = flips[fi];\n                // Map start/end string indices to indices in the line\n                let left = Infinity, right = -Infinity;\n                for (let i = 0; i < lineGlyphCount; i++) {\n                  if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters\n                    let startInLine = i, endInLine = i;\n                    for (; endInLine < lineGlyphCount; endInLine++) {\n                      let info = line.glyphAt(endInLine);\n                      if (info.charIndex > end) {\n                        break\n                      }\n                      if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width\n                        left = Math.min(left, info.x);\n                        right = Math.max(right, info.x + info.width);\n                      }\n                    }\n                    for (let j = startInLine; j < endInLine; j++) {\n                      const glyphInfo = line.glyphAt(j);\n                      glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                    }\n                    break\n                  }\n                }\n              }\n\n              // Assemble final data arrays\n              let glyphObj;\n              const setGlyphObj = g => glyphObj = g;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                let glyphInfo = line.glyphAt(i);\n                glyphObj = glyphInfo.glyphObj;\n                const glyphId = glyphObj.index;\n\n                // Replace mirrored characters in rtl\n                const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n                if (rtl) {\n                  const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                  if (mirrored) {\n                    fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                  }\n                }\n\n                // Add caret positions\n                if (includeCaretPositions) {\n                  const {charIndex} = glyphInfo;\n                  const caretLeft = glyphInfo.x + anchorXOffset;\n                  const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                  caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft; //start edge x\n                  caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                  caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset; //common bottom y\n\n                  // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                  // positions for those missing char indices; currently this uses a best-guess by dividing\n                  // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                  // table to get better interior caret positions.\n                  const ligCount = charIndex - prevCharIndex;\n                  if (ligCount > 1) {\n                    fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                  }\n                  prevCharIndex = charIndex;\n                }\n\n                // Track current color range\n                if (colorRanges) {\n                  const {charIndex} = glyphInfo;\n                  while(charIndex > colorCharIndex) {\n                    colorCharIndex++;\n                    if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                      currentColor = colorRanges[colorCharIndex];\n                    }\n                  }\n                }\n\n                // Get atlas data for renderable glyphs\n                if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                  const idx = renderableGlyphIndex++;\n\n                  // Add this glyph's path data\n                  if (!glyphData[glyphId]) {\n                    glyphData[glyphId] = {\n                      path: glyphObj.path,\n                      pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]\n                    };\n                  }\n\n                  // Determine final glyph position and add to glyphPositions array\n                  const glyphX = glyphInfo.x + anchorXOffset;\n                  const glyphY = lineYOffset + anchorYOffset;\n                  glyphPositions[idx * 2] = glyphX;\n                  glyphPositions[idx * 2 + 1] = glyphY;\n\n                  // Track total visible bounds\n                  const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                  const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                  const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                  const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                  if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                  if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                  if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                  if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n\n                  // Track bounding rects for each chunk of N glyphs\n                  if (idx % chunkedBoundsSize === 0) {\n                    chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};\n                    chunkedBounds.push(chunk);\n                  }\n                  chunk.end++;\n                  const chunkRect = chunk.rect;\n                  if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                  if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                  if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                  if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n\n                  // Add to glyph ids array\n                  glyphIds[idx] = glyphId;\n\n                  // Add colors\n                  if (colorRanges) {\n                    const start = idx * 3;\n                    glyphColors[start] = currentColor >> 16 & 255;\n                    glyphColors[start + 1] = currentColor >> 8 & 255;\n                    glyphColors[start + 2] = currentColor & 255;\n                  }\n                }\n              }\n            }\n\n            // Increment y offset for next line\n            lineYOffset -= lineHeight;\n          });\n\n          // Fill in remaining caret positions in case the final character was a ligature\n          if (caretPositions) {\n            const ligCount = text.length - prevCharIndex;\n            if (ligCount > 1) {\n              fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n            }\n          }\n        }\n\n        // Timing stats\n        timings.typesetting = now() - typesetStart;\n\n        callback({\n          glyphIds, //font indices for each glyph\n          glyphPositions, //x,y of each glyph's origin in layout\n          glyphData, //dict holding data about each glyph appearing in the text\n          caretPositions, //startX,endX,bottomY caret positions for each char\n          caretHeight, //height of cursor from bottom to top\n          glyphColors, //color for each glyph, if color ranges supplied\n          chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n          fontSize, //calculated em height\n          unitsPerEm, //font units per em\n          ascender: ascender * fontSizeMult, //font ascender\n          descender: descender * fontSizeMult, //font descender\n          capHeight: capHeight * fontSizeMult, //font cap-height\n          xHeight: xHeight * fontSizeMult, //font x-height\n          lineHeight, //computed line height\n          topBaseline, //y coordinate of the top line's baseline\n          blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n            anchorXOffset,\n            anchorYOffset - lines.length * lineHeight,\n            anchorXOffset + maxLineWidth,\n            anchorYOffset\n          ],\n          visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n          timings\n        });\n      });\n    }\n\n\n    /**\n     * For a given text string and font parameters, determine the resulting block dimensions\n     * after wrapping for the given maxWidth.\n     * @param args\n     * @param callback\n     */\n    function measure(args, callback) {\n      typeset(args, (result) => {\n        const [x0, y0, x1, y1] = result.blockBounds;\n        callback({\n          width: x1 - x0,\n          height: y1 - y0\n        });\n      }, {metricsOnly: true});\n    }\n\n    function parsePercent(str) {\n      let match = str.match(/^([\\d.]+)%$/);\n      let pct = match ? parseFloat(match[1]) : NaN;\n      return isNaN(pct) ? 0 : pct / 100\n    }\n\n    function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n      const ligStartX = caretPositions[ligStartIndex * 3];\n      const ligEndX = caretPositions[ligStartIndex * 3 + 1];\n      const ligY = caretPositions[ligStartIndex * 3 + 2];\n      const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n      for (let i = 0; i < ligCount; i++) {\n        const startIndex = (ligStartIndex + i) * 3;\n        caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n        caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n        caretPositions[startIndex + 2] = ligY;\n      }\n    }\n\n    function now() {\n      return (self.performance || Date).now()\n    }\n\n    // Array-backed structure for a single line's glyphs data\n    function TextLine() {\n      this.data = [];\n    }\n    const textLineProps = ['glyphObj', 'x', 'width', 'charIndex'];\n    TextLine.prototype = {\n      width: 0,\n      isSoftWrapped: false,\n      get count() {\n        return Math.ceil(this.data.length / textLineProps.length)\n      },\n      glyphAt(i) {\n        let fly = TextLine.flyweight;\n        fly.data = this.data;\n        fly.index = i;\n        return fly\n      },\n      splitAt(i) {\n        let newLine = new TextLine();\n        newLine.data = this.data.splice(i * textLineProps.length);\n        return newLine\n      }\n    };\n    TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {\n      Object.defineProperty(obj, prop, {\n        get() {\n          return this.data[this.index * textLineProps.length + i]\n        },\n        set(val) {\n          this.data[this.index * textLineProps.length + i] = val;\n        }\n      });\n      return obj\n    }, {data: null, index: 0});\n\n\n    return {\n      typeset,\n      measure,\n      loadFont\n    }\n  }\n\n  const now = () => (self.performance || Date).now();\n\n  const mainThreadGenerator = /*#__PURE__*/ createSDFGenerator__default['default']();\n\n  let warned;\n\n  /**\n   * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n   * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n   * generation when supported.\n   */\n  function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n    // Allow opt-out\n    if (!useWebGL) {\n      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n    }\n\n    // Attempt GPU-accelerated generation first\n    return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(\n      null,\n      err => {\n        // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n        if (!warned) {\n          console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n          warned = true;\n        }\n        return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n      }\n    )\n  }\n\n  const queue = [];\n  const chunkTimeBudget = 5; // ms\n  let timer = 0;\n\n  function nextChunk() {\n    const start = now();\n    while (queue.length && now() - start < chunkTimeBudget) {\n      queue.shift()();\n    }\n    timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n  }\n\n  /**\n   * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n   * macrotask chunks to allow render frames to execute in between.\n   */\n  const generateSDF_GL = (...args) => {\n    return new Promise((resolve, reject) => {\n      queue.push(() => {\n        const start = now();\n        try {\n          mainThreadGenerator.webgl.generateIntoCanvas(...args);\n          resolve({ timing: now() - start });\n        } catch (err) {\n          reject(err);\n        }\n      });\n      if (!timer) {\n        timer = setTimeout(nextChunk, 0);\n      }\n    })\n  };\n\n  const threadCount = 4; // how many workers to spawn\n  const idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\n  const threads = {};\n  let callNum = 0;\n\n  /**\n   * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n   */\n  function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n    const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);\n    let thread = threads[workerId];\n    if (!thread) {\n      thread = threads[workerId] = {\n        workerModule: troikaWorkerUtils.defineWorkerModule({\n          name: workerId,\n          workerId,\n          dependencies: [\n            createSDFGenerator__default['default'],\n            now\n          ],\n          init(_createSDFGenerator, now) {\n            const generate = _createSDFGenerator().javascript.generate;\n            return function (...args) {\n              const start = now();\n              const textureData = generate(...args);\n              return {\n                textureData,\n                timing: now() - start\n              }\n            }\n          },\n          getTransferables(result) {\n            return [result.textureData.buffer]\n          }\n        }),\n        requests: 0,\n        idleTimer: null\n      };\n    }\n\n    thread.requests++;\n    clearTimeout(thread.idleTimer);\n    return thread.workerModule(width, height, path, viewBox, distance, exponent)\n      .then(({ textureData, timing }) => {\n        // copy result data into the canvas\n        const start = now();\n        // expand single-channel data into rgba\n        const imageData = new Uint8Array(textureData.length * 4);\n        for (let i = 0; i < textureData.length; i++) {\n          imageData[i * 4 + channel] = textureData[i];\n        }\n        mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));\n        timing += now() - start;\n\n        // clean up workers after a while\n        if (--thread.requests === 0) {\n          thread.idleTimer = setTimeout(() => { troikaWorkerUtils.terminateWorker(workerId); }, idleTimeout);\n        }\n        return { timing }\n      })\n  }\n\n  function warmUpSDFCanvas(canvas) {\n    if (!canvas._warm) {\n      mainThreadGenerator.webgl.isSupported(canvas);\n      canvas._warm = true;\n    }\n  }\n\n  const resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\n\n  /*!\n  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\n  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n  */\n  function typrFactory(){return \"undefined\"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if(\"ttcf\"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=[\"cmap\",\"head\",\"hhea\",\"maxp\",\"hmtx\",\"name\",\"OS/2\",\"post\",\"loca\",\"glyf\",\"kern\",\"CFF \",\"GPOS\",\"GSUB\",\"SVG \"],i={_data:r,_offset:n},h={},f=0;f<o;f++){var d=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[d]={offset:u,length:l};}for(f=0;f<s.length;f++){var v=s[f];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var f=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return f}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a=\"\",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a=\"\",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:\"undefined\"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var f=s.readUshort(r,t);t+=2;var d=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+f),i.featureList=e._lctf.readFeatureList(r,h+d),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=n.readUshort(r,t);t+=2;var d=e._lctf.readLookupTable(r,o+f,a);s.push(d);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,f=0;f<i;f++){var d=n.readUshort(r,t);t+=2;var u=a(r,h,o+d,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var f=a.readUshort(r,t);t+=2;for(h=0;h<f;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2;var d=e._lctf.readFeatureTable(r,n+f);d.tag=h.trim(),o.push(d);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+f);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,o.default=e._lctf.readLangSysTable(r,n+s);var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[f.trim()]=e._lctf.readLangSysTable(r,n+d);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var f=[];for(i=0;i<h.length-1;i++)f.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var d=f[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,d),d.CharStrings){t=d.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));d.CharStrings=v;}if(d.ROS){t=d.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),d.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),d.FDArray.push(p);}t+=c[c.length-1],t=d.FDSelect,d.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)d.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return d.Encoding&&(d.Encoding=e.CFF.readEncoding(r,d.Encoding,d.CharStrings.length)),d.charset&&(d.charset=e.CFF.readCharset(r,d.charset,d.CharStrings.length)),e.CFF._readFDict(r,d,l),d},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=[\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[\".notdef\"],o=r[t];if(t++,0!=o)throw \"error: unknown encoding format: \"+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[\".notdef\"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw \"error: format: \"+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var f=0;1==s?(f=r[t],t++):(f=n.readUshort(r,t),t+=2);for(i=0;i<=f;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw \"unsupported offset size: \"+s+\", count: \"+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,f=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(f=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(f=o-139,i=1),247<=o&&o<=250&&(f=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(f=256*-(o-251)-s-108,i=2),255==o&&(f=n.readInt(r,t+1)/65535,i=5),a.val=null!=f?f:\"o\"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;i<=20&&(d=i,f=1),12==i&&(d=100*i+h,f=2),19!=i&&20!=i||(d=i,f=2),21<=i&&i<=27&&(d=i,f=1),28==i&&(u=o.readShort(r,t+1),f=3),29<=i&&i<=31&&(d=i,f=1),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i&&(u=o.readInt(r,t+1)/65535,f=5),s.push(null!=u?u:\"o\"+d),t+=f;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;if(28==i&&(u=n.readShort(r,t+1),f=3),29==i&&(u=n.readInt(r,t+1),f=5),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i)throw u=n.readInt(r,t+1)/65535,f=5,\"unknown number\";if(30==i){var l=[];for(f=1;;){var v=r[t+f];f++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U=\"\",g=[0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(d=[\"version\",\"Notice\",\"FullName\",\"FamilyName\",\"Weight\",\"FontBBox\",\"BlueValues\",\"OtherBlues\",\"FamilyBlues\",\"FamilyOtherBlues\",\"StdHW\",\"StdVW\",\"escape\",\"UniqueID\",\"XUID\",\"charset\",\"Encoding\",\"CharStrings\",\"Private\",\"Subrs\",\"defaultWidthX\",\"nominalWidthX\"][i],f=1,12==i)d=[\"Copyright\",\"isFixedPitch\",\"ItalicAngle\",\"UnderlinePosition\",\"UnderlineThickness\",\"PaintType\",\"CharstringType\",\"FontMatrix\",\"StrokeWidth\",\"BlueScale\",\"BlueShift\",\"BlueFuzz\",\"StemSnapH\",\"StemSnapV\",\"ForceBold\",0,0,\"LanguageGroup\",\"ExpansionFactor\",\"initialRandomSeed\",\"SyntheticBase\",\"PostScript\",\"BaseFontName\",\"BaseFontBlend\",0,0,0,0,0,0,\"ROS\",\"CIDFontVersion\",\"CIDFontRevision\",\"CIDFontType\",\"CIDCount\",\"UIDBase\",\"FDArray\",\"FDSelect\",\"FontName\"][h],f=2;null!=d?(o[d]=1==s.length?s[0]:s,s=[]):s.push(u),t+=f;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var f=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l=\"p\"+f+\"e\"+d,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug(\"unknown format: \"+p,f,d,u),o.tables.push(c);}if(null!=o[l])throw \"multiple tables for one platform+encoding\";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var f=0;f<h;f++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),f=a.readUint(r,i+4),d=a.readUint(r,i+8);n.groups.push([h,f,d]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,\"glyf\",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var f=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<f;i++){var d=n[o];if(o++,s.flags.push(d),0!=(8&d)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(d),i++;}}s.xs=[];for(i=0;i<f;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<f;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<f;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var f=o.readUshort(r,a);a+=2;var d=e._lctf.numOfOnes(f);0!=f&&(i.pos=e.GPOS.readValueRecord(r,a,f));}else if(2==t&&i.fmt>=1&&i.fmt<=2){f=o.readUshort(r,a);a+=2;var u=o.readUshort(r,a);a+=2;d=e._lctf.numOfOnes(f);var l=e._lctf.numOfOnes(u);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,p,u),p+=2*l),g.push({gid2:m,val1:x,val2:P});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var _=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var C=[];for(S=0;S<_;S++){var x=null,P=null;0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,a,u),a+=2*l),C.push({val1:x,val2:P});}i.matrix.push(C);}}}else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw \"invalid extension substitution\";return e.GPOS.subt(r,n.ltype,s+w)}console.debug(\"unsupported GPOS table LookupType\",t,\"format\",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var f=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,f),a+=2*i.newg.length;}}else if(4==t){i.vals=[];f=o.readUshort(r,a);a+=2;for(var d=0;d<f;d++){var u=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+u));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var l=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+l),i.scset=[];var v=o.readUshort(r,a);a+=2;for(d=0;d<v;d++){var c=o.readUshort(r,a);a+=2,i.scset.push(0==c?null:e.GSUB.readSubClassSet(r,s+c));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(d=0;d<3;d++){f=o.readUshort(r,a);a+=2;for(var p=[],U=0;U<f;U++)p.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*U)));a+=2*f,0==d&&(i.backCvg=p),1==d&&(i.inptCvg=p),2==d&&(i.ahedCvg=p);}f=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,f);}}else {if(7==t&&1==i.fmt){var g=o.readUshort(r,a);a+=2;var S=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=g;else if(n.ltype!=g)throw \"invalid extension substitution\";return e.GSUB.subt(r,n.ltype,s+S)}console.debug(\"unsupported GSUB table LookupType\",t,\"format\",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=[\"backtrack\",\"input\",\"lookahead\"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,f=0;f<n.maxp.numGlyphs;f++)f<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},f=0;f<i;f++){t+=2;a=o.readUshort(r,t);t+=2;var d=o.readUshort(r,t);t+=2;var u=d>>>8;if(0!=(u&=15))throw \"unknown kern table format: \"+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var f=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var d=f>>>8;if(0!=(d&=15))throw \"unknown kern table format: \"+d;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var d=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(f),u.vals.push(d),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var f=0;f<h;f++)s.push(o.readUshort(r,t+(f<<1))<<1);if(1==i)for(f=0;f<h;f++)s.push(o.readUint(r,t+(f<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=[\"copyright\",\"fontFamily\",\"fontSubfamily\",\"ID\",\"fullName\",\"version\",\"postScriptName\",\"trademark\",\"manufacturer\",\"designer\",\"description\",\"urlVendor\",\"urlDesigner\",\"licence\",\"licenceURL\",\"---\",\"typoFamilyName\",\"typoSubfamilyName\",\"compatibleFull\",\"sampleText\",\"postScriptCID\",\"wwsFamilyName\",\"wwsSubfamilyName\",\"lightPalette\",\"darkPalette\"],f=t+=2,d=0;d<s;d++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=f+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw \"unknown encoding \"+l+\", platformID: \"+u;g=n.readASCII(r,m,p),console.debug(\"reading unknown MAC encoding \"+l+\" as ASCII\");}var b=\"p\"+u+\",\"+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return console.debug(\"returning name table with languageID \"+o[i]._lang),o[i]},e[\"OS/2\"]={},e[\"OS/2\"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e[\"OS/2\"].version0(r,t,o);else if(1==n)e[\"OS/2\"].version1(r,t,o);else if(2==n||3==n||4==n)e[\"OS/2\"].version2(r,t,o);else {if(5!=n)throw \"unknown OS/2 table version: \"+n;e[\"OS/2\"].version5(r,t,o);}return o},e[\"OS/2\"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e[\"OS/2\"].version1=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e[\"OS/2\"].version2=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e[\"OS/2\"].version5=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw \"no familiar platform and encoding!\";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw \"unknown cmap table format \"+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:(\"string\"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,f=1&r.flags[s],d=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(f){if(!d){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else d?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);f?d&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var f=o.crds[h],d=o.crds[h+1];a.crds.push(f*i.a+d*i.b+i.tx),a.crds.push(f*i.c+d*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U.getPairAdjustment=function(r,t,a){var n=!1;if(r.GPOS)for(var o=r.GPOS,s=o.lookupList,i=o.featureList,h=[],f=0;f<i.length;f++){var d=i[f];if(\"kern\"==d.tag){n=!0;for(var u=0;u<d.tab.length;u++)if(!h[d.tab[u]]){h[d.tab[u]]=!0;for(var l=s[d.tab[u]],v=0;v<l.tabs.length;v++)if(null!=l.tabs[v]){var c,p=l.tabs[v];if(!p.coverage||-1!=(c=e._lctf.coverageIndex(p.coverage,t)))if(1==l.ltype);else if(2==l.ltype){var U=null;if(1==p.fmt){var g=p.pairsets[c];for(f=0;f<g.length;f++)g[f].gid2==a&&(U=g[f]);}else if(2==p.fmt){var S=e.U._getGlyphClass(t,p.classDef1),m=e.U._getGlyphClass(a,p.classDef2);U=p.matrix[S][m];}if(U){var b=0;return U.val1&&U.val1[2]&&(b+=U.val1[2]),U.val2&&U.val2[0]&&(b+=U.val2[0]),b}}}}}}if(r.kern&&!n){var y=r.kern.glyph1.indexOf(t);if(-1!=y){var F=r.kern.rval[y].glyph2.indexOf(a);if(-1!=F)return r.kern.rval[y].vals[F]}}return 0},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var f=h.vals[i],d=0;d<f.length;d++){var u=f[d],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var _=b.substLookupRecords;for(d=0;d<_.length;d+=2)_[d],_[d+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var C=h.lookupRec;for(m=0;m<C.length;m+=2){U=C[m];var x=n[C[m+1]];e.U._applySubs(r,t+U,x,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,f=e.U.glyphToPath(r,i),d=0;d<f.crds.length;d+=2)n.crds.push(f.crds[d]+o),n.crds.push(f.crds[d+1]);a&&n.cmds.push(a);for(d=0;d<f.cmds.length;d++)n.cmds.push(f.cmds[d]);a&&n.cmds.push(\"X\"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push(\"M\"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push(\"L\"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push(\"C\"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push(\"Q\"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push(\"Z\");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,_=0,C={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,C);var x=C.val;if(u+=C.size,\"o1\"==x||\"o18\"==x)s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if(\"o3\"==x||\"o23\"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if(\"o4\"==x)s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),d&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),d=!0;else if(\"o5\"==x)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if(\"o6\"==x||\"o7\"==x)for(var P=s.length,I=\"o6\"==x,w=0;w<P;w++){var O=s.shift();I?l+=O:v+=O,I=!I,e.U.P.lineTo(o,l,v);}else if(\"o8\"==x||\"o24\"==x){P=s.length;for(var T=0;T+6<=P;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),T+=6;\"o24\"==x&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if(\"o11\"==x)break;if(\"o1234\"==x||\"o1235\"==x||\"o1236\"==x||\"o1237\"==x)\"o1234\"==x&&(p=v,U=(c=l+s.shift())+s.shift(),_=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1235\"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1236\"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),_=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1237\"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v));else if(\"o14\"==x){if(s.length>0&&!h&&(f=s.shift()+a.nominalWidthX,h=!0),4==s.length){var k=s.shift(),G=s.shift(),D=s.shift(),B=s.shift(),L=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[L],t,a,n,o),t.x=k,t.y=G,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}d&&(e.U.P.closePath(o),d=!1);}else if(\"o19\"==x||\"o20\"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if(\"o21\"==x)s.length>2&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0;else if(\"o22\"==x)s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0;else if(\"o25\"==x){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if(\"o26\"==x)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o27\"==x)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o10\"==x||\"o29\"==x){var A=\"o10\"==x?n:a;if(0==s.length)console.debug(\"error: empty stack\");else {var W=s.pop(),M=A.Subrs[W+A.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open;}}else if(\"o30\"==x||\"o31\"==x){var V=s.length,N=(T=0,\"o31\"==x);for(T+=V-(P=-3&V);T<P;)N?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),P-T==5?(l=U+s.shift(),T++):l=U,N=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),P-T==5?(v=g+s.shift(),T++):v=g,N=!0),e.U.P.curveTo(o,c,p,U,g,l,v),T+=4;}else {if(\"o\"==(x+\"\").charAt(0))throw console.debug(\"Unknown operation: \"+x,r),x;s.push(x);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).Typr}\n\n  /*!\n  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n  (https://github.com/101arrowz/fflate) for use in Troika text rendering. \n  Original licenses apply: \n  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n  */\n  function woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).convert_streams}\n\n  /**\n   * A factory wrapper parsing a font file using Typr.\n   * Also adds support for WOFF files (not WOFF2).\n   */\n\n  function parserFactory(Typr, woff2otf) {\n    const cmdArgLengths = {\n      M: 2,\n      L: 2,\n      Q: 4,\n      C: 6,\n      Z: 0\n    };\n\n    // {joinType: \"skip+step,...\"}\n    const joiningTypeRawData = {\"C\":\"18g,ca,368,1kz\",\"D\":\"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\"R\":\"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\"L\":\"x9u,jff,a,fd,jv\",\"T\":\"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"};\n\n    const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.\n      JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.\n      JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.\n      JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.\n      JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.\n      JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n\n    let joiningTypeMap;\n    function getCharJoiningType(ch) {\n      if (!joiningTypeMap) {\n        const m = {\n          R: JT_RIGHT,\n          L: JT_LEFT,\n          D: JT_DUAL,\n          C: JT_JOIN_CAUSING,\n          U: JT_NON_JOINING,\n          T: JT_TRANSPARENT\n        };\n        joiningTypeMap = new Map();\n        for (let type in joiningTypeRawData) {\n          let lastCode = 0;\n          joiningTypeRawData[type].split(',').forEach(range => {\n            let [skip, step] = range.split('+');\n            skip = parseInt(skip,36);\n            step = step ? parseInt(step, 36) : 0;\n            joiningTypeMap.set(lastCode += skip, m[type]);\n            for (let i = step; i--;) {\n              joiningTypeMap.set(++lastCode, m[type]);\n            }\n          });\n        }\n      }\n      return joiningTypeMap.get(ch) || JT_NON_JOINING\n    }\n\n    const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n    const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];\n\n    function detectJoiningForms(str) {\n      // This implements the algorithm described here:\n      // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n      const joiningForms = new Uint8Array(str.length);\n      let prevJoiningType = JT_NON_JOINING;\n      let prevForm = ISOL;\n      let prevIndex = -1;\n      for (let i = 0; i < str.length; i++) {\n        const code = str.codePointAt(i);\n        let joiningType = getCharJoiningType(code) | 0;\n        let form = ISOL;\n        if (joiningType & JT_TRANSPARENT) {\n          continue\n        }\n        if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n          if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n            form = FINA;\n            // isol->init, fina->medi\n            if (prevForm === ISOL || prevForm === FINA) {\n              joiningForms[prevIndex]++;\n            }\n          }\n          else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n            // medi->fina, init->isol\n            if (prevForm === INIT || prevForm === MEDI) {\n              joiningForms[prevIndex]--;\n            }\n          }\n        }\n        else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n          // medi->fina, init->isol\n          if (prevForm === INIT || prevForm === MEDI) {\n            joiningForms[prevIndex]--;\n          }\n        }\n        prevForm = joiningForms[i] = form;\n        prevJoiningType = joiningType;\n        prevIndex = i;\n        if (code > 0xffff) i++;\n      }\n      // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n      // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n      // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n      return joiningForms\n    }\n\n    function stringToGlyphs (font, str) {\n      const glyphIds = [];\n      for (let i = 0; i < str.length; i++) {\n        const cc = str.codePointAt(i);\n        if (cc > 0xffff) i++;\n        glyphIds.push(Typr.U.codeToGlyph(font, cc));\n      }\n\n      const gsub = font['GSUB'];\n      if (gsub) {\n        const {lookupList, featureList} = gsub;\n        let joiningForms;\n        const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;\n        const usedLookups = [];\n        featureList.forEach(feature => {\n          if (supportedFeatures.test(feature.tag)) {\n            for (let ti = 0; ti < feature.tab.length; ti++) {\n              if (usedLookups[feature.tab[ti]]) continue\n              usedLookups[feature.tab[ti]] = true;\n              const tab = lookupList[feature.tab[ti]];\n              const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n              if (isJoiningFeature && !joiningForms) { //lazy\n                joiningForms = detectJoiningForms(str);\n              }\n              for (let ci = 0; ci < glyphIds.length; ci++) {\n                if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                  Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n                }\n              }\n            }\n          }\n        });\n      }\n\n      return glyphIds\n    }\n\n    function firstNum(...args) {\n      for (let i = 0; i < args.length; i++) {\n        if (typeof args[i] === 'number') {\n          return args[i]\n        }\n      }\n    }\n\n    function wrapFontObj(typrFont) {\n      const glyphMap = Object.create(null);\n\n      const os2 = typrFont['OS/2'];\n      const hhea = typrFont.hhea;\n      const unitsPerEm = typrFont.head.unitsPerEm;\n      const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n\n      const fontObj = {\n        unitsPerEm,\n        ascender,\n        descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n        capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n        xHeight: firstNum(os2 && os2.sxHeight, ascender),\n        lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n        forEachGlyph(text, fontSize, letterSpacing, callback) {\n          let glyphX = 0;\n          const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n          const glyphIndices = stringToGlyphs(typrFont, text);\n          let charIndex = 0;\n          let prevGlyphIndex = -1;\n          glyphIndices.forEach((glyphIndex, i) => {\n            // Typr returns a glyph index per string codepoint, with -1s in place of those that\n            // were omitted due to ligature substitution. So we can track original index in the\n            // string via simple increment, and skip everything else when seeing a -1.\n            if (glyphIndex !== -1) {\n              let glyphObj = glyphMap[glyphIndex];\n              if (!glyphObj) {\n                const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphIndex);\n\n                // Build path string\n                let path = '';\n                let crdsIdx = 0;\n                for (let i = 0, len = cmds.length; i < len; i++) {\n                  const numArgs = cmdArgLengths[cmds[i]];\n                  path += cmds[i];\n                  for (let j = 1; j <= numArgs; j++) {\n                    path += (j > 1 ? ',' : '') + crds[crdsIdx++];\n                  }\n                }\n\n                // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n                // normalize the two, so it's simplest just to iterate ourselves.\n                let xMin, yMin, xMax, yMax;\n                if (crds.length) {\n                  xMin = yMin = Infinity;\n                  xMax = yMax = -Infinity;\n                  for (let i = 0, len = crds.length; i < len; i += 2) {\n                    let x = crds[i];\n                    let y = crds[i + 1];\n                    if (x < xMin) xMin = x;\n                    if (y < yMin) yMin = y;\n                    if (x > xMax) xMax = x;\n                    if (y > yMax) yMax = y;\n                  }\n                } else {\n                  xMin = xMax = yMin = yMax = 0;\n                }\n\n                glyphObj = glyphMap[glyphIndex] = {\n                  index: glyphIndex,\n                  advanceWidth: typrFont.hmtx.aWidth[glyphIndex],\n                  xMin,\n                  yMin,\n                  xMax,\n                  yMax,\n                  path,\n                  pathCommandCount: cmds.length,\n                  // forEachPathCommand(callback) {\n                  //   let argsIndex = 0\n                  //   const argsArray = []\n                  //   for (let i = 0, len = cmds.length; i < len; i++) {\n                  //     const numArgs = cmdArgLengths[cmds[i]]\n                  //     argsArray.length = 1 + numArgs\n                  //     argsArray[0] = cmds[i]\n                  //     for (let j = 1; j <= numArgs; j++) {\n                  //       argsArray[j] = crds[argsIndex++]\n                  //     }\n                  //     callback.apply(null, argsArray)\n                  //   }\n                  // }\n                };\n              }\n\n              // Kerning\n              if (prevGlyphIndex !== -1) {\n                glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;\n              }\n\n              callback.call(null, glyphObj, glyphX, charIndex);\n\n              if (glyphObj.advanceWidth) {\n                glyphX += glyphObj.advanceWidth * fontScale;\n              }\n              if (letterSpacing) {\n                glyphX += letterSpacing * fontSize;\n              }\n\n              prevGlyphIndex = glyphIndex;\n            }\n            charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n          });\n          return glyphX\n        }\n      };\n\n      return fontObj\n    }\n\n    return function parse(buffer) {\n      // Look to see if we have a WOFF file and convert it if so:\n      const peek = new Uint8Array(buffer, 0, 4);\n      const tag = Typr._bin.readASCII(peek, 0, 4);\n      if (tag === 'wOFF') {\n        buffer = woff2otf(buffer);\n      } else if (tag === 'wOF2') {\n        throw new Error('woff2 fonts not supported')\n      }\n      return wrapFontObj(Typr.parse(buffer)[0])\n    }\n  }\n\n\n  const workerModule = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'Typr Font Parser',\n    dependencies: [typrFactory, woff2otfFactory, parserFactory],\n    init(typrFactory, woff2otfFactory, parserFactory) {\n      const Typr = typrFactory();\n      const woff2otf = woff2otfFactory();\n      return parserFactory(Typr, woff2otf)\n    }\n  });\n\n  const CONFIG = {\n    defaultFontURL: 'https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff', //Roboto Regular\n    sdfGlyphSize: 64,\n    sdfMargin: 1 / 16,\n    sdfExponent: 9,\n    textureWidth: 2048\n  };\n  const tempColor = /*#__PURE__*/new three.Color();\n  let hasRequested = false;\n\n  function now$1() {\n    return (self.performance || Date).now()\n  }\n\n  /**\n   * Customizes the text builder configuration. This must be called prior to the first font processing\n   * request, and applies to all fonts.\n   *\n   * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n   *                 requests, in case none is specified or the specifiede font fails to load or parse.\n   *                 Defaults to \"Roboto Regular\" from Google Fonts.\n   * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n   *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n   *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n   *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n   *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n   *                 to 64 which is generally a good balance of size and quality.\n   * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n   *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n   *                 the glyph's path, with lower precision further away. Defaults to 9.\n   * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n   *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n   *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n   *                 Defaults to 1/16th of the glyph size.\n   * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n   *                 2048 which is a safe maximum texture dimension according to the stats at\n   *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n   *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n   *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n   *                 increase the glyph size and/or have an extraordinary number of glyphs.\n   */\n  function configureTextBuilder(config) {\n    if (hasRequested) {\n      console.warn('configureTextBuilder called after first font request; will be ignored.');\n    } else {\n      assign(CONFIG, config);\n    }\n  }\n\n  /**\n   * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n   * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n   *\n   *   {\n   *     [sdfGlyphSize]: {\n   *       glyphCount: number,\n   *       sdfGlyphSize: number,\n   *       sdfTexture: Texture,\n   *       sdfCanvas: HTMLCanvasElement,\n   *       contextLost: boolean,\n   *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n   *     }\n   *   }\n   */\n  const atlases = Object.create(null);\n\n  /**\n   * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n   * @property {object} parameters - The normalized input arguments to the render call.\n   * @property {Texture} sdfTexture - The SDF atlas texture.\n   * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n   * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n   * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n   * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n   * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n   * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n   *           three elements: the starting X, the ending X, and the bottom Y for the caret.\n   * @property {number} [caretHeight] - An appropriate height for all selection carets.\n   * @property {number} ascender - The font's ascender metric.\n   * @property {number} descender - The font's descender metric.\n   * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n   * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n   * @property {number} lineHeight - The final computed lineHeight measurement.\n   * @property {number} topBaseline - The y position of the top line's baseline.\n   * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n   *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n   *           equivalent to the dimensions of a block-level text element in CSS.\n   * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n   *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n   * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n   *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n   * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n   *           generation, typesetting, etc.\n   * @frozen\n   */\n\n  /**\n   * @callback getTextRenderInfo~callback\n   * @param {TroikaTextRenderInfo} textRenderInfo\n   */\n\n  /**\n   * Main entry point for requesting the data needed to render a text string with given font parameters.\n   * This is an asynchronous call, performing most of the logic in a web worker thread.\n   * @param {object} args\n   * @param {getTextRenderInfo~callback} callback\n   */\n  function getTextRenderInfo(args, callback) {\n    hasRequested = true;\n    args = assign({}, args);\n    const totalStart = now$1();\n\n    // Apply default font here to avoid a 'null' atlas, and convert relative\n    // URLs to absolute so they can be resolved in the worker\n    args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);\n\n    // Normalize text to a string\n    args.text = '' + args.text;\n\n    args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n\n    // Normalize colors\n    if (args.colorRanges != null) {\n      let colors = {};\n      for (let key in args.colorRanges) {\n        if (args.colorRanges.hasOwnProperty(key)) {\n          let val = args.colorRanges[key];\n          if (typeof val !== 'number') {\n            val = tempColor.set(val).getHex();\n          }\n          colors[key] = val;\n        }\n      }\n      args.colorRanges = colors;\n    }\n\n    Object.freeze(args);\n\n    // Init the atlas if needed\n    const {textureWidth, sdfExponent} = CONFIG;\n    const {sdfGlyphSize} = args;\n    const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);\n    let atlas = atlases[sdfGlyphSize];\n    if (!atlas) {\n      const canvas = document.createElement('canvas');\n      canvas.width = textureWidth;\n      canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n      atlas = atlases[sdfGlyphSize] = {\n        glyphCount: 0,\n        sdfGlyphSize,\n        sdfCanvas: canvas,\n        sdfTexture: new three.Texture(\n          canvas,\n          undefined,\n          undefined,\n          undefined,\n          three.LinearFilter,\n          three.LinearFilter\n        ),\n        contextLost: false,\n        glyphsByFont: new Map()\n      };\n      atlas.sdfTexture.generateMipmaps = false;\n      initContextLossHandling(atlas);\n    }\n\n    const {sdfTexture, sdfCanvas} = atlas;\n    let fontGlyphs = atlas.glyphsByFont.get(args.font);\n    if (!fontGlyphs) {\n      atlas.glyphsByFont.set(args.font, fontGlyphs = new Map());\n    }\n\n    // Issue request to the typesetting engine in the worker\n    typesetInWorker(args).then(result => {\n      const {glyphIds, glyphPositions, fontSize, unitsPerEm, timings} = result;\n      const neededSDFs = [];\n      const glyphBounds = new Float32Array(glyphIds.length * 4);\n      const fontSizeMult = fontSize / unitsPerEm;\n      let boundsIdx = 0;\n      let positionsIdx = 0;\n      const quadsStart = now$1();\n      glyphIds.forEach((glyphId, i) => {\n        let glyphInfo = fontGlyphs.get(glyphId);\n\n        // If this is a glyphId not seen before, add it to the atlas\n        if (!glyphInfo) {\n          const {path, pathBounds} = result.glyphData[glyphId];\n\n          // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n          // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n          // useful interpolated values and will be ignored anyway.\n          const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])\n            / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n\n          const atlasIndex = atlas.glyphCount++;\n          const sdfViewBox = [\n            pathBounds[0] - fontUnitsMargin,\n            pathBounds[1] - fontUnitsMargin,\n            pathBounds[2] + fontUnitsMargin,\n            pathBounds[3] + fontUnitsMargin,\n          ];\n          fontGlyphs.set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));\n\n          // Collect those that need SDF generation\n          neededSDFs.push(glyphInfo);\n        }\n\n        // Calculate bounds for renderable quads\n        // TODO can we get this back off the main thread?\n        const {sdfViewBox} = glyphInfo;\n        const posX = glyphPositions[positionsIdx++];\n        const posY = glyphPositions[positionsIdx++];\n        glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n        glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n        glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n        glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n\n        // Convert glyphId to SDF index for the shader\n        glyphIds[i] = glyphInfo.atlasIndex;\n      });\n      timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n\n      const sdfStart = now$1();\n      timings.sdf = {};\n\n      // Grow the texture height by power of 2 if needed\n      const currentHeight = sdfCanvas.height;\n      const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n      const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n      if (neededHeight > currentHeight) {\n        // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n        console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n        resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n        // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n        sdfTexture.dispose();\n      }\n\n      Promise.all(neededSDFs.map(glyphInfo =>\n        generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {\n          timings.sdf[glyphInfo.atlasIndex] = timing;\n        })\n      )).then(() => {\n        if (neededSDFs.length && !atlas.contextLost) {\n          safariPre15Workaround(atlas);\n          sdfTexture.needsUpdate = true;\n        }\n        timings.sdfTotal = now$1() - sdfStart;\n        timings.total = now$1() - totalStart;\n        // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n\n        // Invoke callback with the text layout arrays and updated texture\n        callback(Object.freeze({\n          parameters: args,\n          sdfTexture,\n          sdfGlyphSize,\n          sdfExponent,\n          glyphBounds,\n          glyphAtlasIndices: glyphIds,\n          glyphColors: result.glyphColors,\n          caretPositions: result.caretPositions,\n          caretHeight: result.caretHeight,\n          chunkedBounds: result.chunkedBounds,\n          ascender: result.ascender,\n          descender: result.descender,\n          lineHeight: result.lineHeight,\n          capHeight: result.capHeight,\n          xHeight: result.xHeight,\n          topBaseline: result.topBaseline,\n          blockBounds: result.blockBounds,\n          visibleBounds: result.visibleBounds,\n          timings: result.timings,\n        }));\n      });\n    });\n\n    // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n    // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n    // a head start on that process before SDFs actually start getting processed.\n    Promise.resolve().then(() => {\n      if (!atlas.contextLost) {\n        warmUpSDFCanvas(sdfCanvas);\n      }\n    });\n  }\n\n  function generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {\n    if (contextLost) {\n      // If the context is lost there's nothing we can do, just quit silently and let it\n      // get regenerated when the context is restored\n      return Promise.resolve({timing: -1})\n    }\n    const {textureWidth, sdfExponent} = CONFIG;\n    const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n    const squareIndex = Math.floor(atlasIndex / 4);\n    const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n    const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n    const channel = atlasIndex % 4;\n    return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)\n  }\n\n  function initContextLossHandling(atlas) {\n    const canvas = atlas.sdfCanvas;\n\n    /*\n    // Begin context loss simulation\n    if (!window.WebGLDebugUtils) {\n      let script = document.getElementById('WebGLDebugUtilsScript')\n      if (!script) {\n        script = document.createElement('script')\n        script.id = 'WebGLDebugUtils'\n        document.head.appendChild(script)\n        script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n      }\n      script.addEventListener('load', () => {\n        initContextLossHandling(atlas)\n      })\n      return\n    }\n    window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n    canvas.loseContextInNCalls(500)\n    canvas.addEventListener('webglcontextrestored', (event) => {\n      canvas.loseContextInNCalls(5000)\n    })\n    // End context loss simulation\n    */\n\n    canvas.addEventListener('webglcontextlost', (event) => {\n      console.log('Context Lost', event);\n      event.preventDefault();\n      atlas.contextLost = true;\n    });\n    canvas.addEventListener('webglcontextrestored', (event) => {\n      console.log('Context Restored', event);\n      atlas.contextLost = false;\n      // Regenerate all glyphs into the restored canvas:\n      const promises = [];\n      atlas.glyphsByFont.forEach(glyphMap => {\n        glyphMap.forEach(glyph => {\n          promises.push(generateGlyphSDF(glyph, atlas, true));\n        });\n      });\n      Promise.all(promises).then(() => {\n        safariPre15Workaround(atlas);\n        atlas.sdfTexture.needsUpdate = true;\n      });\n    });\n  }\n\n  /**\n   * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n   * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n   * needed fonts and glyphs up front along with other assets.\n   *\n   * @param {object} options\n   * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n   *        be loaded.\n   * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n   *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n   *        to specify ligature sequences in addition to their individual characters to get all\n   *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n   * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n   *        specified `characters`.\n   * @param {function} callback - A function that will be called when the preloading is complete.\n   */\n  function preloadFont({font, characters, sdfGlyphSize}, callback) {\n    let text = Array.isArray(characters) ? characters.join('\\n') : '' + characters;\n    getTextRenderInfo({ font, sdfGlyphSize, text }, callback);\n  }\n\n\n  // Local assign impl so we don't have to import troika-core\n  function assign(toObj, fromObj) {\n    for (let key in fromObj) {\n      if (fromObj.hasOwnProperty(key)) {\n        toObj[key] = fromObj[key];\n      }\n    }\n    return toObj\n  }\n\n  // Utility for making URLs absolute\n  let linkEl;\n  function toAbsoluteURL(path) {\n    if (!linkEl) {\n      linkEl = typeof document === 'undefined' ? {} : document.createElement('a');\n    }\n    linkEl.href = path;\n    return linkEl.href\n  }\n\n  /**\n   * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n   * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n   * a slight performance cost.\n   */\n  function safariPre15Workaround(atlas) {\n    // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n    // have supported it for a long while so any false positives should be minimal.\n    if (typeof createImageBitmap !== 'function') {\n      console.info('Safari<15: applying SDF canvas workaround');\n      const {sdfCanvas, sdfTexture} = atlas;\n      const {width, height} = sdfCanvas;\n      const gl = atlas.sdfCanvas.getContext('webgl');\n      let pixels = sdfTexture.image.data;\n      if (!pixels || pixels.length !== width * height * 4) {\n        pixels = new Uint8Array(width * height * 4);\n        sdfTexture.image = {width, height, data: pixels};\n        sdfTexture.flipY = false;\n        sdfTexture.isDataTexture = true;\n      }\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    }\n  }\n\n\n  const typesetterWorkerModule = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'Typesetter',\n    dependencies: [\n      CONFIG,\n      workerModule,\n      createTypesetter,\n      bidiFactory__default['default']\n    ],\n    init(config, fontParser, createTypesetter, bidiFactory) {\n      const {defaultFontURL} = config;\n      return createTypesetter(fontParser, bidiFactory(), { defaultFontURL })\n    }\n  });\n\n  const typesetInWorker = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'Typesetter',\n    dependencies: [\n      typesetterWorkerModule,\n    ],\n    init(typesetter) {\n      return function(args) {\n        return new Promise(resolve => {\n          typesetter.typeset(args, resolve);\n        })\n      }\n    },\n    getTransferables(result) {\n      // Mark array buffers as transferable to avoid cloning during postMessage\n      const transferables = [\n        result.glyphPositions.buffer,\n        result.glyphIds.buffer\n      ];\n      if (result.caretPositions) {\n        transferables.push(result.caretPositions.buffer);\n      }\n      if (result.glyphColors) {\n        transferables.push(result.glyphColors.buffer);\n      }\n      return transferables\n    }\n  });\n\n  function dumpSDFTextures() {\n    Object.keys(atlases).forEach(size => {\n      const canvas = atlases[size].sdfCanvas;\n      const {width, height} = canvas;\n      console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n    });\n  }\n\n  const templateGeometries = {};\n\n  function getTemplateGeometry(detail) {\n    let geom = templateGeometries[detail];\n    if (!geom) {\n      // Geometry is two planes back-to-back, which will always be rendered FrontSide only but\n      // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.\n      // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials\n      // introduced by Three.js in r130 - see https://github.com/mrdoob/three.js/pull/21967\n      const front = new three.PlaneGeometry(1, 1, detail, detail);\n      const back = front.clone();\n      const frontAttrs = front.attributes;\n      const backAttrs = back.attributes;\n      const combined = new three.BufferGeometry();\n      const vertCount = frontAttrs.uv.count;\n      for (let i = 0; i < vertCount; i++) {\n        backAttrs.position.array[i * 3] *= -1; // flip position x\n        backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z\n      }\n      ['position', 'normal', 'uv'].forEach(name => {\n        combined.setAttribute(name, new three.Float32BufferAttribute(\n          [...frontAttrs[name].array, ...backAttrs[name].array],\n          frontAttrs[name].itemSize)\n        );\n      });\n      combined.setIndex([...front.index.array, ...back.index.array.map(n => n + vertCount)]);\n      combined.translate(0.5, 0.5, 0);\n      geom = templateGeometries[detail] = combined;\n    }\n    return geom\n  }\n\n  const glyphBoundsAttrName = 'aTroikaGlyphBounds';\n  const glyphIndexAttrName = 'aTroikaGlyphIndex';\n  const glyphColorAttrName = 'aTroikaGlyphColor';\n\n  /**\n  @class GlyphsGeometry\n\n  A specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\n  render the glyphs using GPU instancing of a single quad, rather than constructing a whole\n  geometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n    Where N = number of glyphs...\n\n    Instanced:\n    - position: 4 * 3\n    - index: 2 * 3\n    - normal: 4 * 3\n    - uv: 4 * 2\n    - glyph x/y bounds: N * 4\n    - glyph indices: N * 1\n    = 5N + 38\n\n    Non-instanced:\n    - position: N * 4 * 3\n    - index: N * 2 * 3\n    - normal: N * 4 * 3\n    - uv: N * 4 * 2\n    - glyph indices: N * 1\n    = 39N\n\n  A downside of this is the rare-but-possible lack of the instanced arrays extension,\n  which we could potentially work around with a fallback non-instanced implementation.\n\n  */\n  class GlyphsGeometry extends three.InstancedBufferGeometry {\n    constructor() {\n      super();\n\n      this.detail = 1;\n      this.curveRadius = 0;\n\n      // Define groups for rendering text outline as a separate pass; these will only\n      // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n      this.groups = [\n        {start: 0, count: Infinity, materialIndex: 0},\n        {start: 0, count: Infinity, materialIndex: 1}\n      ];\n\n      // Preallocate empty bounding objects\n      this.boundingSphere = new three.Sphere();\n      this.boundingBox = new three.Box3();\n    }\n\n    computeBoundingSphere () {\n      // No-op; we'll sync the boundingSphere proactively when needed.\n    }\n\n    computeBoundingBox() {\n      // No-op; we'll sync the boundingBox proactively when needed.\n    }\n\n    // Since our base geometry contains triangles for both front and back sides, we can emulate\n    // the \"side\" by restricting the draw range.\n    setSide(side) {\n      const verts = this.getIndex().count;\n      this.setDrawRange(side === three.BackSide ? verts / 2 : 0, side === three.DoubleSide ? verts : verts / 2);\n    }\n\n    set detail(detail) {\n      if (detail !== this._detail) {\n        this._detail = detail;\n        if (typeof detail !== 'number' || detail < 1) {\n          detail = 1;\n        }\n        let tpl = getTemplateGeometry(detail)\n        ;['position', 'normal', 'uv'].forEach(attr => {\n          this.attributes[attr] = tpl.attributes[attr].clone();\n        });\n        this.setIndex(tpl.getIndex().clone());\n      }\n    }\n    get detail() {\n      return this._detail\n    }\n\n    set curveRadius(r) {\n      if (r !== this._curveRadius) {\n        this._curveRadius = r;\n        this._updateBounds();\n      }\n    }\n    get curveRadius() {\n      return this._curveRadius\n    }\n\n    /**\n     * Update the geometry for a new set of glyphs.\n     * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n     *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n     * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n     *        the SDF atlas texture.\n     * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n     * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n     *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n     *        used with `applyClipRect` to choose an optimized `instanceCount`.\n     * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n     */\n    updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n      // Update the instance attributes\n      updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);\n      updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);\n      updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);\n      this._blockBounds = blockBounds;\n      this._chunkedBounds = chunkedBounds;\n      this.instanceCount = glyphAtlasIndices.length;\n      this._updateBounds();\n    }\n\n    _updateBounds() {\n      const bounds = this._blockBounds;\n      if (bounds) {\n        const { curveRadius, boundingBox: bbox } = this;\n        if (curveRadius) {\n          const { PI, floor, min, max, sin, cos } = Math;\n          const halfPi = PI / 2;\n          const twoPi = PI * 2;\n          const absR = Math.abs(curveRadius);\n          const leftAngle = bounds[0] / absR;\n          const rightAngle = bounds[2] / absR;\n          const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)\n            ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n          const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)\n            ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n          const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)\n            ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n          bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n          bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n        } else {\n          bbox.min.set(bounds[0], bounds[1], 0);\n          bbox.max.set(bounds[2], bounds[3], 0);\n        }\n        bbox.getBoundingSphere(this.boundingSphere);\n      }\n    }\n\n    /**\n     * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n     * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n     * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n     * be clipped anyway.\n     *\n     * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n     * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n     * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n     * but at the expense of much larger attribute buffers (see classdoc above.)\n     *\n     * @param {Vector4} clipRect\n     */\n    applyClipRect(clipRect) {\n      let count = this.getAttribute(glyphIndexAttrName).count;\n      let chunks = this._chunkedBounds;\n      if (chunks) {\n        for (let i = chunks.length; i--;) {\n          count = chunks[i].end;\n          let rect = chunks[i].rect;\n          // note: both rects are l-b-r-t\n          if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n            break\n          }\n        }\n      }\n      this.instanceCount = count;\n    }\n  }\n\n\n  function updateBufferAttr(geom, attrName, newArray, itemSize) {\n    const attr = geom.getAttribute(attrName);\n    if (newArray) {\n      // If length isn't changing, just update the attribute's array data\n      if (attr && attr.array.length === newArray.length) {\n        attr.array.set(newArray);\n        attr.needsUpdate = true;\n      } else {\n        geom.setAttribute(attrName, new three.InstancedBufferAttribute(newArray, itemSize));\n        // If the new attribute has a different size, we also have to (as of r117) manually clear the\n        // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n        // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n        // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n        // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n        // implies it should be supported. It's possible we need to\n        delete geom._maxInstanceCount; //for r117+, could be fragile\n        geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n      }\n    } else if (attr) {\n      geom.deleteAttribute(attrName);\n    }\n  }\n\n  // language=GLSL\n  const VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n\n  // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n  const VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n\n  // language=GLSL\n  const FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */}\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${''/*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */}\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${''/* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */}\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n\n  // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n  const FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n\n\n  /**\n   * Create a material for rendering text, derived from a baseMaterial\n   */\n  function createTextDerivedMaterial(baseMaterial) {\n    const textMaterial = troikaThreeUtils.createDerivedMaterial(baseMaterial, {\n      chained: true,\n      extensions: {\n        derivatives: true\n      },\n      uniforms: {\n        uTroikaSDFTexture: {value: null},\n        uTroikaSDFTextureSize: {value: new three.Vector2()},\n        uTroikaSDFGlyphSize: {value: 0},\n        uTroikaSDFExponent: {value: 0},\n        uTroikaTotalBounds: {value: new three.Vector4(0,0,0,0)},\n        uTroikaClipRect: {value: new three.Vector4(0,0,0,0)},\n        uTroikaDistanceOffset: {value: 0},\n        uTroikaOutlineOpacity: {value: 0},\n        uTroikaFillOpacity: {value: 1},\n        uTroikaPositionOffset: {value: new three.Vector2()},\n        uTroikaCurveRadius: {value: 0},\n        uTroikaBlurRadius: {value: 0},\n        uTroikaStrokeWidth: {value: 0},\n        uTroikaStrokeColor: {value: new three.Color()},\n        uTroikaStrokeOpacity: {value: 1},\n        uTroikaOrient: {value: new three.Matrix3()},\n        uTroikaUseGlyphColors: {value: true},\n        uTroikaSDFDebug: {value: false}\n      },\n      vertexDefs: VERTEX_DEFS,\n      vertexTransform: VERTEX_TRANSFORM,\n      fragmentDefs: FRAGMENT_DEFS,\n      fragmentColorTransform: FRAGMENT_TRANSFORM,\n      customRewriter({vertexShader, fragmentShader}) {\n        let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n        if (uDiffuseRE.test(fragmentShader)) {\n          // Replace all instances of `diffuse` with our varying\n          fragmentShader = fragmentShader\n            .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')\n            .replace(/\\bdiffuse\\b/g, 'vTroikaGlyphColor');\n          // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n          if (!uDiffuseRE.test(vertexShader)) {\n            vertexShader = vertexShader.replace(\n              troikaThreeUtils.voidMainRegExp,\n              'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n'\n            );\n          }\n        }\n        return { vertexShader, fragmentShader }\n      }\n    });\n\n    // Force transparency - TODO is this reasonable?\n    textMaterial.transparent = true;\n\n    Object.defineProperties(textMaterial, {\n      isTroikaTextMaterial: {value: true},\n\n      // WebGLShadowMap reverses the side of the shadow material by default, which fails\n      // for planes, so here we force the `shadowSide` to always match the main side.\n      shadowSide: {\n        get() {\n          return this.side\n        },\n        set() {\n          //no-op\n        }\n      }\n    });\n\n    return textMaterial\n  }\n\n  const defaultMaterial = /*#__PURE__*/ new three.MeshBasicMaterial({\n    color: 0xffffff,\n    side: three.DoubleSide,\n    transparent: true\n  });\n  const defaultStrokeColor = 0x808080;\n\n  const tempMat4 = /*#__PURE__*/ new three.Matrix4();\n  const tempVec3a = /*#__PURE__*/ new three.Vector3();\n  const tempVec3b = /*#__PURE__*/ new three.Vector3();\n  const tempArray = [];\n  const origin = /*#__PURE__*/ new three.Vector3();\n  const defaultOrient = '+x+y';\n\n  function first(o) {\n    return Array.isArray(o) ? o[0] : o\n  }\n\n  let getFlatRaycastMesh = () => {\n    const mesh = new three.Mesh(\n      new three.PlaneGeometry(1, 1),\n      defaultMaterial\n    );\n    getFlatRaycastMesh = () => mesh;\n    return mesh\n  };\n  let getCurvedRaycastMesh = () => {\n    const mesh = new three.Mesh(\n      new three.PlaneGeometry(1, 1, 32, 1),\n      defaultMaterial\n    );\n    getCurvedRaycastMesh = () => mesh;\n    return mesh\n  };\n\n  const syncStartEvent = { type: 'syncstart' };\n  const syncCompleteEvent = { type: 'synccomplete' };\n\n  const SYNCABLE_PROPS = [\n    'font',\n    'fontSize',\n    'letterSpacing',\n    'lineHeight',\n    'maxWidth',\n    'overflowWrap',\n    'text',\n    'direction',\n    'textAlign',\n    'textIndent',\n    'whiteSpace',\n    'anchorX',\n    'anchorY',\n    'colorRanges',\n    'sdfGlyphSize'\n  ];\n\n  const COPYABLE_PROPS = SYNCABLE_PROPS.concat(\n    'material',\n    'color',\n    'depthOffset',\n    'clipRect',\n    'curveRadius',\n    'orientation',\n    'glyphGeometryDetail'\n  );\n\n  /**\n   * @class Text\n   *\n   * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n   * fields (SDF).\n   */\n  class Text extends three.Mesh {\n    constructor() {\n      const geometry = new GlyphsGeometry();\n      super(geometry, null);\n\n      // === Text layout properties: === //\n\n      /**\n       * @member {string} text\n       * The string of text to be rendered.\n       */\n      this.text = '';\n\n      /**\n       * @member {number|string} anchorX\n       * Defines the horizontal position in the text block that should line up with the local origin.\n       * Can be specified as a numeric x position in local units, a string percentage of the total\n       * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n       * or 'right'.\n       */\n      this.anchorX = 0;\n\n      /**\n       * @member {number|string} anchorX\n       * Defines the vertical position in the text block that should line up with the local origin.\n       * Can be specified as a numeric y position in local units (note: down is negative y), a string\n       * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n       * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n       */\n      this.anchorY = 0;\n\n      /**\n       * @member {number} curveRadius\n       * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n       * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n       * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n       * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n       *\n       * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n       * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n       */\n      this.curveRadius = 0;\n\n      /**\n       * @member {string} direction\n       * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n       * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n       */\n      this.direction = 'auto';\n\n      /**\n       * @member {string} font\n       * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n       * Defaults to the Roboto font loaded from Google Fonts.\n       */\n      this.font = null; //will use default from TextBuilder\n\n      /**\n       * @member {number} fontSize\n       * The size at which to render the font in local units; corresponds to the em-box height\n       * of the chosen `font`.\n       */\n      this.fontSize = 0.1;\n\n      /**\n       * @member {number} letterSpacing\n       * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n       * numbers increase spacing and negative numbers decrease it.\n       */\n      this.letterSpacing = 0;\n\n      /**\n       * @member {number|string} lineHeight\n       * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n       * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n       */\n      this.lineHeight = 'normal';\n\n      /**\n       * @member {number} maxWidth\n       * The maximum width of the text block, above which text may start wrapping according to the\n       * `whiteSpace` and `overflowWrap` properties.\n       */\n      this.maxWidth = Infinity;\n\n      /**\n       * @member {string} overflowWrap\n       * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n       * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n       * Defaults to `'normal'`.\n       */\n      this.overflowWrap = 'normal';\n\n      /**\n       * @member {string} textAlign\n       * The horizontal alignment of each line of text within the overall text bounding box.\n       */\n      this.textAlign = 'left';\n\n      /**\n       * @member {number} textIndent\n       * Indentation for the first character of a line; see CSS `text-indent`.\n       */\n      this.textIndent = 0;\n\n      /**\n       * @member {string} whiteSpace\n       * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n       * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n       * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n       * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n       */\n      this.whiteSpace = 'normal';\n\n\n      // === Presentation properties: === //\n\n      /**\n       * @member {THREE.Material} material\n       * Defines a _base_ material to be used when rendering the text. This material will be\n       * automatically replaced with a material derived from it, that adds shader code to\n       * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n       * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n       * of the other mesh materials to gain other features like lighting, texture maps, etc.\n       *\n       * Also see the `color` shortcut property.\n       */\n      this.material = null;\n\n      /**\n       * @member {string|number|THREE.Color} color\n       * This is a shortcut for setting the `color` of the text's material. You can use this\n       * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n       * `material`, this color will only be used for this particuar Text instance, even if\n       * that same material instance is shared across multiple Text objects.\n       */\n      this.color = null;\n\n      /**\n       * @member {object|null} colorRanges\n       * WARNING: This API is experimental and may change.\n       * This allows more fine-grained control of colors for individual or ranges of characters,\n       * taking precedence over the material's `color`. Its format is an Object whose keys each\n       * define a starting character index for a range, and whose values are the color for each\n       * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n       * any of the strings accepted by `THREE.Color`.\n       */\n      this.colorRanges = null;\n\n      /**\n       * @member {number|string} outlineWidth\n       * WARNING: This API is experimental and may change.\n       * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n       * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n       * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n       */\n      this.outlineWidth = 0;\n\n      /**\n       * @member {string|number|THREE.Color} outlineColor\n       * WARNING: This API is experimental and may change.\n       * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n       * Defaults to black.\n       */\n      this.outlineColor = 0x000000;\n\n      /**\n       * @member {number} outlineOpacity\n       * WARNING: This API is experimental and may change.\n       * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n       * Defaults to `1`.\n       */\n      this.outlineOpacity = 1;\n\n      /**\n       * @member {number|string} outlineBlur\n       * WARNING: This API is experimental and may change.\n       * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n       * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n       * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.outlineBlur = 0;\n\n      /**\n       * @member {number|string} outlineOffsetX\n       * WARNING: This API is experimental and may change.\n       * A horizontal offset for the text outline.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n       * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.outlineOffsetX = 0;\n\n      /**\n       * @member {number|string} outlineOffsetY\n       * WARNING: This API is experimental and may change.\n       * A vertical offset for the text outline.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n       * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.outlineOffsetY = 0;\n\n      /**\n       * @member {number|string} strokeWidth\n       * WARNING: This API is experimental and may change.\n       * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n       * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.strokeWidth = 0;\n\n      /**\n       * @member {string|number|THREE.Color} strokeColor\n       * WARNING: This API is experimental and may change.\n       * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n       */\n      this.strokeColor = defaultStrokeColor;\n\n      /**\n       * @member {number} strokeOpacity\n       * WARNING: This API is experimental and may change.\n       * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n       */\n      this.strokeOpacity = 1;\n\n      /**\n       * @member {number} fillOpacity\n       * WARNING: This API is experimental and may change.\n       * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n       * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n       * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n       */\n      this.fillOpacity = 1;\n\n      /**\n       * @member {number} depthOffset\n       * This is a shortcut for setting the material's `polygonOffset` and related properties,\n       * which can be useful in preventing z-fighting when this text is laid on top of another\n       * plane in the scene. Positive numbers are further from the camera, negatives closer.\n       */\n      this.depthOffset = 0;\n\n      /**\n       * @member {Array<number>} clipRect\n       * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n       * pixels will be discarded. This can be used for example to clip overflowing text when\n       * `whiteSpace='nowrap'`.\n       */\n      this.clipRect = null;\n\n      /**\n       * @member {string} orientation\n       * Defines the axis plane on which the text should be laid out when the mesh has no extra\n       * rotation transform. It is specified as a string with two axes: the horizontal axis with\n       * positive pointing right, and the vertical axis with positive pointing up. By default this\n       * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n       * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n       * top toward negative z and facing positive y.\n       */\n      this.orientation = defaultOrient;\n\n      /**\n       * @member {number} glyphGeometryDetail\n       * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n       * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n       * vertex shader effects, for example.\n       */\n      this.glyphGeometryDetail = 1;\n\n      /**\n       * @member {number|null} sdfGlyphSize\n       * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n       * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n       * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n       * the sharpness of corners and preventing loss of very thin lines, at the expense of\n       * increased memory footprint and longer SDF generation time.\n       */\n      this.sdfGlyphSize = null;\n\n      /**\n       * @member {boolean} gpuAccelerateSDF\n       * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n       * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n       * executed in web workers when support isn't available. It should automatically detect support,\n       * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n       * version if you encounter issues with it.\n       */\n      this.gpuAccelerateSDF = true;\n\n      this.debugSDF = false;\n    }\n\n    /**\n     * Updates the text rendering according to the current text-related configuration properties.\n     * This is an async process, so you can pass in a callback function to be executed when it\n     * finishes.\n     * @param {function} [callback]\n     */\n    sync(callback) {\n      if (this._needsSync) {\n        this._needsSync = false;\n\n        // If there's another sync still in progress, queue\n        if (this._isSyncing) {\n          (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n        } else {\n          this._isSyncing = true;\n          this.dispatchEvent(syncStartEvent);\n\n          getTextRenderInfo({\n            text: this.text,\n            font: this.font,\n            fontSize: this.fontSize || 0.1,\n            letterSpacing: this.letterSpacing || 0,\n            lineHeight: this.lineHeight || 'normal',\n            maxWidth: this.maxWidth,\n            direction: this.direction || 'auto',\n            textAlign: this.textAlign,\n            textIndent: this.textIndent,\n            whiteSpace: this.whiteSpace,\n            overflowWrap: this.overflowWrap,\n            anchorX: this.anchorX,\n            anchorY: this.anchorY,\n            colorRanges: this.colorRanges,\n            includeCaretPositions: true, //TODO parameterize\n            sdfGlyphSize: this.sdfGlyphSize,\n            gpuAccelerateSDF: this.gpuAccelerateSDF,\n          }, textRenderInfo => {\n            this._isSyncing = false;\n\n            // Save result for later use in onBeforeRender\n            this._textRenderInfo = textRenderInfo;\n\n            // Update the geometry attributes\n            this.geometry.updateGlyphs(\n              textRenderInfo.glyphBounds,\n              textRenderInfo.glyphAtlasIndices,\n              textRenderInfo.blockBounds,\n              textRenderInfo.chunkedBounds,\n              textRenderInfo.glyphColors\n            );\n\n            // If we had extra sync requests queued up, kick it off\n            const queued = this._queuedSyncs;\n            if (queued) {\n              this._queuedSyncs = null;\n              this._needsSync = true;\n              this.sync(() => {\n                queued.forEach(fn => fn && fn());\n              });\n            }\n\n            this.dispatchEvent(syncCompleteEvent);\n            if (callback) {\n              callback();\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * Initiate a sync if needed - note it won't complete until next frame at the\n     * earliest so if possible it's a good idea to call sync() manually as soon as\n     * all the properties have been set.\n     * @override\n     */\n    onBeforeRender(renderer, scene, camera, geometry, material, group) {\n      this.sync();\n\n      // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n      if (material.isTroikaTextMaterial) {\n        this._prepareForRender(material);\n      }\n\n      // We need to force the material to FrontSide to avoid the double-draw-call performance hit\n      // introduced in Three.js r130: https://github.com/mrdoob/three.js/pull/21967 - The sidedness\n      // is instead applied via drawRange in the GlyphsGeometry.\n      material._hadOwnSide = material.hasOwnProperty('side');\n      this.geometry.setSide(material._actualSide = material.side);\n      material.side = three.FrontSide;\n    }\n\n    onAfterRender(renderer, scene, camera, geometry, material, group) {\n      // Restore original material side\n      if (material._hadOwnSide) {\n        material.side = material._actualSide;\n      } else {\n        delete material.side; // back to inheriting from base material\n      }\n    }\n\n    /**\n     * Shortcut to dispose the geometry specific to this instance.\n     * Note: we don't also dispose the derived material here because if anything else is\n     * sharing the same base material it will result in a pause next frame as the program\n     * is recompiled. Instead users can dispose the base material manually, like normal,\n     * and we'll also dispose the derived material at that time.\n     */\n    dispose() {\n      this.geometry.dispose();\n    }\n\n    /**\n     * @property {TroikaTextRenderInfo|null} textRenderInfo\n     * @readonly\n     * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n     * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n     * the asynchrous `sync()` process completes.\n     */\n    get textRenderInfo() {\n      return this._textRenderInfo || null\n    }\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n      let derivedMaterial = this._derivedMaterial;\n      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      // If text outline is configured, render it as a preliminary draw using Three's multi-material\n      // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n      // materials ensures the layers are always rendered consecutively in a consistent order.\n      // Each layer will trigger onBeforeRender with the appropriate material.\n      if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {\n        let outlineMaterial = derivedMaterial._outlineMtl;\n        if (!outlineMaterial) {\n          outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n            id: {value: derivedMaterial.id + 0.1}\n          });\n          outlineMaterial.isTextOutlineMaterial = true;\n          outlineMaterial.depthWrite = false;\n          outlineMaterial.map = null; //???\n          derivedMaterial.addEventListener('dispose', function onDispose() {\n            derivedMaterial.removeEventListener('dispose', onDispose);\n            outlineMaterial.dispose();\n          });\n        }\n        return [\n          outlineMaterial,\n          derivedMaterial\n        ]\n      } else {\n        return derivedMaterial\n      }\n    }\n    set material(baseMaterial) {\n      if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation\n        this._derivedMaterial = baseMaterial;\n        this._baseMaterial = baseMaterial.baseMaterial;\n      } else {\n        this._baseMaterial = baseMaterial;\n      }\n    }\n\n    get glyphGeometryDetail() {\n      return this.geometry.detail\n    }\n    set glyphGeometryDetail(detail) {\n      this.geometry.detail = detail;\n    }\n\n    get curveRadius() {\n      return this.geometry.curveRadius\n    }\n    set curveRadius(r) {\n      this.geometry.curveRadius = r;\n    }\n\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n      return first(this.material).getDepthMaterial()\n    }\n    get customDistanceMaterial() {\n      return first(this.material).getDistanceMaterial()\n    }\n\n    _prepareForRender(material) {\n      const isOutline = material.isTextOutlineMaterial;\n      const uniforms = material.uniforms;\n      const textInfo = this.textRenderInfo;\n      if (textInfo) {\n        const {sdfTexture, blockBounds} = textInfo;\n        uniforms.uTroikaSDFTexture.value = sdfTexture;\n        uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n        uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n        uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n        uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n        uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n\n        let distanceOffset = 0;\n        let blurRadius = 0;\n        let strokeWidth = 0;\n        let fillOpacity;\n        let strokeOpacity;\n        let strokeColor;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isOutline) {\n          let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;\n          distanceOffset = this._parsePercent(outlineWidth) || 0;\n          blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n          fillOpacity = outlineOpacity;\n          offsetX = this._parsePercent(outlineOffsetX) || 0;\n          offsetY = this._parsePercent(outlineOffsetY) || 0;\n        } else {\n          strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n          if (strokeWidth) {\n            strokeColor = this.strokeColor;\n            uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n            strokeOpacity = this.strokeOpacity;\n            if (strokeOpacity == null) strokeOpacity = 1;\n          }\n          fillOpacity = this.fillOpacity;\n        }\n\n        uniforms.uTroikaDistanceOffset.value = distanceOffset;\n        uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n        uniforms.uTroikaBlurRadius.value = blurRadius;\n        uniforms.uTroikaStrokeWidth.value = strokeWidth;\n        uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n        uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n        uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n\n        let clipRect = this.clipRect;\n        if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n          uniforms.uTroikaClipRect.value.fromArray(clipRect);\n        } else {\n          // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n          const pad = (this.fontSize || 0.1) * 100;\n          uniforms.uTroikaClipRect.value.set(\n            blockBounds[0] - pad,\n            blockBounds[1] - pad,\n            blockBounds[2] + pad,\n            blockBounds[3] + pad\n          );\n        }\n        this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n      }\n      uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n      material.polygonOffset = !!this.depthOffset;\n      material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n      // Shortcut for setting material color via `color` prop on the mesh; this is\n      // applied only to the derived material to avoid mutating a shared base material.\n      const color = isOutline ? (this.outlineColor || 0) : this.color;\n\n      if (color == null) {\n        delete material.color; //inherit from base\n      } else {\n        const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new three.Color());\n        if (color !== colorObj._input || typeof color === 'object') {\n          colorObj.set(colorObj._input = color);\n        }\n      }\n\n      // base orientation\n      let orient = this.orientation || defaultOrient;\n      if (orient !== material._orientation) {\n        let rotMat = uniforms.uTroikaOrient.value;\n        orient = orient.replace(/[^-+xyz]/g, '');\n        let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n        if (match) {\n          let [, hSign, hAxis, vSign, vAxis] = match;\n          tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;\n          tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;\n          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n          rotMat.setFromMatrix4(tempMat4);\n        } else {\n          rotMat.identity();\n        }\n        material._orientation = orient;\n      }\n    }\n\n    _parsePercent(value) {\n      if (typeof value === 'string') {\n        let match = value.match(/^(-?[\\d.]+)%$/);\n        let pct = match ? parseFloat(match[1]) : NaN;\n        value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n      }\n      return value\n    }\n\n    /**\n     * Translate a point in local space to an x/y in the text plane.\n     */\n    localPositionToTextCoords(position, target = new three.Vector2()) {\n      target.copy(position); //simple non-curved case is 1:1\n      const r = this.curveRadius;\n      if (r) { //flatten the curve\n        target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n      }\n      return target\n    }\n\n    /**\n     * Translate a point in world space to an x/y in the text plane.\n     */\n    worldPositionToTextCoords(position, target = new three.Vector2()) {\n      tempVec3a.copy(position);\n      return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)\n    }\n\n    /**\n     * @override Custom raycasting to test against the whole text block's max rectangular bounds\n     * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n     */\n    raycast(raycaster, intersects) {\n      const {textRenderInfo, curveRadius} = this;\n      if (textRenderInfo) {\n        const bounds = textRenderInfo.blockBounds;\n        const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n        const geom = raycastMesh.geometry;\n        const {position, uv} = geom.attributes;\n        for (let i = 0; i < uv.count; i++) {\n          let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));\n          const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));\n          let z = 0;\n          if (curveRadius) {\n            z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n            x = Math.sin(x / curveRadius) * curveRadius;\n          }\n          position.setXYZ(i, x, y, z);\n        }\n        geom.boundingSphere = this.geometry.boundingSphere;\n        geom.boundingBox = this.geometry.boundingBox;\n        raycastMesh.matrixWorld = this.matrixWorld;\n        raycastMesh.material.side = this.material.side;\n        tempArray.length = 0;\n        raycastMesh.raycast(raycaster, tempArray);\n        for (let i = 0; i < tempArray.length; i++) {\n          tempArray[i].object = this;\n          intersects.push(tempArray[i]);\n        }\n      }\n    }\n\n    copy(source) {\n      // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n      const geom = this.geometry;\n      super.copy(source);\n      this.geometry = geom;\n\n      COPYABLE_PROPS.forEach(prop => {\n        this[prop] = source[prop];\n      });\n      return this\n    }\n\n    clone() {\n      return new this.constructor().copy(this)\n    }\n  }\n\n\n  // Create setters for properties that affect text layout:\n  SYNCABLE_PROPS.forEach(prop => {\n    const privateKey = '_private_' + prop;\n    Object.defineProperty(Text.prototype, prop, {\n      get() {\n        return this[privateKey]\n      },\n      set(value) {\n        if (value !== this[privateKey]) {\n          this[privateKey] = value;\n          this._needsSync = true;\n        }\n      }\n    });\n  });\n\n  //=== Utility functions for dealing with carets and selection ranges ===//\n\n  /**\n   * @typedef {object} TextCaret\n   * @property {number} x - x position of the caret\n   * @property {number} y - y position of the caret's bottom\n   * @property {number} height - height of the caret\n   * @property {number} charIndex - the index in the original input string of this caret's target\n   *   character; the caret will be for the position _before_ that character.\n   */\n\n  /**\n   * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n   * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n   * @param {number} x\n   * @param {number} y\n   * @return {TextCaret | null}\n   */\n  function getCaretAtPoint(textRenderInfo, x, y) {\n    let closestCaret = null;\n    const {caretHeight} = textRenderInfo;\n    const caretsByRow = groupCaretsByRow(textRenderInfo);\n\n    // Find nearest row by y first\n    let closestRowY = Infinity;\n    caretsByRow.forEach((carets, rowY) => {\n      if (Math.abs(y - (rowY + caretHeight / 2)) < Math.abs(y - (closestRowY + caretHeight / 2))) {\n        closestRowY = rowY;\n      }\n    });\n\n    // Then find closest caret by x within that row\n    caretsByRow.get(closestRowY).forEach(caret => {\n      if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n        closestCaret = caret;\n      }\n    });\n    return closestCaret\n  }\n\n\n  const _rectsCache = new WeakMap();\n\n  /**\n   * Given start and end character indexes, return a list of rectangles covering all the\n   * characters within that selection.\n   * @param {TroikaTextRenderInfo} textRenderInfo\n   * @param {number} start - index of the first char in the selection\n   * @param {number} end - index of the first char after the selection\n   * @return {Array<{left, top, right, bottom}> | null}\n   */\n  function getSelectionRects(textRenderInfo, start, end) {\n    let rects;\n    if (textRenderInfo) {\n      // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n      let prevResult = _rectsCache.get(textRenderInfo);\n      if (prevResult && prevResult.start === start && prevResult.end === end) {\n        return prevResult.rects\n      }\n\n      const {caretPositions, caretHeight} = textRenderInfo;\n\n      // Normalize\n      if (end < start) {\n        const s = start;\n        start = end;\n        end = s;\n      }\n      start = Math.max(start, 0);\n      end = Math.min(end, caretPositions.length + 1);\n\n      // Build list of rects, expanding the current rect for all characters in a run and starting\n      // a new rect whenever reaching a new line or a new bidi direction\n      rects = [];\n      let currentRect = null;\n      for (let i = start; i < end; i++) {\n        const x1 = caretPositions[i * 3];\n        const x2 = caretPositions[i * 3 + 1];\n        const left = Math.min(x1, x2);\n        const right = Math.max(x1, x2);\n        const bottom = caretPositions[i * 3 + 2];\n        if (!currentRect || bottom !== currentRect.bottom || left > currentRect.right || right < currentRect.left) {\n          currentRect = {\n            left: Infinity,\n            right: -Infinity,\n            bottom: bottom,\n            top: bottom + caretHeight\n          };\n          rects.push(currentRect);\n        }\n        currentRect.left = Math.min(left, currentRect.left);\n        currentRect.right = Math.max(right, currentRect.right);\n      }\n\n      // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n      rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);\n      for (let i = rects.length - 1; i-- > 0;) {\n        const rectA = rects[i];\n        const rectB = rects[i + 1];\n        if (rectA.bottom === rectB.bottom && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n          rectB.left = Math.min(rectB.left, rectA.left);\n          rectB.right = Math.max(rectB.right, rectA.right);\n          rects.splice(i, 1);\n        }\n      }\n\n      _rectsCache.set(textRenderInfo, {start, end, rects});\n    }\n    return rects\n  }\n\n  const _caretsByRowCache = new WeakMap();\n\n  function groupCaretsByRow(textRenderInfo) {\n    // textRenderInfo is frozen so it's safe to cache based on it\n    let caretsByRow = _caretsByRowCache.get(textRenderInfo);\n    if (!caretsByRow) {\n      const {caretPositions, caretHeight} = textRenderInfo;\n      caretsByRow = new Map();\n      for (let i = 0; i < caretPositions.length; i += 3) {\n        const rowY = caretPositions[i + 2];\n        let rowCarets = caretsByRow.get(rowY);\n        if (!rowCarets) {\n          caretsByRow.set(rowY, rowCarets = []);\n        }\n        rowCarets.push({\n          x: caretPositions[i],\n          y: rowY,\n          height: caretHeight,\n          charIndex: i / 3\n        });\n        // Add one more caret after the final char\n        if (i + 3 >= caretPositions.length) {\n          rowCarets.push({\n            x: caretPositions[i + 1],\n            y: rowY,\n            height: caretHeight,\n            charIndex: i / 3 + 1\n          });\n        }\n      }\n    }\n    _caretsByRowCache.set(textRenderInfo, caretsByRow);\n    return caretsByRow\n  }\n\n  exports.GlyphsGeometry = GlyphsGeometry;\n  exports.Text = Text;\n  exports.configureTextBuilder = configureTextBuilder;\n  exports.createTextDerivedMaterial = createTextDerivedMaterial;\n  exports.dumpSDFTextures = dumpSDFTextures;\n  exports.getCaretAtPoint = getCaretAtPoint;\n  exports.getSelectionRects = getSelectionRects;\n  exports.preloadFont = preloadFont;\n  exports.typesetterWorkerModule = typesetterWorkerModule;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHlEQUFPLEdBQUcsbUJBQU8sQ0FBQyxxR0FBcUIsR0FBRyxtQkFBTyxDQUFDLGlHQUFxQixHQUFHLG1CQUFPLENBQUMsMERBQVMsR0FBRyxtQkFBTyxDQUFDLGtHQUFvQjtBQUNwTixFQUFFLENBQ21PO0FBQ3JPLENBQUMsMEdBQTBHOztBQUUzRyx1Q0FBdUMsNERBQTREOztBQUVuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQXVCOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSSxFQUFFLGlDQUFpQyxpQkFBaUI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsT0FBTyx5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsNkJBQTZCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWZyb250Ly4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS10ZXh0L2Rpc3QvdHJvaWthLXRocmVlLXRleHQudW1kLmpzP2Q0OTIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCd0aHJlZScpLCByZXF1aXJlKCd0cm9pa2Etd29ya2VyLXV0aWxzJyksIHJlcXVpcmUoJ3dlYmdsLXNkZi1nZW5lcmF0b3InKSwgcmVxdWlyZSgnYmlkaS1qcycpLCByZXF1aXJlKCd0cm9pa2EtdGhyZWUtdXRpbHMnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3RocmVlJywgJ3Ryb2lrYS13b3JrZXItdXRpbHMnLCAnd2ViZ2wtc2RmLWdlbmVyYXRvcicsICdiaWRpLWpzJywgJ3Ryb2lrYS10aHJlZS11dGlscyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnRyb2lrYV90aHJlZV90ZXh0ID0ge30sIGdsb2JhbC5USFJFRSwgZ2xvYmFsLnRyb2lrYV93b3JrZXJfdXRpbHMsIGdsb2JhbC53ZWJnbF9zZGZfZ2VuZXJhdG9yLCBnbG9iYWwuYmlkaV9qcywgZ2xvYmFsLnRyb2lrYV90aHJlZV91dGlscykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIHRocmVlLCB0cm9pa2FXb3JrZXJVdGlscywgY3JlYXRlU0RGR2VuZXJhdG9yLCBiaWRpRmFjdG9yeSwgdHJvaWthVGhyZWVVdGlscykgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbiAgdmFyIGNyZWF0ZVNERkdlbmVyYXRvcl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koY3JlYXRlU0RGR2VuZXJhdG9yKTtcbiAgdmFyIGJpZGlGYWN0b3J5X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShiaWRpRmFjdG9yeSk7XG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc2VsZi1jb250YWluZWQgZW52aXJvbm1lbnQgZm9yIHByb2Nlc3NpbmcgdGV4dCB0eXBlc2V0dGluZyByZXF1ZXN0cy5cbiAgICpcbiAgICogSXQgaXMgaW1wb3J0YW50IHRoYXQgdGhpcyBmdW5jdGlvbiBoYXMgbm8gY2xvc3VyZSBkZXBlbmRlbmNpZXMsIHNvIHRoYXQgaXQgY2FuIGJlIGVhc2lseSBpbmplY3RlZFxuICAgKiBpbnRvIHRoZSBzb3VyY2UgZm9yIGEgV29ya2VyIHdpdGhvdXQgcmVxdWlyaW5nIGEgYnVpbGQgc3RlcCBvciBjb21wbGV4IGRlcGVuZGVuY3kgbG9hZGluZy4gQWxsIGl0c1xuICAgKiBkZXBlbmRlbmNpZXMgbXVzdCBiZSBwYXNzZWQgaW4gYXQgaW5pdGlhbGl6YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZvbnRQYXJzZXIgLSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBBcnJheUJ1ZmZlciBvZiB0aGUgZm9udCBkYXRhIGFuZCByZXR1cm5zXG4gICAqIGEgc3RhbmRhcmRpemVkIHN0cnVjdHVyZSBnaXZpbmcgYWNjZXNzIHRvIHRoZSBmb250IGFuZCBpdHMgZ2x5cGhzOlxuICAgKiAgIHtcbiAgICogICAgIHVuaXRzUGVyRW06IG51bWJlcixcbiAgICogICAgIGFzY2VuZGVyOiBudW1iZXIsXG4gICAqICAgICBkZXNjZW5kZXI6IG51bWJlcixcbiAgICogICAgIGNhcEhlaWdodDogbnVtYmVyLFxuICAgKiAgICAgeEhlaWdodDogbnVtYmVyLFxuICAgKiAgICAgbGluZUdhcDogbnVtYmVyLFxuICAgKiAgICAgZm9yRWFjaEdseXBoKHN0cmluZywgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIGNhbGxiYWNrKSB7XG4gICAqICAgICAgIC8vaW52b2tlcyBjYWxsYmFjayBmb3IgZWFjaCBnbHlwaCB0byByZW5kZXIsIHBhc3NpbmcgaXQgYW4gb2JqZWN0OlxuICAgKiAgICAgICBjYWxsYmFjayh7XG4gICAqICAgICAgICAgaW5kZXg6IG51bWJlcixcbiAgICogICAgICAgICBhZHZhbmNlV2lkdGg6IG51bWJlcixcbiAgICogICAgICAgICB4TWluOiBudW1iZXIsXG4gICAqICAgICAgICAgeU1pbjogbnVtYmVyLFxuICAgKiAgICAgICAgIHhNYXg6IG51bWJlcixcbiAgICogICAgICAgICB5TWF4OiBudW1iZXIsXG4gICAqICAgICAgICAgcGF0aDogc3RyaW5nLFxuICAgKiAgICAgICAgIHBhdGhDb21tYW5kQ291bnQ6IG51bWJlclxuICAgKiAgICAgICB9KVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogQHBhcmFtIHtvYmplY3R9IGJpZGkgLSB0aGUgYmlkaS5qcyBpbXBsZW1lbnRhdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVUeXBlc2V0dGVyKGZvbnRQYXJzZXIsIGJpZGksIGNvbmZpZykge1xuXG4gICAgY29uc3Qge1xuICAgICAgZGVmYXVsdEZvbnRVUkxcbiAgICB9ID0gY29uZmlnO1xuXG4gICAgLyoqXG4gICAgICogSG9sZHMgcGFyc2VkIGZvbnQgb2JqZWN0cyBieSB1cmxcbiAgICAgKi9cbiAgICBjb25zdCBmb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBjb25zdCBJTkYgPSBJbmZpbml0eTtcblxuICAgIC8vIFNldCBvZiBVbmljb2RlIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgY2hhcmFjdGVycywgdGhlc2Ugd2lsbCBub3QgcHJvZHVjZSB2aXNpYmxlIGdseXBoc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuICAgIGNvbnN0IERFRkFVTFRfSUdOT1JBQkxFX0NIQVJTID0gL1tcXHUwMEFEXFx1MDM0RlxcdTA2MUNcXHUxMTVGLVxcdTExNjBcXHUxN0I0LVxcdTE3QjVcXHUxODBCLVxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNkZcXHUzMTY0XFx1RkUwMC1cXHVGRTBGXFx1RkVGRlxcdUZGQTBcXHVGRkYwLVxcdUZGRjhdLztcblxuICAgIC8vIFRoaXMgcmVnZXggKGluc3RlYWQgb2YgL1xccy8pIGFsbG93cyB1cyB0byBzZWxlY3QgYWxsIHdoaXRlc3BhY2UgRVhDRVBUIGZvciBub24tYnJlYWtpbmcgd2hpdGUgc3BhY2VzXG4gICAgY29uc3QgbGluZUJyZWFraW5nV2hpdGVTcGFjZSA9IGBbXlxcXFxTXFxcXHUwMEEwXWA7XG5cbiAgICAvLyBJbmNvbXBsZXRlIHNldCBvZiBjaGFyYWN0ZXJzIHRoYXQgYWxsb3cgbGluZSBicmVha2luZyBhZnRlciB0aGVtXG4gICAgLy8gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgY29uc2lkZXIgYSBmdWxsIFVuaWNvZGUgbGluZSBicmVha2luZyBhbGdvcml0aG0gaW1wbDogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjE0XG4gICAgY29uc3QgQlJFQUtfQUZURVJfQ0hBUlMgPSBuZXcgUmVnRXhwKGAke2xpbmVCcmVha2luZ1doaXRlU3BhY2V9fFtcXFxcLVxcXFx1MDA3Q1xcXFx1MDBBRFxcXFx1MjAxMFxcXFx1MjAxMi1cXFxcdTIwMTRcXFxcdTIwMjdcXFxcdTIwNTZcXFxcdTJFMTdcXFxcdTJFNDBdYCk7XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgZ2l2ZW4gZm9udCB1cmxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0xvYWRGb250KHVybCwgY2FsbGJhY2spIHtcbiAgICAgIGZ1bmN0aW9uIHRyeUxvYWQoKSB7XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWx1cmUgbG9hZGluZyBmb250ICR7dXJsfSR7dXJsID09PSBkZWZhdWx0Rm9udFVSTCA/ICcnIDogJzsgdHJ5aW5nIGZhbGxiYWNrJ31gLCBlcnIpO1xuICAgICAgICAgIGlmICh1cmwgIT09IGRlZmF1bHRGb250VVJMKSB7XG4gICAgICAgICAgICB1cmwgPSBkZWZhdWx0Rm9udFVSTDtcbiAgICAgICAgICAgIHRyeUxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHJlcXVlc3Qub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICAgIG9uRXJyb3IobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPiAwKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9udE9iaiA9IGZvbnRQYXJzZXIocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZm9udE9iaik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xuICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5TG9hZCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsIGlmIG5lZWRlZCwgaW52b2tpbmcgYSBjYWxsYmFjayB3aGVuIGl0J3MgbG9hZGVkLiBJZiBhbHJlYWR5XG4gICAgICogbG9hZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRm9udChmb250VXJsLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFmb250VXJsKSBmb250VXJsID0gZGVmYXVsdEZvbnRVUkw7XG4gICAgICBsZXQgZm9udCA9IGZvbnRzW2ZvbnRVcmxdO1xuICAgICAgaWYgKGZvbnQpIHtcbiAgICAgICAgLy8gaWYgY3VycmVudGx5IGxvYWRpbmcgZm9udCwgYWRkIHRvIGNhbGxiYWNrcywgb3RoZXJ3aXNlIGV4ZWN1dGUgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKGZvbnQucGVuZGluZykge1xuICAgICAgICAgIGZvbnQucGVuZGluZy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhmb250KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9udHNbZm9udFVybF0gPSB7cGVuZGluZzogW2NhbGxiYWNrXX07XG4gICAgICAgIGRvTG9hZEZvbnQoZm9udFVybCwgZm9udE9iaiA9PiB7XG4gICAgICAgICAgbGV0IGNhbGxiYWNrcyA9IGZvbnRzW2ZvbnRVcmxdLnBlbmRpbmc7XG4gICAgICAgICAgZm9udHNbZm9udFVybF0gPSBmb250T2JqO1xuICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKGZvbnRPYmopKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBNYWluIGVudHJ5IHBvaW50LlxuICAgICAqIFByb2Nlc3MgYSB0ZXh0IHN0cmluZyB3aXRoIGdpdmVuIGZvbnQgYW5kIGZvcm1hdHRpbmcgcGFyYW1ldGVycywgYW5kIHJldHVybiBhbGwgaW5mb1xuICAgICAqIG5lY2Vzc2FyeSB0byByZW5kZXIgYWxsIGl0cyBnbHlwaHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHlwZXNldChcbiAgICAgIHtcbiAgICAgICAgdGV4dD0nJyxcbiAgICAgICAgZm9udD1kZWZhdWx0Rm9udFVSTCxcbiAgICAgICAgc2RmR2x5cGhTaXplPTY0LFxuICAgICAgICBmb250U2l6ZT0xLFxuICAgICAgICBsZXR0ZXJTcGFjaW5nPTAsXG4gICAgICAgIGxpbmVIZWlnaHQ9J25vcm1hbCcsXG4gICAgICAgIG1heFdpZHRoPUlORixcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICB0ZXh0QWxpZ249J2xlZnQnLFxuICAgICAgICB0ZXh0SW5kZW50PTAsXG4gICAgICAgIHdoaXRlU3BhY2U9J25vcm1hbCcsXG4gICAgICAgIG92ZXJmbG93V3JhcD0nbm9ybWFsJyxcbiAgICAgICAgYW5jaG9yWCA9IDAsXG4gICAgICAgIGFuY2hvclkgPSAwLFxuICAgICAgICBpbmNsdWRlQ2FyZXRQb3NpdGlvbnM9ZmFsc2UsXG4gICAgICAgIGNodW5rZWRCb3VuZHNTaXplPTgxOTIsXG4gICAgICAgIGNvbG9yUmFuZ2VzPW51bGxcbiAgICAgIH0sXG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldHJpY3NPbmx5PWZhbHNlXG4gICAgKSB7XG4gICAgICBjb25zdCBtYWluU3RhcnQgPSBub3coKTtcbiAgICAgIGNvbnN0IHRpbWluZ3MgPSB7Zm9udExvYWQ6IDAsIHR5cGVzZXR0aW5nOiAwfTtcblxuICAgICAgLy8gRW5zdXJlIG5ld2xpbmVzIGFyZSBub3JtYWxpemVkXG4gICAgICBpZiAodGV4dC5pbmRleE9mKCdcXHInKSA+IC0xKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnVHlwZXNldHRlcjogZ290IHRleHQgd2l0aCBcXFxcciBjaGFyczsgbm9ybWFsaXppbmcgdG8gXFxcXG4nKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgd2UndmUgZ290IG51bWJlcnMgbm90IHN0cmluZ3NcbiAgICAgIGZvbnRTaXplID0gK2ZvbnRTaXplO1xuICAgICAgbGV0dGVyU3BhY2luZyA9ICtsZXR0ZXJTcGFjaW5nO1xuICAgICAgbWF4V2lkdGggPSArbWF4V2lkdGg7XG4gICAgICBsaW5lSGVpZ2h0ID0gbGluZUhlaWdodCB8fCAnbm9ybWFsJztcbiAgICAgIHRleHRJbmRlbnQgPSArdGV4dEluZGVudDtcblxuICAgICAgbG9hZEZvbnQoZm9udCwgZm9udE9iaiA9PiB7XG4gICAgICAgIGNvbnN0IGhhc01heFdpZHRoID0gaXNGaW5pdGUobWF4V2lkdGgpO1xuICAgICAgICBsZXQgZ2x5cGhJZHMgPSBudWxsO1xuICAgICAgICBsZXQgZ2x5cGhQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgICBsZXQgZ2x5cGhEYXRhID0gbnVsbDtcbiAgICAgICAgbGV0IGdseXBoQ29sb3JzID0gbnVsbDtcbiAgICAgICAgbGV0IGNhcmV0UG9zaXRpb25zID0gbnVsbDtcbiAgICAgICAgbGV0IHZpc2libGVCb3VuZHMgPSBudWxsO1xuICAgICAgICBsZXQgY2h1bmtlZEJvdW5kcyA9IG51bGw7XG4gICAgICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgICBsZXQgcmVuZGVyYWJsZUdseXBoQ291bnQgPSAwO1xuICAgICAgICBsZXQgY2FuV3JhcCA9IHdoaXRlU3BhY2UgIT09ICdub3dyYXAnO1xuICAgICAgICBjb25zdCB7YXNjZW5kZXIsIGRlc2NlbmRlciwgdW5pdHNQZXJFbSwgbGluZUdhcCwgY2FwSGVpZ2h0LCB4SGVpZ2h0fSA9IGZvbnRPYmo7XG4gICAgICAgIHRpbWluZ3MuZm9udExvYWQgPSBub3coKSAtIG1haW5TdGFydDtcbiAgICAgICAgY29uc3QgdHlwZXNldFN0YXJ0ID0gbm93KCk7XG5cbiAgICAgICAgLy8gRmluZCBjb252ZXJzaW9uIGJldHdlZW4gbmF0aXZlIGZvbnQgdW5pdHMgYW5kIGZvbnRTaXplIHVuaXRzOyB0aGlzIHdpbGwgYWxyZWFkeSBiZSBkb25lXG4gICAgICAgIC8vIGZvciB0aGUgZ3gvZ3kgdmFsdWVzIGJlbG93IGJ1dCBldmVyeXRoaW5nIGVsc2Ugd2UnbGwgbmVlZCB0byBjb252ZXJ0XG4gICAgICAgIGNvbnN0IGZvbnRTaXplTXVsdCA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgYXBwcm9wcmlhdGUgdmFsdWUgZm9yICdub3JtYWwnIGxpbmUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBmb250J3MgYWN0dWFsIG1ldHJpY3NcbiAgICAgICAgLy8gVE9ETyB0aGlzIGRvZXMgbm90IGd1YXJhbnRlZSBpbmRpdmlkdWFsIGdseXBocyB3b24ndCBleGNlZWQgdGhlIGxpbmUgaGVpZ2h0LCBlLmcuIFJvYm90bzsgc2hvdWxkIHdlIHVzZSB5TWluL01heCBpbnN0ZWFkP1xuICAgICAgICBpZiAobGluZUhlaWdodCA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICBsaW5lSGVpZ2h0ID0gKGFzY2VuZGVyIC0gZGVzY2VuZGVyICsgbGluZUdhcCkgLyB1bml0c1BlckVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGxpbmUgaGVpZ2h0IGFuZCBsZWFkaW5nIGFkanVzdG1lbnRzXG4gICAgICAgIGxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ICogZm9udFNpemU7XG4gICAgICAgIGNvbnN0IGhhbGZMZWFkaW5nID0gKGxpbmVIZWlnaHQgLSAoYXNjZW5kZXIgLSBkZXNjZW5kZXIpICogZm9udFNpemVNdWx0KSAvIDI7XG4gICAgICAgIGNvbnN0IHRvcEJhc2VsaW5lID0gLShhc2NlbmRlciAqIGZvbnRTaXplTXVsdCArIGhhbGZMZWFkaW5nKTtcbiAgICAgICAgY29uc3QgY2FyZXRIZWlnaHQgPSBNYXRoLm1pbihsaW5lSGVpZ2h0LCAoYXNjZW5kZXIgLSBkZXNjZW5kZXIpICogZm9udFNpemVNdWx0KTtcbiAgICAgICAgY29uc3QgY2FyZXRCb3R0b21PZmZzZXQgPSAoYXNjZW5kZXIgKyBkZXNjZW5kZXIpIC8gMiAqIGZvbnRTaXplTXVsdCAtIGNhcmV0SGVpZ2h0IC8gMjtcblxuICAgICAgICAvLyBEaXN0cmlidXRlIGdseXBocyBpbnRvIGxpbmVzIGJhc2VkIG9uIHdyYXBwaW5nXG4gICAgICAgIGxldCBsaW5lWE9mZnNldCA9IHRleHRJbmRlbnQ7XG4gICAgICAgIGxldCBjdXJyZW50TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICBjb25zdCBsaW5lcyA9IFtjdXJyZW50TGluZV07XG5cbiAgICAgICAgZm9udE9iai5mb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIChnbHlwaE9iaiwgZ2x5cGhYLCBjaGFySW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFyID0gdGV4dC5jaGFyQXQoY2hhckluZGV4KTtcbiAgICAgICAgICBjb25zdCBnbHlwaFdpZHRoID0gZ2x5cGhPYmouYWR2YW5jZVdpZHRoICogZm9udFNpemVNdWx0O1xuICAgICAgICAgIGNvbnN0IGN1ckxpbmVDb3VudCA9IGN1cnJlbnRMaW5lLmNvdW50O1xuICAgICAgICAgIGxldCBuZXh0TGluZTtcblxuICAgICAgICAgIC8vIENhbGMgaXNXaGl0ZXNwYWNlIGFuZCBpc0VtcHR5IG9uY2UgcGVyIGdseXBoT2JqXG4gICAgICAgICAgaWYgKCEoJ2lzRW1wdHknIGluIGdseXBoT2JqKSkge1xuICAgICAgICAgICAgZ2x5cGhPYmouaXNXaGl0ZXNwYWNlID0gISFjaGFyICYmIG5ldyBSZWdFeHAobGluZUJyZWFraW5nV2hpdGVTcGFjZSkudGVzdChjaGFyKTtcbiAgICAgICAgICAgIGdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIgPSAhIWNoYXIgJiYgQlJFQUtfQUZURVJfQ0hBUlMudGVzdChjaGFyKTtcbiAgICAgICAgICAgIGdseXBoT2JqLmlzRW1wdHkgPSBnbHlwaE9iai54TWluID09PSBnbHlwaE9iai54TWF4IHx8IGdseXBoT2JqLnlNaW4gPT09IGdseXBoT2JqLnlNYXggfHwgREVGQVVMVF9JR05PUkFCTEVfQ0hBUlMudGVzdChjaGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgIWdseXBoT2JqLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJlbmRlcmFibGVHbHlwaENvdW50Kys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgYSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIgb3ZlcmZsb3dzIHRoZSBtYXggd2lkdGgsIHdlIG5lZWQgdG8gc29mdC13cmFwXG4gICAgICAgICAgaWYgKGNhbldyYXAgJiYgaGFzTWF4V2lkdGggJiYgIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiBnbHlwaFggKyBnbHlwaFdpZHRoICsgbGluZVhPZmZzZXQgPiBtYXhXaWR0aCAmJiBjdXJMaW5lQ291bnQpIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgYSB3aGl0ZXNwYWNlLCBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmUuZ2x5cGhBdChjdXJMaW5lQ291bnQgLSAxKS5nbHlwaE9iai5jYW5CcmVha0FmdGVyKSB7XG4gICAgICAgICAgICAgIG5leHRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gLWdseXBoWDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEJhY2sgdXAgbG9va2luZyBmb3IgYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciB0byB3cmFwIGF0XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjdXJMaW5lQ291bnQ7IGktLTspIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHRoZXJlJ3Mgbm8gc29mdCBicmVhayBwb2ludDsgbWFrZSBoYXJkIGJyZWFrIGlmIG92ZXJmbG93V3JhcD0nYnJlYWstd29yZCdcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBvdmVyZmxvd1dyYXAgPT09ICdicmVhay13b3JkJykge1xuICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gLWdseXBoWDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgc29mdCBicmVhayBwb2ludDsgbW92ZSBhbGwgY2hhcnMgc2luY2UgaXQgdG8gYSBuZXcgbGluZVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRMaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouY2FuQnJlYWtBZnRlcikge1xuICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSBjdXJyZW50TGluZS5zcGxpdEF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdFggPSBuZXh0TGluZS5nbHlwaEF0KDApLng7XG4gICAgICAgICAgICAgICAgICBsaW5lWE9mZnNldCAtPSBhZGp1c3RYO1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IG5leHRMaW5lLmNvdW50OyBqLS07KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lLmdseXBoQXQoaikueCAtPSBhZGp1c3RYO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0TGluZSkge1xuICAgICAgICAgICAgICBjdXJyZW50TGluZS5pc1NvZnRXcmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3VycmVudExpbmUgPSBuZXh0TGluZTtcbiAgICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IG1heFdpZHRoOyAvL2FmdGVyIHNvZnQgd3JhcHBpbmcgdXNlIG1heFdpZHRoIGFzIGNhbGN1bGF0ZWQgd2lkdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZmx5ID0gY3VycmVudExpbmUuZ2x5cGhBdChjdXJyZW50TGluZS5jb3VudCk7XG4gICAgICAgICAgZmx5LmdseXBoT2JqID0gZ2x5cGhPYmo7XG4gICAgICAgICAgZmx5LnggPSBnbHlwaFggKyBsaW5lWE9mZnNldDtcbiAgICAgICAgICBmbHkud2lkdGggPSBnbHlwaFdpZHRoO1xuICAgICAgICAgIGZseS5jaGFySW5kZXggPSBjaGFySW5kZXg7XG5cbiAgICAgICAgICAvLyBIYW5kbGUgaGFyZCBsaW5lIGJyZWFrc1xuICAgICAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICAgICAgY3VycmVudExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtKGdseXBoWCArIGdseXBoV2lkdGggKyAobGV0dGVyU3BhY2luZyAqIGZvbnRTaXplKSkgKyB0ZXh0SW5kZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHdpZHRoIG9mIGVhY2ggbGluZSAoZXhjbHVkaW5nIHRyYWlsaW5nIHdoaXRlc3BhY2UpIGFuZCBtYXhpbXVtIGJsb2NrIHdpZHRoXG4gICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmUuY291bnQ7IGktLTspIHtcbiAgICAgICAgICAgIGxldCB7Z2x5cGhPYmosIHgsIHdpZHRofSA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICAgIGlmICghZ2x5cGhPYmouaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgIGxpbmUud2lkdGggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgIGlmIChsaW5lLndpZHRoID4gbWF4TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpbmQgb3ZlcmFsbCBwb3NpdGlvbiBhZGp1c3RtZW50cyBmb3IgYW5jaG9yaW5nXG4gICAgICAgIGxldCBhbmNob3JYT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGFuY2hvcllPZmZzZXQgPSAwO1xuICAgICAgICBpZiAoYW5jaG9yWCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yWCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFuY2hvclhPZmZzZXQgPSAtYW5jaG9yWDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFuY2hvclggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhbmNob3JYT2Zmc2V0ID0gLW1heExpbmVXaWR0aCAqIChcbiAgICAgICAgICAgICAgYW5jaG9yWCA9PT0gJ2xlZnQnID8gMCA6XG4gICAgICAgICAgICAgIGFuY2hvclggPT09ICdjZW50ZXInID8gMC41IDpcbiAgICAgICAgICAgICAgYW5jaG9yWCA9PT0gJ3JpZ2h0JyA/IDEgOlxuICAgICAgICAgICAgICBwYXJzZVBlcmNlbnQoYW5jaG9yWClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNob3JZKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYW5jaG9yWU9mZnNldCA9IC1hbmNob3JZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYW5jaG9yWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBsaW5lcy5sZW5ndGggKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgYW5jaG9yWU9mZnNldCA9IGFuY2hvclkgPT09ICd0b3AnID8gMCA6XG4gICAgICAgICAgICAgIGFuY2hvclkgPT09ICd0b3AtYmFzZWxpbmUnID8gLXRvcEJhc2VsaW5lIDpcbiAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1jYXAnID8gLXRvcEJhc2VsaW5lIC0gY2FwSGVpZ2h0ICogZm9udFNpemVNdWx0IDpcbiAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1leCcgPyAtdG9wQmFzZWxpbmUgLSB4SGVpZ2h0ICogZm9udFNpemVNdWx0IDpcbiAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ21pZGRsZScgPyBoZWlnaHQgLyAyIDpcbiAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ2JvdHRvbScgPyBoZWlnaHQgOlxuICAgICAgICAgICAgICBhbmNob3JZID09PSAnYm90dG9tLWJhc2VsaW5lJyA/IGhlaWdodCAtIGhhbGZMZWFkaW5nICsgZGVzY2VuZGVyICogZm9udFNpemVNdWx0IDpcbiAgICAgICAgICAgICAgcGFyc2VQZXJjZW50KGFuY2hvclkpICogaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWV0cmljc09ubHkpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGJpZGkgbGV2ZWxzXG4gICAgICAgICAgY29uc3QgYmlkaUxldmVsc1Jlc3VsdCA9IGJpZGkuZ2V0RW1iZWRkaW5nTGV2ZWxzKHRleHQsIGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggbGluZSwgYXBwbHlpbmcgYWxpZ25tZW50IG9mZnNldHMsIGFkZGluZyBlYWNoIGdseXBoIHRvIHRoZSBhdGxhcywgYW5kXG4gICAgICAgICAgLy8gY29sbGVjdGluZyBhbGwgcmVuZGVyYWJsZSBnbHlwaHMgaW50byBhIHNpbmdsZSBjb2xsZWN0aW9uLlxuICAgICAgICAgIGdseXBoSWRzID0gbmV3IFVpbnQxNkFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50KTtcbiAgICAgICAgICBnbHlwaFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQgKiAyKTtcbiAgICAgICAgICBnbHlwaERhdGEgPSB7fTtcbiAgICAgICAgICB2aXNpYmxlQm91bmRzID0gW0lORiwgSU5GLCAtSU5GLCAtSU5GXTtcbiAgICAgICAgICBjaHVua2VkQm91bmRzID0gW107XG4gICAgICAgICAgbGV0IGxpbmVZT2Zmc2V0ID0gdG9wQmFzZWxpbmU7XG4gICAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRleHQubGVuZ3RoICogMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgZ2x5cGhDb2xvcnMgPSBuZXcgVWludDhBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCAqIDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmVuZGVyYWJsZUdseXBoSW5kZXggPSAwO1xuICAgICAgICAgIGxldCBwcmV2Q2hhckluZGV4ID0gLTE7XG4gICAgICAgICAgbGV0IGNvbG9yQ2hhckluZGV4ID0gLTE7XG4gICAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICAgIGxldCBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSwgbGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQge2NvdW50OmxpbmVHbHlwaENvdW50LCB3aWR0aDpsaW5lV2lkdGh9ID0gbGluZTtcblxuICAgICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGxpbmVzXG4gICAgICAgICAgICBpZiAobGluZUdseXBoQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIENvdW50IHRyYWlsaW5nIHdoaXRlc3BhY2VzLCB3ZSB3YW50IHRvIGlnbm9yZSB0aGVzZSBmb3IgY2VydGFpbiB0aGluZ3NcbiAgICAgICAgICAgICAgbGV0IHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVHbHlwaENvdW50OyBpLS0gJiYgbGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmlzV2hpdGVzcGFjZTspIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQXBwbHkgaG9yaXpvbnRhbCBhbGlnbm1lbnQgYWRqdXN0bWVudHNcbiAgICAgICAgICAgICAgbGV0IGxpbmVYT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgbGV0IGp1c3RpZnlBZGp1c3QgPSAwO1xuICAgICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aCkgLyAyO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnknICYmIGxpbmUuaXNTb2Z0V3JhcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvdW50IG5vbi10cmFpbGluZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsIGFuZCB3ZSdsbCBhZGp1c3QgdGhlIG9mZnNldHMgcGVyIGNoYXJhY3RlciBpbiB0aGUgbmV4dCBsb29wXG4gICAgICAgICAgICAgICAgbGV0IHdoaXRlc3BhY2VDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQ7IGktLTspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqdXN0aWZ5QWRqdXN0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aCkgLyB3aGl0ZXNwYWNlQ291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGp1c3RpZnlBZGp1c3QgfHwgbGluZVhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQganVzdGlmeU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhPYmogPSBnbHlwaEluZm8uZ2x5cGhPYmo7XG4gICAgICAgICAgICAgICAgICBnbHlwaEluZm8ueCArPSBsaW5lWE9mZnNldCArIGp1c3RpZnlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgbm9uLXRyYWlsaW5nIHdoaXRlc3BhY2VzIGZvciBqdXN0aWZ5IGFsaWdubWVudFxuICAgICAgICAgICAgICAgICAgaWYgKGp1c3RpZnlBZGp1c3QgIT09IDAgJiYgZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmIGkgPCBsaW5lR2x5cGhDb3VudCAtIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnlPZmZzZXQgKz0ganVzdGlmeUFkanVzdDtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmZvLndpZHRoICs9IGp1c3RpZnlBZGp1c3Q7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gUGVyZm9ybSBiaWRpIHJhbmdlIGZsaXBwaW5nXG4gICAgICAgICAgICAgIGNvbnN0IGZsaXBzID0gYmlkaS5nZXRSZW9yZGVyU2VnbWVudHMoXG4gICAgICAgICAgICAgICAgdGV4dCwgYmlkaUxldmVsc1Jlc3VsdCwgbGluZS5nbHlwaEF0KDApLmNoYXJJbmRleCwgbGluZS5nbHlwaEF0KGxpbmUuY291bnQgLSAxKS5jaGFySW5kZXhcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgZmkgPSAwOyBmaSA8IGZsaXBzLmxlbmd0aDsgZmkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IGZsaXBzW2ZpXTtcbiAgICAgICAgICAgICAgICAvLyBNYXAgc3RhcnQvZW5kIHN0cmluZyBpbmRpY2VzIHRvIGluZGljZXMgaW4gdGhlIGxpbmVcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmdseXBoQXQoaSkuY2hhckluZGV4ID49IHN0YXJ0KSB7IC8vIGd0ZSB0byBoYW5kbGUgcmVtb3ZlZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydEluTGluZSA9IGksIGVuZEluTGluZSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBlbmRJbkxpbmUgPCBsaW5lR2x5cGhDb3VudDsgZW5kSW5MaW5lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IGxpbmUuZ2x5cGhBdChlbmRJbkxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmNoYXJJbmRleCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluTGluZSA8IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQpIHsgLy9kb24ndCBpbmNsdWRlIHRyYWlsaW5nIHdzIGluIGZsaXAgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCBpbmZvLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgaW5mby54ICsgaW5mby53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydEluTGluZTsgaiA8IGVuZEluTGluZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGopO1xuICAgICAgICAgICAgICAgICAgICAgIGdseXBoSW5mby54ID0gcmlnaHQgLSAoZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGggLSBsZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEFzc2VtYmxlIGZpbmFsIGRhdGEgYXJyYXlzXG4gICAgICAgICAgICAgIGxldCBnbHlwaE9iajtcbiAgICAgICAgICAgICAgY29uc3Qgc2V0R2x5cGhPYmogPSBnID0+IGdseXBoT2JqID0gZztcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdseXBoSW5mbyA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICAgICAgICBnbHlwaE9iaiA9IGdseXBoSW5mby5nbHlwaE9iajtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaElkID0gZ2x5cGhPYmouaW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIG1pcnJvcmVkIGNoYXJhY3RlcnMgaW4gcnRsXG4gICAgICAgICAgICAgICAgY29uc3QgcnRsID0gYmlkaUxldmVsc1Jlc3VsdC5sZXZlbHNbZ2x5cGhJbmZvLmNoYXJJbmRleF0gJiAxOyAvL29kZCBsZXZlbCBtZWFucyBydGxcbiAgICAgICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtaXJyb3JlZCA9IGJpZGkuZ2V0TWlycm9yZWRDaGFyYWN0ZXIodGV4dFtnbHlwaEluZm8uY2hhckluZGV4XSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWlycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udE9iai5mb3JFYWNoR2x5cGgobWlycm9yZWQsIDAsIDAsIHNldEdseXBoT2JqKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgY2FyZXQgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgICAgICAgICAgY29uc3Qge2NoYXJJbmRleH0gPSBnbHlwaEluZm87XG4gICAgICAgICAgICAgICAgICBjb25zdCBjYXJldExlZnQgPSBnbHlwaEluZm8ueCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjYXJldFJpZ2h0ID0gZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGggKyBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogM10gPSBydGwgPyBjYXJldFJpZ2h0IDogY2FyZXRMZWZ0OyAvL3N0YXJ0IGVkZ2UgeFxuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogMyArIDFdID0gcnRsID8gY2FyZXRMZWZ0IDogY2FyZXRSaWdodDsgLy9lbmQgZWRnZSB4XG4gICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiAzICsgMl0gPSBsaW5lWU9mZnNldCArIGNhcmV0Qm90dG9tT2Zmc2V0ICsgYW5jaG9yWU9mZnNldDsgLy9jb21tb24gYm90dG9tIHlcblxuICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2tpcHBlZCBhbnkgY2hhcnMgZnJvbSB0aGUgcHJldmlvdXMgZ2x5cGggKGR1ZSB0byBsaWdhdHVyZSBzdWJzKSwgZmlsbCBpbiBjYXJldFxuICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGZvciB0aG9zZSBtaXNzaW5nIGNoYXIgaW5kaWNlczsgY3VycmVudGx5IHRoaXMgdXNlcyBhIGJlc3QtZ3Vlc3MgYnkgZGl2aWRpbmdcbiAgICAgICAgICAgICAgICAgIC8vIHRoZSBsaWdhdHVyZSdzIHdpZHRoIGV2ZW5seS4gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgdHJ5IHRvIHVzZSB0aGUgZm9udCdzIExpZ2F0dXJlQ2FyZXRMaXN0XG4gICAgICAgICAgICAgICAgICAvLyB0YWJsZSB0byBnZXQgYmV0dGVyIGludGVyaW9yIGNhcmV0IHBvc2l0aW9ucy5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxpZ0NvdW50ID0gY2hhckluZGV4IC0gcHJldkNoYXJJbmRleDtcbiAgICAgICAgICAgICAgICAgIGlmIChsaWdDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIHByZXZDaGFySW5kZXgsIGxpZ0NvdW50KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHByZXZDaGFySW5kZXggPSBjaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgY3VycmVudCBjb2xvciByYW5nZVxuICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgY29uc3Qge2NoYXJJbmRleH0gPSBnbHlwaEluZm87XG4gICAgICAgICAgICAgICAgICB3aGlsZShjaGFySW5kZXggPiBjb2xvckNoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvckNoYXJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMuaGFzT3duUHJvcGVydHkoY29sb3JDaGFySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbG9yID0gY29sb3JSYW5nZXNbY29sb3JDaGFySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGF0bGFzIGRhdGEgZm9yIHJlbmRlcmFibGUgZ2x5cGhzXG4gICAgICAgICAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgIWdseXBoT2JqLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHJlbmRlcmFibGVHbHlwaEluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGdseXBoJ3MgcGF0aCBkYXRhXG4gICAgICAgICAgICAgICAgICBpZiAoIWdseXBoRGF0YVtnbHlwaElkXSkge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaERhdGFbZ2x5cGhJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGF0aDogZ2x5cGhPYmoucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoQm91bmRzOiBbZ2x5cGhPYmoueE1pbiwgZ2x5cGhPYmoueU1pbiwgZ2x5cGhPYmoueE1heCwgZ2x5cGhPYmoueU1heF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIGdseXBoIHBvc2l0aW9uIGFuZCBhZGQgdG8gZ2x5cGhQb3NpdGlvbnMgYXJyYXlcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoWCA9IGdseXBoSW5mby54ICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoWSA9IGxpbmVZT2Zmc2V0ICsgYW5jaG9yWU9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGdseXBoUG9zaXRpb25zW2lkeCAqIDJdID0gZ2x5cGhYO1xuICAgICAgICAgICAgICAgICAgZ2x5cGhQb3NpdGlvbnNbaWR4ICogMiArIDFdID0gZ2x5cGhZO1xuXG4gICAgICAgICAgICAgICAgICAvLyBUcmFjayB0b3RhbCB2aXNpYmxlIGJvdW5kc1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmlzWDAgPSBnbHlwaFggKyBnbHlwaE9iai54TWluICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmlzWTAgPSBnbHlwaFkgKyBnbHlwaE9iai55TWluICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmlzWDEgPSBnbHlwaFggKyBnbHlwaE9iai54TWF4ICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmlzWTEgPSBnbHlwaFkgKyBnbHlwaE9iai55TWF4ICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgICAgaWYgKHZpc1gwIDwgdmlzaWJsZUJvdW5kc1swXSkgdmlzaWJsZUJvdW5kc1swXSA9IHZpc1gwO1xuICAgICAgICAgICAgICAgICAgaWYgKHZpc1kwIDwgdmlzaWJsZUJvdW5kc1sxXSkgdmlzaWJsZUJvdW5kc1sxXSA9IHZpc1kwO1xuICAgICAgICAgICAgICAgICAgaWYgKHZpc1gxID4gdmlzaWJsZUJvdW5kc1syXSkgdmlzaWJsZUJvdW5kc1syXSA9IHZpc1gxO1xuICAgICAgICAgICAgICAgICAgaWYgKHZpc1kxID4gdmlzaWJsZUJvdW5kc1szXSkgdmlzaWJsZUJvdW5kc1szXSA9IHZpc1kxO1xuXG4gICAgICAgICAgICAgICAgICAvLyBUcmFjayBib3VuZGluZyByZWN0cyBmb3IgZWFjaCBjaHVuayBvZiBOIGdseXBoc1xuICAgICAgICAgICAgICAgICAgaWYgKGlkeCAlIGNodW5rZWRCb3VuZHNTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rID0ge3N0YXJ0OiBpZHgsIGVuZDogaWR4LCByZWN0OiBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdfTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtlZEJvdW5kcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNodW5rLmVuZCsrO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtSZWN0ID0gY2h1bmsucmVjdDtcbiAgICAgICAgICAgICAgICAgIGlmICh2aXNYMCA8IGNodW5rUmVjdFswXSkgY2h1bmtSZWN0WzBdID0gdmlzWDA7XG4gICAgICAgICAgICAgICAgICBpZiAodmlzWTAgPCBjaHVua1JlY3RbMV0pIGNodW5rUmVjdFsxXSA9IHZpc1kwO1xuICAgICAgICAgICAgICAgICAgaWYgKHZpc1gxID4gY2h1bmtSZWN0WzJdKSBjaHVua1JlY3RbMl0gPSB2aXNYMTtcbiAgICAgICAgICAgICAgICAgIGlmICh2aXNZMSA+IGNodW5rUmVjdFszXSkgY2h1bmtSZWN0WzNdID0gdmlzWTE7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBnbHlwaCBpZHMgYXJyYXlcbiAgICAgICAgICAgICAgICAgIGdseXBoSWRzW2lkeF0gPSBnbHlwaElkO1xuXG4gICAgICAgICAgICAgICAgICAvLyBBZGQgY29sb3JzXG4gICAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpZHggKiAzO1xuICAgICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydF0gPSBjdXJyZW50Q29sb3IgPj4gMTYgJiAyNTU7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0ICsgMV0gPSBjdXJyZW50Q29sb3IgPj4gOCAmIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnQgKyAyXSA9IGN1cnJlbnRDb2xvciAmIDI1NTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5jcmVtZW50IHkgb2Zmc2V0IGZvciBuZXh0IGxpbmVcbiAgICAgICAgICAgIGxpbmVZT2Zmc2V0IC09IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBGaWxsIGluIHJlbWFpbmluZyBjYXJldCBwb3NpdGlvbnMgaW4gY2FzZSB0aGUgZmluYWwgY2hhcmFjdGVyIHdhcyBhIGxpZ2F0dXJlXG4gICAgICAgICAgaWYgKGNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsaWdDb3VudCA9IHRleHQubGVuZ3RoIC0gcHJldkNoYXJJbmRleDtcbiAgICAgICAgICAgIGlmIChsaWdDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIHByZXZDaGFySW5kZXgsIGxpZ0NvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaW1pbmcgc3RhdHNcbiAgICAgICAgdGltaW5ncy50eXBlc2V0dGluZyA9IG5vdygpIC0gdHlwZXNldFN0YXJ0O1xuXG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICBnbHlwaElkcywgLy9mb250IGluZGljZXMgZm9yIGVhY2ggZ2x5cGhcbiAgICAgICAgICBnbHlwaFBvc2l0aW9ucywgLy94LHkgb2YgZWFjaCBnbHlwaCdzIG9yaWdpbiBpbiBsYXlvdXRcbiAgICAgICAgICBnbHlwaERhdGEsIC8vZGljdCBob2xkaW5nIGRhdGEgYWJvdXQgZWFjaCBnbHlwaCBhcHBlYXJpbmcgaW4gdGhlIHRleHRcbiAgICAgICAgICBjYXJldFBvc2l0aW9ucywgLy9zdGFydFgsZW5kWCxib3R0b21ZIGNhcmV0IHBvc2l0aW9ucyBmb3IgZWFjaCBjaGFyXG4gICAgICAgICAgY2FyZXRIZWlnaHQsIC8vaGVpZ2h0IG9mIGN1cnNvciBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICAgICAgICBnbHlwaENvbG9ycywgLy9jb2xvciBmb3IgZWFjaCBnbHlwaCwgaWYgY29sb3IgcmFuZ2VzIHN1cHBsaWVkXG4gICAgICAgICAgY2h1bmtlZEJvdW5kcywgLy90b3RhbCByZWN0cyBwZXIgKG49Y2h1bmtlZEJvdW5kc1NpemUpIGNvbnNlY3V0aXZlIGdseXBoc1xuICAgICAgICAgIGZvbnRTaXplLCAvL2NhbGN1bGF0ZWQgZW0gaGVpZ2h0XG4gICAgICAgICAgdW5pdHNQZXJFbSwgLy9mb250IHVuaXRzIHBlciBlbVxuICAgICAgICAgIGFzY2VuZGVyOiBhc2NlbmRlciAqIGZvbnRTaXplTXVsdCwgLy9mb250IGFzY2VuZGVyXG4gICAgICAgICAgZGVzY2VuZGVyOiBkZXNjZW5kZXIgKiBmb250U2l6ZU11bHQsIC8vZm9udCBkZXNjZW5kZXJcbiAgICAgICAgICBjYXBIZWlnaHQ6IGNhcEhlaWdodCAqIGZvbnRTaXplTXVsdCwgLy9mb250IGNhcC1oZWlnaHRcbiAgICAgICAgICB4SGVpZ2h0OiB4SGVpZ2h0ICogZm9udFNpemVNdWx0LCAvL2ZvbnQgeC1oZWlnaHRcbiAgICAgICAgICBsaW5lSGVpZ2h0LCAvL2NvbXB1dGVkIGxpbmUgaGVpZ2h0XG4gICAgICAgICAgdG9wQmFzZWxpbmUsIC8veSBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lXG4gICAgICAgICAgYmxvY2tCb3VuZHM6IFsgLy9ib3VuZHMgZm9yIHRoZSB3aG9sZSBibG9jayBvZiB0ZXh0LCBpbmNsdWRpbmcgdmVydGljYWwgcGFkZGluZyBmb3IgbGluZUhlaWdodFxuICAgICAgICAgICAgYW5jaG9yWE9mZnNldCxcbiAgICAgICAgICAgIGFuY2hvcllPZmZzZXQgLSBsaW5lcy5sZW5ndGggKiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgYW5jaG9yWE9mZnNldCArIG1heExpbmVXaWR0aCxcbiAgICAgICAgICAgIGFuY2hvcllPZmZzZXRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHZpc2libGVCb3VuZHMsIC8vdG90YWwgYm91bmRzIG9mIHZpc2libGUgdGV4dCBwYXRocywgbWF5IGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gYmxvY2tCb3VuZHNcbiAgICAgICAgICB0aW1pbmdzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBGb3IgYSBnaXZlbiB0ZXh0IHN0cmluZyBhbmQgZm9udCBwYXJhbWV0ZXJzLCBkZXRlcm1pbmUgdGhlIHJlc3VsdGluZyBibG9jayBkaW1lbnNpb25zXG4gICAgICogYWZ0ZXIgd3JhcHBpbmcgZm9yIHRoZSBnaXZlbiBtYXhXaWR0aC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYXN1cmUoYXJncywgY2FsbGJhY2spIHtcbiAgICAgIHR5cGVzZXQoYXJncywgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gcmVzdWx0LmJsb2NrQm91bmRzO1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgd2lkdGg6IHgxIC0geDAsXG4gICAgICAgICAgaGVpZ2h0OiB5MSAtIHkwXG4gICAgICAgIH0pO1xuICAgICAgfSwge21ldHJpY3NPbmx5OiB0cnVlfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQZXJjZW50KHN0cikge1xuICAgICAgbGV0IG1hdGNoID0gc3RyLm1hdGNoKC9eKFtcXGQuXSspJSQvKTtcbiAgICAgIGxldCBwY3QgPSBtYXRjaCA/IHBhcnNlRmxvYXQobWF0Y2hbMV0pIDogTmFOO1xuICAgICAgcmV0dXJuIGlzTmFOKHBjdCkgPyAwIDogcGN0IC8gMTAwXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIGxpZ1N0YXJ0SW5kZXgsIGxpZ0NvdW50KSB7XG4gICAgICBjb25zdCBsaWdTdGFydFggPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogM107XG4gICAgICBjb25zdCBsaWdFbmRYID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDMgKyAxXTtcbiAgICAgIGNvbnN0IGxpZ1kgPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogMyArIDJdO1xuICAgICAgY29uc3QgZ3Vlc3NlZEFkdmFuY2VYID0gKGxpZ0VuZFggLSBsaWdTdGFydFgpIC8gbGlnQ291bnQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpZ0NvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IChsaWdTdGFydEluZGV4ICsgaSkgKiAzO1xuICAgICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4XSA9IGxpZ1N0YXJ0WCArIGd1ZXNzZWRBZHZhbmNlWCAqIGk7XG4gICAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXggKyAxXSA9IGxpZ1N0YXJ0WCArIGd1ZXNzZWRBZHZhbmNlWCAqIChpICsgMSk7XG4gICAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXggKyAyXSA9IGxpZ1k7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm93KCkge1xuICAgICAgcmV0dXJuIChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpXG4gICAgfVxuXG4gICAgLy8gQXJyYXktYmFja2VkIHN0cnVjdHVyZSBmb3IgYSBzaW5nbGUgbGluZSdzIGdseXBocyBkYXRhXG4gICAgZnVuY3Rpb24gVGV4dExpbmUoKSB7XG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG4gICAgY29uc3QgdGV4dExpbmVQcm9wcyA9IFsnZ2x5cGhPYmonLCAneCcsICd3aWR0aCcsICdjaGFySW5kZXgnXTtcbiAgICBUZXh0TGluZS5wcm90b3R5cGUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGlzU29mdFdyYXBwZWQ6IGZhbHNlLFxuICAgICAgZ2V0IGNvdW50KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGF0YS5sZW5ndGggLyB0ZXh0TGluZVByb3BzLmxlbmd0aClcbiAgICAgIH0sXG4gICAgICBnbHlwaEF0KGkpIHtcbiAgICAgICAgbGV0IGZseSA9IFRleHRMaW5lLmZseXdlaWdodDtcbiAgICAgICAgZmx5LmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZseS5pbmRleCA9IGk7XG4gICAgICAgIHJldHVybiBmbHlcbiAgICAgIH0sXG4gICAgICBzcGxpdEF0KGkpIHtcbiAgICAgICAgbGV0IG5ld0xpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgbmV3TGluZS5kYXRhID0gdGhpcy5kYXRhLnNwbGljZShpICogdGV4dExpbmVQcm9wcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3TGluZVxuICAgICAgfVxuICAgIH07XG4gICAgVGV4dExpbmUuZmx5d2VpZ2h0ID0gdGV4dExpbmVQcm9wcy5yZWR1Y2UoKG9iaiwgcHJvcCwgaSwgYWxsKSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuaW5kZXggKiB0ZXh0TGluZVByb3BzLmxlbmd0aCArIGldXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIHRleHRMaW5lUHJvcHMubGVuZ3RoICsgaV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9ialxuICAgIH0sIHtkYXRhOiBudWxsLCBpbmRleDogMH0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZXNldCxcbiAgICAgIG1lYXN1cmUsXG4gICAgICBsb2FkRm9udFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5vdyA9ICgpID0+IChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpO1xuXG4gIGNvbnN0IG1haW5UaHJlYWRHZW5lcmF0b3IgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNERkdlbmVyYXRvcl9fZGVmYXVsdFsnZGVmYXVsdCddKCk7XG5cbiAgbGV0IHdhcm5lZDtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgc2luZ2xlIGdseXBoIHBhdGgsIHBsYWNpbmcgdGhlIHJlc3VsdCBpbnRvIGEgd2ViZ2wgY2FudmFzIGF0IGFcbiAgICogZ2l2ZW4gbG9jYXRpb24gYW5kIGNoYW5uZWwuIFV0aWxpemVzIHRoZSB3ZWJnbC1zZGYtZ2VuZXJhdG9yIGV4dGVybmFsIHBhY2thZ2UgZm9yIEdQVS1hY2NlbGVyYXRlZCBTREZcbiAgICogZ2VuZXJhdGlvbiB3aGVuIHN1cHBvcnRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlU0RGKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsLCB1c2VXZWJHTCA9IHRydWUpIHtcbiAgICAvLyBBbGxvdyBvcHQtb3V0XG4gICAgaWYgKCF1c2VXZWJHTCkge1xuICAgICAgcmV0dXJuIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbClcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IEdQVS1hY2NlbGVyYXRlZCBnZW5lcmF0aW9uIGZpcnN0XG4gICAgcmV0dXJuIGdlbmVyYXRlU0RGX0dMKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKS50aGVuKFxuICAgICAgbnVsbCxcbiAgICAgIGVyciA9PiB7XG4gICAgICAgIC8vIFdlYkdMIGZhaWxlZCBlaXRoZXIgZHVlIHRvIGEgaGFyZCBlcnJvciBvciB1bmV4cGVjdGVkIHJlc3VsdHM7IGZhbGwgYmFjayB0byBKUyBpbiB3b3JrZXJzXG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKU2AsIGVycik7XG4gICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHF1ZXVlID0gW107XG4gIGNvbnN0IGNodW5rVGltZUJ1ZGdldCA9IDU7IC8vIG1zXG4gIGxldCB0aW1lciA9IDA7XG5cbiAgZnVuY3Rpb24gbmV4dENodW5rKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAmJiBub3coKSAtIHN0YXJ0IDwgY2h1bmtUaW1lQnVkZ2V0KSB7XG4gICAgICBxdWV1ZS5zaGlmdCgpKCk7XG4gICAgfVxuICAgIHRpbWVyID0gcXVldWUubGVuZ3RoID8gc2V0VGltZW91dChuZXh0Q2h1bmssIDApIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZWJHTC1iYXNlZCBpbXBsZW1lbnRhdGlvbiBleGVjdXRlZCBvbiB0aGUgbWFpbiB0aHJlYWQuIFJlcXVlc3RzIGFyZSBleGVjdXRlZCBpbiB0aW1lLWJvdW5kZWRcbiAgICogbWFjcm90YXNrIGNodW5rcyB0byBhbGxvdyByZW5kZXIgZnJhbWVzIHRvIGV4ZWN1dGUgaW4gYmV0d2Vlbi5cbiAgICovXG4gIGNvbnN0IGdlbmVyYXRlU0RGX0dMID0gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbC5nZW5lcmF0ZUludG9DYW52YXMoLi4uYXJncyk7XG4gICAgICAgICAgcmVzb2x2ZSh7IHRpbWluZzogbm93KCkgLSBzdGFydCB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQobmV4dENodW5rLCAwKTtcbiAgICAgIH1cbiAgICB9KVxuICB9O1xuXG4gIGNvbnN0IHRocmVhZENvdW50ID0gNDsgLy8gaG93IG1hbnkgd29ya2VycyB0byBzcGF3blxuICBjb25zdCBpZGxlVGltZW91dCA9IDIwMDA7IC8vIHdvcmtlcnMgd2lsbCBiZSB0ZXJtaW5hdGVkIGFmdGVyIGJlaW5nIGlkbGUgdGhpcyBtYW55IG1pbGxpc2Vjb25kc1xuICBjb25zdCB0aHJlYWRzID0ge307XG4gIGxldCBjYWxsTnVtID0gMDtcblxuICAvKipcbiAgICogRmFsbGJhY2sgSlMtYmFzZWQgaW1wbGVtZW50YXRpb24sIGZhbm5lZCBvdXQgdG8gYSBudW1iZXIgb2Ygd29ya2VyIHRocmVhZHMgZm9yIHBhcmFsbGVsaXNtXG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpIHtcbiAgICBjb25zdCB3b3JrZXJJZCA9ICdUcm9pa2FUZXh0U0RGR2VuZXJhdG9yX0pTXycgKyAoKGNhbGxOdW0rKykgJSB0aHJlYWRDb3VudCk7XG4gICAgbGV0IHRocmVhZCA9IHRocmVhZHNbd29ya2VySWRdO1xuICAgIGlmICghdGhyZWFkKSB7XG4gICAgICB0aHJlYWQgPSB0aHJlYWRzW3dvcmtlcklkXSA9IHtcbiAgICAgICAgd29ya2VyTW9kdWxlOiB0cm9pa2FXb3JrZXJVdGlscy5kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgICAgICAgIG5hbWU6IHdvcmtlcklkLFxuICAgICAgICAgIHdvcmtlcklkLFxuICAgICAgICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgICAgICAgY3JlYXRlU0RGR2VuZXJhdG9yX19kZWZhdWx0WydkZWZhdWx0J10sXG4gICAgICAgICAgICBub3dcbiAgICAgICAgICBdLFxuICAgICAgICAgIGluaXQoX2NyZWF0ZVNERkdlbmVyYXRvciwgbm93KSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZSA9IF9jcmVhdGVTREZHZW5lcmF0b3IoKS5qYXZhc2NyaXB0LmdlbmVyYXRlO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVEYXRhID0gZ2VuZXJhdGUoLi4uYXJncyk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZURhdGEsXG4gICAgICAgICAgICAgICAgdGltaW5nOiBub3coKSAtIHN0YXJ0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFRyYW5zZmVyYWJsZXMocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdC50ZXh0dXJlRGF0YS5idWZmZXJdXG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcmVxdWVzdHM6IDAsXG4gICAgICAgIGlkbGVUaW1lcjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJlYWQucmVxdWVzdHMrKztcbiAgICBjbGVhclRpbWVvdXQodGhyZWFkLmlkbGVUaW1lcik7XG4gICAgcmV0dXJuIHRocmVhZC53b3JrZXJNb2R1bGUod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50KVxuICAgICAgLnRoZW4oKHsgdGV4dHVyZURhdGEsIHRpbWluZyB9KSA9PiB7XG4gICAgICAgIC8vIGNvcHkgcmVzdWx0IGRhdGEgaW50byB0aGUgY2FudmFzXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAgIC8vIGV4cGFuZCBzaW5nbGUtY2hhbm5lbCBkYXRhIGludG8gcmdiYVxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlRGF0YS5sZW5ndGggKiA0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGltYWdlRGF0YVtpICogNCArIGNoYW5uZWxdID0gdGV4dHVyZURhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlbmRlckltYWdlRGF0YShjYW52YXMsIGltYWdlRGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSA8PCAoMyAtIGNoYW5uZWwpKTtcbiAgICAgICAgdGltaW5nICs9IG5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgd29ya2VycyBhZnRlciBhIHdoaWxlXG4gICAgICAgIGlmICgtLXRocmVhZC5yZXF1ZXN0cyA9PT0gMCkge1xuICAgICAgICAgIHRocmVhZC5pZGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgdHJvaWthV29ya2VyVXRpbHMudGVybWluYXRlV29ya2VyKHdvcmtlcklkKTsgfSwgaWRsZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRpbWluZyB9XG4gICAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gd2FybVVwU0RGQ2FudmFzKGNhbnZhcykge1xuICAgIGlmICghY2FudmFzLl93YXJtKSB7XG4gICAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsLmlzU3VwcG9ydGVkKGNhbnZhcyk7XG4gICAgICBjYW52YXMuX3dhcm0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nID0gbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nO1xuXG4gIC8qIVxuICBDdXN0b20gYnVpbGQgb2YgVHlwci50cyAoaHR0cHM6Ly9naXRodWIuY29tL2ZyZWRsaTc0L1R5cHIudHMpIGZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLlxuICBPcmlnaW5hbCBNSVQgbGljZW5zZSBhcHBsaWVzOiBodHRwczovL2dpdGh1Yi5jb20vZnJlZGxpNzQvVHlwci50cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICovXG4gIGZ1bmN0aW9uIHR5cHJGYWN0b3J5KCl7cmV0dXJuIFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3cmJihzZWxmLndpbmRvdz1zZWxmKSxmdW5jdGlvbihyKXt2YXIgZT17cGFyc2U6ZnVuY3Rpb24ocil7dmFyIHQ9ZS5fYmluLGE9bmV3IFVpbnQ4QXJyYXkocik7aWYoXCJ0dGNmXCI9PXQucmVhZEFTQ0lJKGEsMCw0KSl7dmFyIG49NDt0LnJlYWRVc2hvcnQoYSxuKSxuKz0yLHQucmVhZFVzaG9ydChhLG4pLG4rPTI7dmFyIG89dC5yZWFkVWludChhLG4pO24rPTQ7Zm9yKHZhciBzPVtdLGk9MDtpPG87aSsrKXt2YXIgaD10LnJlYWRVaW50KGEsbik7bis9NCxzLnB1c2goZS5fcmVhZEZvbnQoYSxoKSk7fXJldHVybiBzfXJldHVybiBbZS5fcmVhZEZvbnQoYSwwKV19LF9yZWFkRm9udDpmdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQ7YS5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTI7Zm9yKHZhciBzPVtcImNtYXBcIixcImhlYWRcIixcImhoZWFcIixcIm1heHBcIixcImhtdHhcIixcIm5hbWVcIixcIk9TLzJcIixcInBvc3RcIixcImxvY2FcIixcImdseWZcIixcImtlcm5cIixcIkNGRiBcIixcIkdQT1NcIixcIkdTVUJcIixcIlNWRyBcIl0saT17X2RhdGE6cixfb2Zmc2V0Om59LGg9e30sZj0wO2Y8bztmKyspe3ZhciBkPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00LGEucmVhZFVpbnQocix0KSx0Kz00O3ZhciB1PWEucmVhZFVpbnQocix0KTt0Kz00O3ZhciBsPWEucmVhZFVpbnQocix0KTt0Kz00LGhbZF09e29mZnNldDp1LGxlbmd0aDpsfTt9Zm9yKGY9MDtmPHMubGVuZ3RoO2YrKyl7dmFyIHY9c1tmXTtoW3ZdJiYoaVt2LnRyaW0oKV09ZVt2LnRyaW0oKV0ucGFyc2UocixoW3ZdLm9mZnNldCxoW3ZdLmxlbmd0aCxpKSk7fXJldHVybiBpfSxfdGFiT2Zmc2V0OmZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLG89bi5yZWFkVXNob3J0KHIsYSs0KSxzPWErMTIsaT0wO2k8bztpKyspe3ZhciBoPW4ucmVhZEFTQ0lJKHIscyw0KTtzKz00LG4ucmVhZFVpbnQocixzKSxzKz00O3ZhciBmPW4ucmVhZFVpbnQocixzKTtpZihzKz00LG4ucmVhZFVpbnQocixzKSxzKz00LGg9PXQpcmV0dXJuIGZ9cmV0dXJuIDB9fTtlLl9iaW49e3JlYWRGaXhlZDpmdW5jdGlvbihyLGUpe3JldHVybiAocltlXTw8OHxyW2UrMV0pKyhyW2UrMl08PDh8cltlKzNdKS82NTU0MH0scmVhZEYyZG90MTQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLnJlYWRTaG9ydChyLHQpLzE2Mzg0fSxyZWFkSW50OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQzMih0KX0scmVhZEludDg6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDgodCl9LHJlYWRTaG9ydDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50MTYodCl9LHJlYWRVc2hvcnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldFVpbnQxNih0KX0scmVhZFVzaG9ydHM6ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1bXSxvPTA7bzxhO28rKyluLnB1c2goZS5fYmluLnJlYWRVc2hvcnQocix0KzIqbykpO3JldHVybiBufSxyZWFkVWludDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0VWludDMyKHQpfSxyZWFkVWludDY0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIDQyOTQ5NjcyOTYqZS5fYmluLnJlYWRVaW50KHIsdCkrZS5fYmluLnJlYWRVaW50KHIsdCs0KX0scmVhZEFTQ0lJOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKylhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRVbmljb2RlOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKyl7dmFyIG89cltlKytdPDw4fHJbZSsrXTthKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pO31yZXR1cm4gYX0sX3RkZWM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LlRleHREZWNvZGVyP25ldyB3aW5kb3cuVGV4dERlY29kZXI6bnVsbCxyZWFkVVRGODpmdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLl90ZGVjO3JldHVybiBuJiYwPT10JiZhPT1yLmxlbmd0aD9uLmRlY29kZShyKTplLl9iaW4ucmVhZEFTQ0lJKHIsdCxhKX0scmVhZEJ5dGVzOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRBU0NJSUFycmF5OmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUocltlK25dKSk7cmV0dXJuIGF9LF92aWV3OmZ1bmN0aW9uKHIpe3JldHVybiByLl9kYXRhVmlld3x8KHIuX2RhdGFWaWV3PXIuYnVmZmVyP25ldyBEYXRhVmlldyhyLmJ1ZmZlcixyLmJ5dGVPZmZzZXQsci5ieXRlTGVuZ3RoKTpuZXcgRGF0YVZpZXcobmV3IFVpbnQ4QXJyYXkocikuYnVmZmVyKSl9fSxlLl9sY3RmPXt9LGUuX2xjdGYucGFyc2U9ZnVuY3Rpb24ocix0LGEsbixvKXt2YXIgcz1lLl9iaW4saT17fSxoPXQ7cy5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBmPXMucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9cy5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1zLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixpLnNjcmlwdExpc3Q9ZS5fbGN0Zi5yZWFkU2NyaXB0TGlzdChyLGgrZiksaS5mZWF0dXJlTGlzdD1lLl9sY3RmLnJlYWRGZWF0dXJlTGlzdChyLGgrZCksaS5sb29rdXBMaXN0PWUuX2xjdGYucmVhZExvb2t1cExpc3QocixoK3UsbyksaX0sZS5fbGN0Zi5yZWFkTG9va3VwTGlzdD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89dCxzPVtdLGk9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXt2YXIgZj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPWUuX2xjdGYucmVhZExvb2t1cFRhYmxlKHIsbytmLGEpO3MucHVzaChkKTt9cmV0dXJuIHN9LGUuX2xjdGYucmVhZExvb2t1cFRhYmxlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz10LHM9e3RhYnM6W119O3MubHR5cGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixzLmZsYWc9bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgaT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD1zLmx0eXBlLGY9MDtmPGk7ZisrKXt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PWEocixoLG8rZCxzKTtzLnRhYnMucHVzaCh1KTt9cmV0dXJuIHN9LGUuX2xjdGYubnVtT2ZPbmVzPWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT0wLHQ9MDt0PDMyO3QrKykwIT0ocj4+PnQmMSkmJmUrKztyZXR1cm4gZX0sZS5fbGN0Zi5yZWFkQ2xhc3NEZWY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1bXSxvPWEucmVhZFVzaG9ydChyLHQpO2lmKHQrPTIsMT09byl7dmFyIHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspbi5wdXNoKHMraCksbi5wdXNoKHMraCksbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO31pZigyPT1vKXt2YXIgZj1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2ZvcihoPTA7aDxmO2grKyluLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTIsbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yLG4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9Mjt9cmV0dXJuIG59LGUuX2xjdGYuZ2V0SW50ZXJ2YWw9ZnVuY3Rpb24ocixlKXtmb3IodmFyIHQ9MDt0PHIubGVuZ3RoO3QrPTMpe3ZhciBhPXJbdF0sbj1yW3QrMV07aWYoclt0KzJdLGE8PWUmJmU8PW4pcmV0dXJuIHR9cmV0dXJuIC0xfSxlLl9sY3RmLnJlYWRDb3ZlcmFnZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm10PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsMT09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCxvKSksMj09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCwzKm8pKSxufSxlLl9sY3RmLmNvdmVyYWdlSW5kZXg9ZnVuY3Rpb24ocix0KXt2YXIgYT1yLnRhYjtpZigxPT1yLmZtdClyZXR1cm4gYS5pbmRleE9mKHQpO2lmKDI9PXIuZm10KXt2YXIgbj1lLl9sY3RmLmdldEludGVydmFsKGEsdCk7aWYoLTEhPW4pcmV0dXJuIGFbbisyXSsodC1hW25dKX1yZXR1cm4gLTF9LGUuX2xjdGYucmVhZEZlYXR1cmVMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZj1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPWUuX2xjdGYucmVhZEZlYXR1cmVUYWJsZShyLG4rZik7ZC50YWc9aC50cmltKCksby5wdXNoKGQpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkRmVhdHVyZVRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixzPjAmJihvLmZlYXR1cmVQYXJhbXM9bitzKTt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8udGFiPVtdO2Zvcih2YXIgaD0wO2g8aTtoKyspby50YWIucHVzaChhLnJlYWRVc2hvcnQocix0KzIqaCkpO3JldHVybiBvfSxlLl9sY3RmLnJlYWRTY3JpcHRMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZj1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG9baC50cmltKCldPWUuX2xjdGYucmVhZFNjcmlwdFRhYmxlKHIsbitmKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZFNjcmlwdFRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLmRlZmF1bHQ9ZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKHIsbitzKTt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe3ZhciBmPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBkPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsb1tmLnRyaW0oKV09ZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKHIsbitkKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZExhbmdTeXNUYWJsZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O2EucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZXFGZWF0dXJlPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsbi5mZWF0dXJlcz1hLnJlYWRVc2hvcnRzKHIsdCxvKSxufSxlLkNGRj17fSxlLkNGRi5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluOyhyPW5ldyBVaW50OEFycmF5KHIuYnVmZmVyLHQsYSkpW3Q9MF0sclsrK3RdLHJbKyt0XSxyWysrdF0sdCsrO3ZhciBvPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxvKTtmb3IodmFyIHM9W10saT0wO2k8by5sZW5ndGgtMTtpKyspcy5wdXNoKG4ucmVhZEFTQ0lJKHIsdCtvW2ldLG9baSsxXS1vW2ldKSk7dCs9b1tvLmxlbmd0aC0xXTt2YXIgaD1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsaCk7dmFyIGY9W107Zm9yKGk9MDtpPGgubGVuZ3RoLTE7aSsrKWYucHVzaChlLkNGRi5yZWFkRGljdChyLHQraFtpXSx0K2hbaSsxXSkpO3QrPWhbaC5sZW5ndGgtMV07dmFyIGQ9ZlswXSx1PVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCx1KTt2YXIgbD1bXTtmb3IoaT0wO2k8dS5sZW5ndGgtMTtpKyspbC5wdXNoKG4ucmVhZEFTQ0lJKHIsdCt1W2ldLHVbaSsxXS11W2ldKSk7aWYodCs9dVt1Lmxlbmd0aC0xXSxlLkNGRi5yZWFkU3VicnMocix0LGQpLGQuQ2hhclN0cmluZ3Mpe3Q9ZC5DaGFyU3RyaW5nczt1PVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCx1KTt2YXIgdj1bXTtmb3IoaT0wO2k8dS5sZW5ndGgtMTtpKyspdi5wdXNoKG4ucmVhZEJ5dGVzKHIsdCt1W2ldLHVbaSsxXS11W2ldKSk7ZC5DaGFyU3RyaW5ncz12O31pZihkLlJPUyl7dD1kLkZEQXJyYXk7dmFyIGM9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LGMpLGQuRkRBcnJheT1bXTtmb3IoaT0wO2k8Yy5sZW5ndGgtMTtpKyspe3ZhciBwPWUuQ0ZGLnJlYWREaWN0KHIsdCtjW2ldLHQrY1tpKzFdKTtlLkNGRi5fcmVhZEZEaWN0KHIscCxsKSxkLkZEQXJyYXkucHVzaChwKTt9dCs9Y1tjLmxlbmd0aC0xXSx0PWQuRkRTZWxlY3QsZC5GRFNlbGVjdD1bXTt2YXIgVT1yW3RdO2lmKHQrKywzIT1VKXRocm93IFU7dmFyIGc9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IoaT0wO2k8ZysxO2krKylkLkZEU2VsZWN0LnB1c2gobi5yZWFkVXNob3J0KHIsdCksclt0KzJdKSx0Kz0zO31yZXR1cm4gZC5FbmNvZGluZyYmKGQuRW5jb2Rpbmc9ZS5DRkYucmVhZEVuY29kaW5nKHIsZC5FbmNvZGluZyxkLkNoYXJTdHJpbmdzLmxlbmd0aCkpLGQuY2hhcnNldCYmKGQuY2hhcnNldD1lLkNGRi5yZWFkQ2hhcnNldChyLGQuY2hhcnNldCxkLkNoYXJTdHJpbmdzLmxlbmd0aCkpLGUuQ0ZGLl9yZWFkRkRpY3QocixkLGwpLGR9LGUuQ0ZGLl9yZWFkRkRpY3Q9ZnVuY3Rpb24ocix0LGEpe3ZhciBuO2Zvcih2YXIgbyBpbiB0LlByaXZhdGUmJihuPXQuUHJpdmF0ZVsxXSx0LlByaXZhdGU9ZS5DRkYucmVhZERpY3QocixuLG4rdC5Qcml2YXRlWzBdKSx0LlByaXZhdGUuU3VicnMmJmUuQ0ZGLnJlYWRTdWJycyhyLG4rdC5Qcml2YXRlLlN1YnJzLHQuUHJpdmF0ZSkpLHQpLTEhPVtcIkZhbWlseU5hbWVcIixcIkZvbnROYW1lXCIsXCJGdWxsTmFtZVwiLFwiTm90aWNlXCIsXCJ2ZXJzaW9uXCIsXCJDb3B5cmlnaHRcIl0uaW5kZXhPZihvKSYmKHRbb109YVt0W29dLTQyNiszNV0pO30sZS5DRkYucmVhZFN1YnJzPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsbyk7dmFyIHMsaT1vLmxlbmd0aDtzPWk8MTI0MD8xMDc6aTwzMzkwMD8xMTMxOjMyNzY4LGEuQmlhcz1zLGEuU3VicnM9W107Zm9yKHZhciBoPTA7aDxvLmxlbmd0aC0xO2grKylhLlN1YnJzLnB1c2gobi5yZWFkQnl0ZXMocix0K29baF0sb1toKzFdLW9baF0pKTt9LGUuQ0ZGLnRhYmxlU0U9WzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMCwxMTEsMTEyLDExMywxMTQsMCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDAsMTIzLDAsMTI0LDEyNSwxMjYsMTI3LDEyOCwxMjksMTMwLDEzMSwwLDEzMiwxMzMsMCwxMzQsMTM1LDEzNiwxMzcsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxMzgsMCwxMzksMCwwLDAsMCwxNDAsMTQxLDE0MiwxNDMsMCwwLDAsMCwwLDE0NCwwLDAsMCwxNDUsMCwwLDE0NiwxNDcsMTQ4LDE0OSwwLDAsMCwwXSxlLkNGRi5nbHlwaEJ5VW5pY29kZT1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5jaGFyc2V0Lmxlbmd0aDt0KyspaWYoci5jaGFyc2V0W3RdPT1lKXJldHVybiB0O3JldHVybiAtMX0sZS5DRkYuZ2x5cGhCeVNFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHQ8MHx8dD4yNTU/LTE6ZS5DRkYuZ2x5cGhCeVVuaWNvZGUocixlLkNGRi50YWJsZVNFW3RdKX0sZS5DRkYucmVhZEVuY29kaW5nPWZ1bmN0aW9uKHIsdCxhKXtlLl9iaW47dmFyIG49W1wiLm5vdGRlZlwiXSxvPXJbdF07aWYodCsrLDAhPW8pdGhyb3cgXCJlcnJvcjogdW5rbm93biBlbmNvZGluZyBmb3JtYXQ6IFwiK287dmFyIHM9clt0XTt0Kys7Zm9yKHZhciBpPTA7aTxzO2krKyluLnB1c2goclt0K2ldKTtyZXR1cm4gbn0sZS5DRkYucmVhZENoYXJzZXQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtcIi5ub3RkZWZcIl0scz1yW3RdO2lmKHQrKywwPT1zKWZvcih2YXIgaT0wO2k8YTtpKyspe3ZhciBoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGgpO31lbHNlIHtpZigxIT1zJiYyIT1zKXRocm93IFwiZXJyb3I6IGZvcm1hdDogXCIrcztmb3IoO28ubGVuZ3RoPGE7KXtoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9MDsxPT1zPyhmPXJbdF0sdCsrKTooZj1uLnJlYWRVc2hvcnQocix0KSx0Kz0yKTtmb3IoaT0wO2k8PWY7aSsrKW8ucHVzaChoKSxoKys7fX1yZXR1cm4gb30sZS5DRkYucmVhZEluZGV4PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1uLnJlYWRVc2hvcnQocix0KSsxLHM9clt0Kz0yXTtpZih0KyssMT09cylmb3IodmFyIGk9MDtpPG87aSsrKWEucHVzaChyW3QraV0pO2Vsc2UgaWYoMj09cylmb3IoaT0wO2k8bztpKyspYS5wdXNoKG4ucmVhZFVzaG9ydChyLHQrMippKSk7ZWxzZSBpZigzPT1zKWZvcihpPTA7aTxvO2krKylhLnB1c2goMTY3NzcyMTUmbi5yZWFkVWludChyLHQrMyppLTEpKTtlbHNlIGlmKDEhPW8pdGhyb3cgXCJ1bnN1cHBvcnRlZCBvZmZzZXQgc2l6ZTogXCIrcytcIiwgY291bnQ6IFwiK287cmV0dXJuICh0Kz1vKnMpLTF9LGUuQ0ZGLmdldENoYXJTdHJpbmc9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXJbdF0scz1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGk9MSxoPW51bGwsZj1udWxsO288PTIwJiYoaD1vLGk9MSksMTI9PW8mJihoPTEwMCpvK3MsaT0yKSwyMTw9byYmbzw9MjcmJihoPW8saT0xKSwyOD09byYmKGY9bi5yZWFkU2hvcnQocix0KzEpLGk9MyksMjk8PW8mJm88PTMxJiYoaD1vLGk9MSksMzI8PW8mJm88PTI0NiYmKGY9by0xMzksaT0xKSwyNDc8PW8mJm88PTI1MCYmKGY9MjU2KihvLTI0NykrcysxMDgsaT0yKSwyNTE8PW8mJm88PTI1NCYmKGY9MjU2Ki0oby0yNTEpLXMtMTA4LGk9MiksMjU1PT1vJiYoZj1uLnJlYWRJbnQocix0KzEpLzY1NTM1LGk9NSksYS52YWw9bnVsbCE9Zj9mOlwib1wiK2gsYS5zaXplPWk7fSxlLkNGRi5yZWFkQ2hhclN0cmluZz1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPXQrYSxvPWUuX2JpbixzPVtdO3Q8bjspe3ZhciBpPXJbdF0saD1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGY9MSxkPW51bGwsdT1udWxsO2k8PTIwJiYoZD1pLGY9MSksMTI9PWkmJihkPTEwMCppK2gsZj0yKSwxOSE9aSYmMjAhPWl8fChkPWksZj0yKSwyMTw9aSYmaTw9MjcmJihkPWksZj0xKSwyOD09aSYmKHU9by5yZWFkU2hvcnQocix0KzEpLGY9MyksMjk8PWkmJmk8PTMxJiYoZD1pLGY9MSksMzI8PWkmJmk8PTI0NiYmKHU9aS0xMzksZj0xKSwyNDc8PWkmJmk8PTI1MCYmKHU9MjU2KihpLTI0NykraCsxMDgsZj0yKSwyNTE8PWkmJmk8PTI1NCYmKHU9MjU2Ki0oaS0yNTEpLWgtMTA4LGY9MiksMjU1PT1pJiYodT1vLnJlYWRJbnQocix0KzEpLzY1NTM1LGY9NSkscy5wdXNoKG51bGwhPXU/dTpcIm9cIitkKSx0Kz1mO31yZXR1cm4gc30sZS5DRkYucmVhZERpY3Q9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4sbz17fSxzPVtdO3Q8YTspe3ZhciBpPXJbdF0saD1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGY9MSxkPW51bGwsdT1udWxsO2lmKDI4PT1pJiYodT1uLnJlYWRTaG9ydChyLHQrMSksZj0zKSwyOT09aSYmKHU9bi5yZWFkSW50KHIsdCsxKSxmPTUpLDMyPD1pJiZpPD0yNDYmJih1PWktMTM5LGY9MSksMjQ3PD1pJiZpPD0yNTAmJih1PTI1NiooaS0yNDcpK2grMTA4LGY9MiksMjUxPD1pJiZpPD0yNTQmJih1PTI1NiotKGktMjUxKS1oLTEwOCxmPTIpLDI1NT09aSl0aHJvdyB1PW4ucmVhZEludChyLHQrMSkvNjU1MzUsZj01LFwidW5rbm93biBudW1iZXJcIjtpZigzMD09aSl7dmFyIGw9W107Zm9yKGY9MTs7KXt2YXIgdj1yW3QrZl07ZisrO3ZhciBjPXY+PjQscD0xNSZ2O2lmKDE1IT1jJiZsLnB1c2goYyksMTUhPXAmJmwucHVzaChwKSwxNT09cClicmVha31mb3IodmFyIFU9XCJcIixnPVswLDEsMiwzLDQsNSw2LDcsOCw5LFwiLlwiLFwiZVwiLFwiZS1cIixcInJlc2VydmVkXCIsXCItXCIsXCJlbmRPZk51bWJlclwiXSxTPTA7UzxsLmxlbmd0aDtTKyspVSs9Z1tsW1NdXTt1PXBhcnNlRmxvYXQoVSk7fWlmKGk8PTIxKWlmKGQ9W1widmVyc2lvblwiLFwiTm90aWNlXCIsXCJGdWxsTmFtZVwiLFwiRmFtaWx5TmFtZVwiLFwiV2VpZ2h0XCIsXCJGb250QkJveFwiLFwiQmx1ZVZhbHVlc1wiLFwiT3RoZXJCbHVlc1wiLFwiRmFtaWx5Qmx1ZXNcIixcIkZhbWlseU90aGVyQmx1ZXNcIixcIlN0ZEhXXCIsXCJTdGRWV1wiLFwiZXNjYXBlXCIsXCJVbmlxdWVJRFwiLFwiWFVJRFwiLFwiY2hhcnNldFwiLFwiRW5jb2RpbmdcIixcIkNoYXJTdHJpbmdzXCIsXCJQcml2YXRlXCIsXCJTdWJyc1wiLFwiZGVmYXVsdFdpZHRoWFwiLFwibm9taW5hbFdpZHRoWFwiXVtpXSxmPTEsMTI9PWkpZD1bXCJDb3B5cmlnaHRcIixcImlzRml4ZWRQaXRjaFwiLFwiSXRhbGljQW5nbGVcIixcIlVuZGVybGluZVBvc2l0aW9uXCIsXCJVbmRlcmxpbmVUaGlja25lc3NcIixcIlBhaW50VHlwZVwiLFwiQ2hhcnN0cmluZ1R5cGVcIixcIkZvbnRNYXRyaXhcIixcIlN0cm9rZVdpZHRoXCIsXCJCbHVlU2NhbGVcIixcIkJsdWVTaGlmdFwiLFwiQmx1ZUZ1enpcIixcIlN0ZW1TbmFwSFwiLFwiU3RlbVNuYXBWXCIsXCJGb3JjZUJvbGRcIiwwLDAsXCJMYW5ndWFnZUdyb3VwXCIsXCJFeHBhbnNpb25GYWN0b3JcIixcImluaXRpYWxSYW5kb21TZWVkXCIsXCJTeW50aGV0aWNCYXNlXCIsXCJQb3N0U2NyaXB0XCIsXCJCYXNlRm9udE5hbWVcIixcIkJhc2VGb250QmxlbmRcIiwwLDAsMCwwLDAsMCxcIlJPU1wiLFwiQ0lERm9udFZlcnNpb25cIixcIkNJREZvbnRSZXZpc2lvblwiLFwiQ0lERm9udFR5cGVcIixcIkNJRENvdW50XCIsXCJVSURCYXNlXCIsXCJGREFycmF5XCIsXCJGRFNlbGVjdFwiLFwiRm9udE5hbWVcIl1baF0sZj0yO251bGwhPWQ/KG9bZF09MT09cy5sZW5ndGg/c1swXTpzLHM9W10pOnMucHVzaCh1KSx0Kz1mO31yZXR1cm4gb30sZS5jbWFwPXt9LGUuY21hcC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7cj1uZXcgVWludDhBcnJheShyLmJ1ZmZlcix0LGEpLHQ9MDt2YXIgbj1lLl9iaW4sbz17fTtuLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGk9W107by50YWJsZXM9W107Zm9yKHZhciBoPTA7aDxzO2grKyl7dmFyIGY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PW4ucmVhZFVpbnQocix0KTt0Kz00O3ZhciBsPVwicFwiK2YrXCJlXCIrZCx2PWkuaW5kZXhPZih1KTtpZigtMT09dil7dmFyIGM7dj1vLnRhYmxlcy5sZW5ndGgsaS5wdXNoKHUpO3ZhciBwPW4ucmVhZFVzaG9ydChyLHUpOzA9PXA/Yz1lLmNtYXAucGFyc2UwKHIsdSk6ND09cD9jPWUuY21hcC5wYXJzZTQocix1KTo2PT1wP2M9ZS5jbWFwLnBhcnNlNihyLHUpOjEyPT1wP2M9ZS5jbWFwLnBhcnNlMTIocix1KTpjb25zb2xlLmRlYnVnKFwidW5rbm93biBmb3JtYXQ6IFwiK3AsZixkLHUpLG8udGFibGVzLnB1c2goYyk7fWlmKG51bGwhPW9bbF0pdGhyb3cgXCJtdWx0aXBsZSB0YWJsZXMgZm9yIG9uZSBwbGF0Zm9ybStlbmNvZGluZ1wiO29bbF09djt9cmV0dXJuIG99LGUuY21hcC5wYXJzZTA9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixuLm1hcD1bXTtmb3IodmFyIHM9MDtzPG8tNjtzKyspbi5tYXAucHVzaChyW3Qrc10pO3JldHVybiBufSxlLmNtYXAucGFyc2U0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9O28uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGg9aS8yO28uc2VhcmNoUmFuZ2U9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLmVudHJ5U2VsZWN0b3I9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLnJhbmdlU2hpZnQ9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLmVuZENvdW50PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCx0Kz0yLG8uc3RhcnRDb3VudD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsby5pZERlbHRhPVtdO2Zvcih2YXIgZj0wO2Y8aDtmKyspby5pZERlbHRhLnB1c2goYS5yZWFkU2hvcnQocix0KSksdCs9Mjtmb3Ioby5pZFJhbmdlT2Zmc2V0PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCxvLmdseXBoSWRBcnJheT1bXTt0PG4rczspby5nbHlwaElkQXJyYXkucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gb30sZS5jbWFwLnBhcnNlNj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4uZmlyc3RDb2RlPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixuLmdseXBoSWRBcnJheT1bXTtmb3IodmFyIHM9MDtzPG87cysrKW4uZ2x5cGhJZEFycmF5LnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG59LGUuY21hcC5wYXJzZTEyPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mix0Kz0yLGEucmVhZFVpbnQocix0KSx0Kz00LGEucmVhZFVpbnQocix0KSx0Kz00O3ZhciBvPWEucmVhZFVpbnQocix0KTt0Kz00LG4uZ3JvdXBzPVtdO2Zvcih2YXIgcz0wO3M8bztzKyspe3ZhciBpPXQrMTIqcyxoPWEucmVhZFVpbnQocixpKzApLGY9YS5yZWFkVWludChyLGkrNCksZD1hLnJlYWRVaW50KHIsaSs4KTtuLmdyb3Vwcy5wdXNoKFtoLGYsZF0pO31yZXR1cm4gbn0sZS5nbHlmPXt9LGUuZ2x5Zi5wYXJzZT1mdW5jdGlvbihyLGUsdCxhKXtmb3IodmFyIG49W10sbz0wO288YS5tYXhwLm51bUdseXBocztvKyspbi5wdXNoKG51bGwpO3JldHVybiBufSxlLmdseWYuX3BhcnNlR2x5Zj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXIuX2RhdGEsbz1lLl90YWJPZmZzZXQobixcImdseWZcIixyLl9vZmZzZXQpK3IubG9jYVt0XTtpZihyLmxvY2FbdF09PXIubG9jYVt0KzFdKXJldHVybiBudWxsO3ZhciBzPXt9O2lmKHMubm9jPWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNaW49YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueU1pbj1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWF4PWEucmVhZFNob3J0KG4sbyksbys9MixzLnlNYXg9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1pbj49cy54TWF4fHxzLnlNaW4+PXMueU1heClyZXR1cm4gbnVsbDtpZihzLm5vYz4wKXtzLmVuZFB0cz1bXTtmb3IodmFyIGk9MDtpPHMubm9jO2krKylzLmVuZFB0cy5wdXNoKGEucmVhZFVzaG9ydChuLG8pKSxvKz0yO3ZhciBoPWEucmVhZFVzaG9ydChuLG8pO2lmKG8rPTIsbi5sZW5ndGgtbzxoKXJldHVybiBudWxsO3MuaW5zdHJ1Y3Rpb25zPWEucmVhZEJ5dGVzKG4sbyxoKSxvKz1oO3ZhciBmPXMuZW5kUHRzW3Mubm9jLTFdKzE7cy5mbGFncz1bXTtmb3IoaT0wO2k8ZjtpKyspe3ZhciBkPW5bb107aWYobysrLHMuZmxhZ3MucHVzaChkKSwwIT0oOCZkKSl7dmFyIHU9bltvXTtvKys7Zm9yKHZhciBsPTA7bDx1O2wrKylzLmZsYWdzLnB1c2goZCksaSsrO319cy54cz1bXTtmb3IoaT0wO2k8ZjtpKyspe3ZhciB2PTAhPSgyJnMuZmxhZ3NbaV0pLGM9MCE9KDE2JnMuZmxhZ3NbaV0pO3Y/KHMueHMucHVzaChjP25bb106LW5bb10pLG8rKyk6Yz9zLnhzLnB1c2goMCk6KHMueHMucHVzaChhLnJlYWRTaG9ydChuLG8pKSxvKz0yKTt9cy55cz1bXTtmb3IoaT0wO2k8ZjtpKyspe3Y9MCE9KDQmcy5mbGFnc1tpXSksYz0wIT0oMzImcy5mbGFnc1tpXSk7dj8ocy55cy5wdXNoKGM/bltvXTotbltvXSksbysrKTpjP3MueXMucHVzaCgwKToocy55cy5wdXNoKGEucmVhZFNob3J0KG4sbykpLG8rPTIpO312YXIgcD0wLFU9MDtmb3IoaT0wO2k8ZjtpKyspcCs9cy54c1tpXSxVKz1zLnlzW2ldLHMueHNbaV09cCxzLnlzW2ldPVU7fWVsc2Uge3ZhciBnO3MucGFydHM9W107ZG97Zz1hLnJlYWRVc2hvcnQobixvKSxvKz0yO3ZhciBTPXttOnthOjEsYjowLGM6MCxkOjEsdHg6MCx0eTowfSxwMTotMSxwMjotMX07aWYocy5wYXJ0cy5wdXNoKFMpLFMuZ2x5cGhJbmRleD1hLnJlYWRVc2hvcnQobixvKSxvKz0yLDEmZyl7dmFyIG09YS5yZWFkU2hvcnQobixvKTtvKz0yO3ZhciBiPWEucmVhZFNob3J0KG4sbyk7bys9Mjt9ZWxzZSB7bT1hLnJlYWRJbnQ4KG4sbyk7bysrO2I9YS5yZWFkSW50OChuLG8pO28rKzt9MiZnPyhTLm0udHg9bSxTLm0udHk9Yik6KFMucDE9bSxTLnAyPWIpLDgmZz8oUy5tLmE9Uy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpOjY0Jmc/KFMubS5hPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKToxMjgmZyYmKFMubS5hPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5iPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5jPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKTt9d2hpbGUoMzImZyk7aWYoMjU2Jmcpe3ZhciB5PWEucmVhZFVzaG9ydChuLG8pO28rPTIscy5pbnN0cj1bXTtmb3IoaT0wO2k8eTtpKyspcy5pbnN0ci5wdXNoKG5bb10pLG8rKzt9fXJldHVybiBzfSxlLkdQT1M9e30sZS5HUE9TLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HUE9TLnN1YnQpfSxlLkdQT1Muc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxPT10fHwyPT10fHwzPT10fHw3PT10fHw4PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsaCtzKTt9aWYoMT09dCYmMT09aS5mbXQpe3ZhciBmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIGQ9ZS5fbGN0Zi5udW1PZk9uZXMoZik7MCE9ZiYmKGkucG9zPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLGYpKTt9ZWxzZSBpZigyPT10JiZpLmZtdD49MSYmaS5mbXQ8PTIpe2Y9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgdT1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Q9ZS5fbGN0Zi5udW1PZk9uZXMoZik7dmFyIGw9ZS5fbGN0Zi5udW1PZk9uZXModSk7aWYoMT09aS5mbXQpe2kucGFpcnNldHM9W107dmFyIHY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGM9MDtjPHY7YysrKXt2YXIgcD1zK28ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIFU9by5yZWFkVXNob3J0KHIscCk7cCs9Mjtmb3IodmFyIGc9W10sUz0wO1M8VTtTKyspe3ZhciBtPW8ucmVhZFVzaG9ydChyLHApO3ArPTIsMCE9ZiYmKHg9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLHAsZikscCs9MipkKSwwIT11JiYoUD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIscCx1KSxwKz0yKmwpLGcucHVzaCh7Z2lkMjptLHZhbDE6eCx2YWwyOlB9KTt9aS5wYWlyc2V0cy5wdXNoKGcpO319aWYoMj09aS5mbXQpe3ZhciBiPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHk9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgRj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBfPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jbGFzc0RlZjE9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK2IpLGkuY2xhc3NEZWYyPWUuX2xjdGYucmVhZENsYXNzRGVmKHIscyt5KSxpLm1hdHJpeD1bXTtmb3IoYz0wO2M8RjtjKyspe3ZhciBDPVtdO2ZvcihTPTA7UzxfO1MrKyl7dmFyIHg9bnVsbCxQPW51bGw7MCE9ZiYmKHg9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZiksYSs9MipkKSwwIT11JiYoUD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSx1KSxhKz0yKmwpLEMucHVzaCh7dmFsMTp4LHZhbDI6UH0pO31pLm1hdHJpeC5wdXNoKEMpO319fWVsc2Uge2lmKDk9PXQmJjE9PWkuZm10KXt2YXIgST1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB3PW8ucmVhZFVpbnQocixhKTtpZihhKz00LDk9PW4ubHR5cGUpbi5sdHlwZT1JO2Vsc2UgaWYobi5sdHlwZSE9SSl0aHJvdyBcImludmFsaWQgZXh0ZW5zaW9uIHN1YnN0aXR1dGlvblwiO3JldHVybiBlLkdQT1Muc3VidChyLG4ubHR5cGUscyt3KX1jb25zb2xlLmRlYnVnKFwidW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSBMb29rdXBUeXBlXCIsdCxcImZvcm1hdFwiLGkuZm10KTt9cmV0dXJuIGl9LGUuR1BPUy5yZWFkVmFsdWVSZWNvcmQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtdO3JldHVybiBvLnB1c2goMSZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MSZhPzI6MCxvLnB1c2goMiZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MiZhPzI6MCxvLnB1c2goNCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9NCZhPzI6MCxvLnB1c2goOCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9OCZhPzI6MCxvfSxlLkdTVUI9e30sZS5HU1VCLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HU1VCLnN1YnQpfSxlLkdTVUIuc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxIT10JiY0IT10JiY1IT10JiY2IT10KXJldHVybiBudWxsO2lmKDE9PXR8fDQ9PXR8fDU9PXQmJmkuZm10PD0yfHw2PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIscytoKTt9aWYoMT09dCYmaS5mbXQ+PTEmJmkuZm10PD0yKXtpZigxPT1pLmZtdClpLmRlbHRhPW8ucmVhZFNob3J0KHIsYSksYSs9MjtlbHNlIGlmKDI9PWkuZm10KXt2YXIgZj1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkubmV3Zz1vLnJlYWRVc2hvcnRzKHIsYSxmKSxhKz0yKmkubmV3Zy5sZW5ndGg7fX1lbHNlIGlmKDQ9PXQpe2kudmFscz1bXTtmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKHZhciBkPTA7ZDxmO2QrKyl7dmFyIHU9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLnZhbHMucHVzaChlLkdTVUIucmVhZExpZ2F0dXJlU2V0KHIscyt1KSk7fX1lbHNlIGlmKDU9PXQmJjI9PWkuZm10KXtpZigyPT1pLmZtdCl7dmFyIGw9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNEZWY9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK2wpLGkuc2NzZXQ9W107dmFyIHY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IoZD0wO2Q8djtkKyspe3ZhciBjPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5zY3NldC5wdXNoKDA9PWM/bnVsbDplLkdTVUIucmVhZFN1YkNsYXNzU2V0KHIscytjKSk7fX19ZWxzZSBpZig2PT10JiYzPT1pLmZtdCl7aWYoMz09aS5mbXQpe2ZvcihkPTA7ZDwzO2QrKyl7Zj1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Zvcih2YXIgcD1bXSxVPTA7VTxmO1UrKylwLnB1c2goZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixzK28ucmVhZFVzaG9ydChyLGErMipVKSkpO2ErPTIqZiwwPT1kJiYoaS5iYWNrQ3ZnPXApLDE9PWQmJihpLmlucHRDdmc9cCksMj09ZCYmKGkuYWhlZEN2Zz1wKTt9Zj1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkubG9va3VwUmVjPWUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzKHIsYSxmKTt9fWVsc2Uge2lmKDc9PXQmJjE9PWkuZm10KXt2YXIgZz1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBTPW8ucmVhZFVpbnQocixhKTtpZihhKz00LDk9PW4ubHR5cGUpbi5sdHlwZT1nO2Vsc2UgaWYobi5sdHlwZSE9Zyl0aHJvdyBcImludmFsaWQgZXh0ZW5zaW9uIHN1YnN0aXR1dGlvblwiO3JldHVybiBlLkdTVUIuc3VidChyLG4ubHR5cGUscytTKX1jb25zb2xlLmRlYnVnKFwidW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSBMb29rdXBUeXBlXCIsdCxcImZvcm1hdFwiLGkuZm10KTt9cmV0dXJuIGl9LGUuR1NVQi5yZWFkU3ViQ2xhc3NTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4ucmVhZFVzaG9ydCxuPXQsbz1bXSxzPWEocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZFN1YkNsYXNzUnVsZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRTdWJDbGFzc1J1bGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4ucmVhZFVzaG9ydCxuPXt9LG89YShyLHQpLHM9YShyLHQrPTIpO3QrPTIsbi5pbnB1dD1bXTtmb3IodmFyIGk9MDtpPG8tMTtpKyspbi5pbnB1dC5wdXNoKGEocix0KSksdCs9MjtyZXR1cm4gbi5zdWJzdExvb2t1cFJlY29yZHM9ZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMocix0LHMpLG59LGUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLnJlYWRVc2hvcnQsbz1bXSxzPTA7czxhO3MrKylvLnB1c2gobihyLHQpLG4ocix0KzIpKSx0Kz00O3JldHVybiBvfSxlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGU9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGE9ZS5fYmluLG49e30sbz1bXCJiYWNrdHJhY2tcIixcImlucHV0XCIsXCJsb29rYWhlYWRcIl0scz0wO3M8by5sZW5ndGg7cysrKXt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLDE9PXMmJmktLSxuW29bc11dPWEucmVhZFVzaG9ydHMocix0LGkpLHQrPTIqbltvW3NdXS5sZW5ndGg7fWk9YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsbi5zdWJzdD1hLnJlYWRVc2hvcnRzKHIsdCwyKmkpLHQrPTIqbi5zdWJzdC5sZW5ndGgsbn0sZS5HU1VCLnJlYWRMaWdhdHVyZVNldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz1bXSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRMaWdhdHVyZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRMaWdhdHVyZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXtjaGFpbjpbXX07bi5uZ2x5cGg9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgcz0wO3M8by0xO3MrKyluLmNoYWluLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG59LGUuaGVhZD17fSxlLmhlYWQucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBuLnJlYWRGaXhlZChyLHQpLHQrPTQsby5mb250UmV2aXNpb249bi5yZWFkRml4ZWQocix0KSx0Kz00LG4ucmVhZFVpbnQocix0KSx0Kz00LG4ucmVhZFVpbnQocix0KSx0Kz00LG8uZmxhZ3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLnVuaXRzUGVyRW09bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmNyZWF0ZWQ9bi5yZWFkVWludDY0KHIsdCksdCs9OCxvLm1vZGlmaWVkPW4ucmVhZFVpbnQ2NChyLHQpLHQrPTgsby54TWluPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnlNaW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueE1heD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby55TWF4PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm1hY1N0eWxlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5sb3dlc3RSZWNQUEVNPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5mb250RGlyZWN0aW9uSGludD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5pbmRleFRvTG9jRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmdseXBoRGF0YUZvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsb30sZS5oaGVhPXt9LGUuaGhlYS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLmFzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmRlc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5saW5lR2FwPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmFkdmFuY2VXaWR0aE1heD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWluTGVmdFNpZGVCZWFyaW5nPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm1pblJpZ2h0U2lkZUJlYXJpbmc9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueE1heEV4dGVudD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldFNsb3BlUmlzZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldFNsb3BlUnVuPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0T2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9Mix0Kz04LG8ubWV0cmljRGF0YUZvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5udW1iZXJPZkhNZXRyaWNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsb30sZS5obXR4PXt9LGUuaG10eC5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXtmb3IodmFyIG89ZS5fYmluLHM9e2FXaWR0aDpbXSxsc0JlYXJpbmc6W119LGk9MCxoPTAsZj0wO2Y8bi5tYXhwLm51bUdseXBocztmKyspZjxuLmhoZWEubnVtYmVyT2ZITWV0cmljcyYmKGk9by5yZWFkVXNob3J0KHIsdCksdCs9MixoPW8ucmVhZFNob3J0KHIsdCksdCs9Mikscy5hV2lkdGgucHVzaChpKSxzLmxzQmVhcmluZy5wdXNoKGgpO3JldHVybiBzfSxlLmtlcm49e30sZS5rZXJuLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPW8ucmVhZFVzaG9ydChyLHQpO2lmKHQrPTIsMT09cylyZXR1cm4gZS5rZXJuLnBhcnNlVjEocix0LTIsYSxuKTt2YXIgaT1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD17Z2x5cGgxOltdLHJ2YWw6W119LGY9MDtmPGk7ZisrKXt0Kz0yO2E9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PWQ+Pj44O2lmKDAhPSh1Jj0xNSkpdGhyb3cgXCJ1bmtub3duIGtlcm4gdGFibGUgZm9ybWF0OiBcIit1O3Q9ZS5rZXJuLnJlYWRGb3JtYXQwKHIsdCxoKTt9cmV0dXJuIGh9LGUua2Vybi5wYXJzZVYxPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbjtvLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIHM9by5yZWFkVWludChyLHQpO3QrPTQ7Zm9yKHZhciBpPXtnbHlwaDE6W10scnZhbDpbXX0saD0wO2g8cztoKyspe28ucmVhZFVpbnQocix0KSx0Kz00O3ZhciBmPW8ucmVhZFVzaG9ydChyLHQpO3QrPTIsby5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgZD1mPj4+ODtpZigwIT0oZCY9MTUpKXRocm93IFwidW5rbm93biBrZXJuIHRhYmxlIGZvcm1hdDogXCIrZDt0PWUua2Vybi5yZWFkRm9ybWF0MChyLHQsaSk7fXJldHVybiBpfSxlLmtlcm4ucmVhZEZvcm1hdDA9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPS0xLHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9bi5yZWFkU2hvcnQocix0KTt0Kz0yLGghPW8mJihhLmdseXBoMS5wdXNoKGgpLGEucnZhbC5wdXNoKHtnbHlwaDI6W10sdmFsczpbXX0pKTt2YXIgdT1hLnJ2YWxbYS5ydmFsLmxlbmd0aC0xXTt1LmdseXBoMi5wdXNoKGYpLHUudmFscy5wdXNoKGQpLG89aDt9cmV0dXJuIHR9LGUubG9jYT17fSxlLmxvY2EucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluLHM9W10saT1uLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdCxoPW4ubWF4cC5udW1HbHlwaHMrMTtpZigwPT1pKWZvcih2YXIgZj0wO2Y8aDtmKyspcy5wdXNoKG8ucmVhZFVzaG9ydChyLHQrKGY8PDEpKTw8MSk7aWYoMT09aSlmb3IoZj0wO2Y8aDtmKyspcy5wdXNoKG8ucmVhZFVpbnQocix0KyhmPDwyKSkpO3JldHVybiBzfSxlLm1heHA9e30sZS5tYXhwLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fSxzPW4ucmVhZFVpbnQocix0KTtyZXR1cm4gdCs9NCxvLm51bUdseXBocz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLDY1NTM2PT1zJiYoby5tYXhQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbnRvdXJzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb3NpdGVQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvc2l0ZUNvbnRvdXJzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhab25lcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4VHdpbGlnaHRQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFN0b3JhZ2U9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heEZ1bmN0aW9uRGVmcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4SW5zdHJ1Y3Rpb25EZWZzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTdGFja0VsZW1lbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTaXplT2ZJbnN0cnVjdGlvbnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvbmVudEVsZW1lbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb25lbnREZXB0aD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yKSxvfSxlLm5hbWU9e30sZS5uYW1lLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtuLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5yZWFkVXNob3J0KHIsdCk7Zm9yKHZhciBpLGg9W1wiY29weXJpZ2h0XCIsXCJmb250RmFtaWx5XCIsXCJmb250U3ViZmFtaWx5XCIsXCJJRFwiLFwiZnVsbE5hbWVcIixcInZlcnNpb25cIixcInBvc3RTY3JpcHROYW1lXCIsXCJ0cmFkZW1hcmtcIixcIm1hbnVmYWN0dXJlclwiLFwiZGVzaWduZXJcIixcImRlc2NyaXB0aW9uXCIsXCJ1cmxWZW5kb3JcIixcInVybERlc2lnbmVyXCIsXCJsaWNlbmNlXCIsXCJsaWNlbmNlVVJMXCIsXCItLS1cIixcInR5cG9GYW1pbHlOYW1lXCIsXCJ0eXBvU3ViZmFtaWx5TmFtZVwiLFwiY29tcGF0aWJsZUZ1bGxcIixcInNhbXBsZVRleHRcIixcInBvc3RTY3JpcHRDSURcIixcInd3c0ZhbWlseU5hbWVcIixcInd3c1N1YmZhbWlseU5hbWVcIixcImxpZ2h0UGFsZXR0ZVwiLFwiZGFya1BhbGV0dGVcIl0sZj10Kz0yLGQ9MDtkPHM7ZCsrKXt2YXIgdT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBsPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgYz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBwPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIFU9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZyxTPWhbY10sbT1mKzEyKnMrVTtpZigwPT11KWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDM9PXUmJjA9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMD09bClnPW4ucmVhZEFTQ0lJKHIsbSxwKTtlbHNlIGlmKDE9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMz09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSB7aWYoMSE9dSl0aHJvdyBcInVua25vd24gZW5jb2RpbmcgXCIrbCtcIiwgcGxhdGZvcm1JRDogXCIrdTtnPW4ucmVhZEFTQ0lJKHIsbSxwKSxjb25zb2xlLmRlYnVnKFwicmVhZGluZyB1bmtub3duIE1BQyBlbmNvZGluZyBcIitsK1wiIGFzIEFTQ0lJXCIpO312YXIgYj1cInBcIit1K1wiLFwiK3YudG9TdHJpbmcoMTYpO251bGw9PW9bYl0mJihvW2JdPXt9KSxvW2JdW3ZvaWQgMCE9PVM/UzpjXT1nLG9bYl0uX2xhbmc9djt9Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMTAzMz09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYwPT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjMwODQ9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSlyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbyl7aT15O2JyZWFrfXJldHVybiBjb25zb2xlLmRlYnVnKFwicmV0dXJuaW5nIG5hbWUgdGFibGUgd2l0aCBsYW5ndWFnZUlEIFwiK29baV0uX2xhbmcpLG9baV19LGVbXCJPUy8yXCJdPXt9LGVbXCJPUy8yXCJdLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIG89e307aWYoMD09billW1wiT1MvMlwiXS52ZXJzaW9uMChyLHQsbyk7ZWxzZSBpZigxPT1uKWVbXCJPUy8yXCJdLnZlcnNpb24xKHIsdCxvKTtlbHNlIGlmKDI9PW58fDM9PW58fDQ9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjIocix0LG8pO2Vsc2Uge2lmKDUhPW4pdGhyb3cgXCJ1bmtub3duIE9TLzIgdGFibGUgdmVyc2lvbjogXCIrbjtlW1wiT1MvMlwiXS52ZXJzaW9uNShyLHQsbyk7fXJldHVybiBvfSxlW1wiT1MvMlwiXS52ZXJzaW9uMD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiBhLnhBdmdDaGFyV2lkdGg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNXZWlnaHRDbGFzcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNXaWR0aENsYXNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5mc1R5cGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRYU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WVNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFhPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFlPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WVNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRZT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdHJpa2VvdXRTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdHJpa2VvdXRQb3NpdGlvbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zRmFtaWx5Q2xhc3M9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEucGFub3NlPW4ucmVhZEJ5dGVzKHIsdCwxMCksdCs9MTAsYS51bFVuaWNvZGVSYW5nZTE9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTI9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTM9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTQ9bi5yZWFkVWludChyLHQpLHQrPTQsYS5hY2hWZW5kSUQ9W24ucmVhZEludDgocix0KSxuLnJlYWRJbnQ4KHIsdCsxKSxuLnJlYWRJbnQ4KHIsdCsyKSxuLnJlYWRJbnQ4KHIsdCszKV0sdCs9NCxhLmZzU2VsZWN0aW9uPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0ZpcnN0Q2hhckluZGV4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0xhc3RDaGFySW5kZXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnNUeXBvQXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc1R5cG9EZXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc1R5cG9MaW5lR2FwPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzV2luQXNjZW50PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1dpbkRlc2NlbnQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZVtcIk9TLzJcIl0udmVyc2lvbjE9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMChyLHQsYSksYS51bENvZGVQYWdlUmFuZ2UxPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxDb2RlUGFnZVJhbmdlMj1uLnJlYWRVaW50KHIsdCksdCs9NH0sZVtcIk9TLzJcIl0udmVyc2lvbjI9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMShyLHQsYSksYS5zeEhlaWdodD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zQ2FwSGVpZ2h0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzRGVmYXVsdD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNCcmVhaz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNNYXhDb250ZXh0PW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGVbXCJPUy8yXCJdLnZlcnNpb241PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjIocix0LGEpLGEudXNMb3dlck9wdGljYWxQb2ludFNpemU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzVXBwZXJPcHRpY2FsUG9pbnRTaXplPW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGUucG9zdD17fSxlLnBvc3QucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBvLnZlcnNpb249bi5yZWFkRml4ZWQocix0KSx0Kz00LG8uaXRhbGljQW5nbGU9bi5yZWFkRml4ZWQocix0KSx0Kz00LG8udW5kZXJsaW5lUG9zaXRpb249bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8udW5kZXJsaW5lVGhpY2tuZXNzPW4ucmVhZFNob3J0KHIsdCksdCs9MixvfSxudWxsPT1lJiYoZT17fSksbnVsbD09ZS5VJiYoZS5VPXt9KSxlLlUuY29kZVRvR2x5cGg9ZnVuY3Rpb24ocixlKXt2YXIgdD1yLmNtYXAsYT0tMTtpZihudWxsIT10LnAwZTQ/YT10LnAwZTQ6bnVsbCE9dC5wM2UxP2E9dC5wM2UxOm51bGwhPXQucDFlMD9hPXQucDFlMDpudWxsIT10LnAwZTMmJihhPXQucDBlMyksLTE9PWEpdGhyb3cgXCJubyBmYW1pbGlhciBwbGF0Zm9ybSBhbmQgZW5jb2RpbmchXCI7dmFyIG49dC50YWJsZXNbYV07aWYoMD09bi5mb3JtYXQpcmV0dXJuIGU+PW4ubWFwLmxlbmd0aD8wOm4ubWFwW2VdO2lmKDQ9PW4uZm9ybWF0KXtmb3IodmFyIG89LTEscz0wO3M8bi5lbmRDb3VudC5sZW5ndGg7cysrKWlmKGU8PW4uZW5kQ291bnRbc10pe289czticmVha31pZigtMT09bylyZXR1cm4gMDtpZihuLnN0YXJ0Q291bnRbb10+ZSlyZXR1cm4gMDtyZXR1cm4gNjU1MzUmKDAhPW4uaWRSYW5nZU9mZnNldFtvXT9uLmdseXBoSWRBcnJheVtlLW4uc3RhcnRDb3VudFtvXSsobi5pZFJhbmdlT2Zmc2V0W29dPj4xKS0obi5pZFJhbmdlT2Zmc2V0Lmxlbmd0aC1vKV06ZStuLmlkRGVsdGFbb10pfWlmKDEyPT1uLmZvcm1hdCl7aWYoZT5uLmdyb3Vwc1tuLmdyb3Vwcy5sZW5ndGgtMV1bMV0pcmV0dXJuIDA7Zm9yKHM9MDtzPG4uZ3JvdXBzLmxlbmd0aDtzKyspe3ZhciBpPW4uZ3JvdXBzW3NdO2lmKGlbMF08PWUmJmU8PWlbMV0pcmV0dXJuIGlbMl0rKGUtaVswXSl9cmV0dXJuIDB9dGhyb3cgXCJ1bmtub3duIGNtYXAgdGFibGUgZm9ybWF0IFwiK24uZm9ybWF0fSxlLlUuZ2x5cGhUb1BhdGg9ZnVuY3Rpb24ocix0KXt2YXIgYT17Y21kczpbXSxjcmRzOltdfTtpZihyLlNWRyYmci5TVkcuZW50cmllc1t0XSl7dmFyIG49ci5TVkcuZW50cmllc1t0XTtyZXR1cm4gbnVsbD09bj9hOihcInN0cmluZ1wiPT10eXBlb2YgbiYmKG49ZS5TVkcudG9QYXRoKG4pLHIuU1ZHLmVudHJpZXNbdF09biksbil9aWYoci5DRkYpe3ZhciBvPXt4OjAseTowLHN0YWNrOltdLG5TdGVtczowLGhhdmVXaWR0aDohMSx3aWR0aDpyLkNGRi5Qcml2YXRlP3IuQ0ZGLlByaXZhdGUuZGVmYXVsdFdpZHRoWDowLG9wZW46ITF9LHM9ci5DRkYsaT1yLkNGRi5Qcml2YXRlO2lmKHMuUk9TKXtmb3IodmFyIGg9MDtzLkZEU2VsZWN0W2grMl08PXQ7KWgrPTI7aT1zLkZEQXJyYXlbcy5GRFNlbGVjdFtoKzFdXS5Qcml2YXRlO31lLlUuX2RyYXdDRkYoci5DRkYuQ2hhclN0cmluZ3NbdF0sbyxzLGksYSk7fWVsc2Ugci5nbHlmJiZlLlUuX2RyYXdHbHlmKHQscixhKTtyZXR1cm4gYX0sZS5VLl9kcmF3R2x5Zj1mdW5jdGlvbihyLHQsYSl7dmFyIG49dC5nbHlmW3JdO251bGw9PW4mJihuPXQuZ2x5ZltyXT1lLmdseWYuX3BhcnNlR2x5Zih0LHIpKSxudWxsIT1uJiYobi5ub2M+LTE/ZS5VLl9zaW1wbGVHbHlwaChuLGEpOmUuVS5fY29tcG9HbHlwaChuLHQsYSkpO30sZS5VLl9zaW1wbGVHbHlwaD1mdW5jdGlvbihyLHQpe2Zvcih2YXIgYT0wO2E8ci5ub2M7YSsrKXtmb3IodmFyIG49MD09YT8wOnIuZW5kUHRzW2EtMV0rMSxvPXIuZW5kUHRzW2FdLHM9bjtzPD1vO3MrKyl7dmFyIGk9cz09bj9vOnMtMSxoPXM9PW8/bjpzKzEsZj0xJnIuZmxhZ3Nbc10sZD0xJnIuZmxhZ3NbaV0sdT0xJnIuZmxhZ3NbaF0sbD1yLnhzW3NdLHY9ci55c1tzXTtpZihzPT1uKWlmKGYpe2lmKCFkKXtlLlUuUC5tb3ZlVG8odCxsLHYpO2NvbnRpbnVlfWUuVS5QLm1vdmVUbyh0LHIueHNbaV0sci55c1tpXSk7fWVsc2UgZD9lLlUuUC5tb3ZlVG8odCxyLnhzW2ldLHIueXNbaV0pOmUuVS5QLm1vdmVUbyh0LChyLnhzW2ldK2wpLzIsKHIueXNbaV0rdikvMik7Zj9kJiZlLlUuUC5saW5lVG8odCxsLHYpOnU/ZS5VLlAucWN1cnZlVG8odCxsLHYsci54c1toXSxyLnlzW2hdKTplLlUuUC5xY3VydmVUbyh0LGwsdiwobCtyLnhzW2hdKS8yLCh2K3IueXNbaF0pLzIpO31lLlUuUC5jbG9zZVBhdGgodCk7fX0sZS5VLl9jb21wb0dseXBoPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49MDtuPHIucGFydHMubGVuZ3RoO24rKyl7dmFyIG89e2NtZHM6W10sY3JkczpbXX0scz1yLnBhcnRzW25dO2UuVS5fZHJhd0dseWYocy5nbHlwaEluZGV4LHQsbyk7Zm9yKHZhciBpPXMubSxoPTA7aDxvLmNyZHMubGVuZ3RoO2grPTIpe3ZhciBmPW8uY3Jkc1toXSxkPW8uY3Jkc1toKzFdO2EuY3Jkcy5wdXNoKGYqaS5hK2QqaS5iK2kudHgpLGEuY3Jkcy5wdXNoKGYqaS5jK2QqaS5kK2kudHkpO31mb3IoaD0wO2g8by5jbWRzLmxlbmd0aDtoKyspYS5jbWRzLnB1c2goby5jbWRzW2hdKTt9fSxlLlUuX2dldEdseXBoQ2xhc3M9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9sY3RmLmdldEludGVydmFsKHQscik7cmV0dXJuIC0xPT1hPzA6dFthKzJdfSxlLlUuZ2V0UGFpckFkanVzdG1lbnQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPSExO2lmKHIuR1BPUylmb3IodmFyIG89ci5HUE9TLHM9by5sb29rdXBMaXN0LGk9by5mZWF0dXJlTGlzdCxoPVtdLGY9MDtmPGkubGVuZ3RoO2YrKyl7dmFyIGQ9aVtmXTtpZihcImtlcm5cIj09ZC50YWcpe249ITA7Zm9yKHZhciB1PTA7dTxkLnRhYi5sZW5ndGg7dSsrKWlmKCFoW2QudGFiW3VdXSl7aFtkLnRhYlt1XV09ITA7Zm9yKHZhciBsPXNbZC50YWJbdV1dLHY9MDt2PGwudGFicy5sZW5ndGg7disrKWlmKG51bGwhPWwudGFic1t2XSl7dmFyIGMscD1sLnRhYnNbdl07aWYoIXAuY292ZXJhZ2V8fC0xIT0oYz1lLl9sY3RmLmNvdmVyYWdlSW5kZXgocC5jb3ZlcmFnZSx0KSkpaWYoMT09bC5sdHlwZSk7ZWxzZSBpZigyPT1sLmx0eXBlKXt2YXIgVT1udWxsO2lmKDE9PXAuZm10KXt2YXIgZz1wLnBhaXJzZXRzW2NdO2ZvcihmPTA7ZjxnLmxlbmd0aDtmKyspZ1tmXS5naWQyPT1hJiYoVT1nW2ZdKTt9ZWxzZSBpZigyPT1wLmZtdCl7dmFyIFM9ZS5VLl9nZXRHbHlwaENsYXNzKHQscC5jbGFzc0RlZjEpLG09ZS5VLl9nZXRHbHlwaENsYXNzKGEscC5jbGFzc0RlZjIpO1U9cC5tYXRyaXhbU11bbV07fWlmKFUpe3ZhciBiPTA7cmV0dXJuIFUudmFsMSYmVS52YWwxWzJdJiYoYis9VS52YWwxWzJdKSxVLnZhbDImJlUudmFsMlswXSYmKGIrPVUudmFsMlswXSksYn19fX19fWlmKHIua2VybiYmIW4pe3ZhciB5PXIua2Vybi5nbHlwaDEuaW5kZXhPZih0KTtpZigtMSE9eSl7dmFyIEY9ci5rZXJuLnJ2YWxbeV0uZ2x5cGgyLmluZGV4T2YoYSk7aWYoLTEhPUYpcmV0dXJuIHIua2Vybi5ydmFsW3ldLnZhbHNbRl19fXJldHVybiAwfSxlLlUuX2FwcGx5U3Vicz1mdW5jdGlvbihyLHQsYSxuKXtmb3IodmFyIG89ci5sZW5ndGgtdC0xLHM9MDtzPGEudGFicy5sZW5ndGg7cysrKWlmKG51bGwhPWEudGFic1tzXSl7dmFyIGksaD1hLnRhYnNbc107aWYoIWguY292ZXJhZ2V8fC0xIT0oaT1lLl9sY3RmLmNvdmVyYWdlSW5kZXgoaC5jb3ZlcmFnZSxyW3RdKSkpaWYoMT09YS5sdHlwZSlyW3RdLDE9PWguZm10P3JbdF09clt0XStoLmRlbHRhOnJbdF09aC5uZXdnW2ldO2Vsc2UgaWYoND09YS5sdHlwZSlmb3IodmFyIGY9aC52YWxzW2ldLGQ9MDtkPGYubGVuZ3RoO2QrKyl7dmFyIHU9ZltkXSxsPXUuY2hhaW4ubGVuZ3RoO2lmKCEobD5vKSl7Zm9yKHZhciB2PSEwLGM9MCxwPTA7cDxsO3ArKyl7Zm9yKDstMT09clt0K2MrKDErcCldOyljKys7dS5jaGFpbltwXSE9clt0K2MrKDErcCldJiYodj0hMSk7fWlmKHYpe3JbdF09dS5uZ2x5cGg7Zm9yKHA9MDtwPGwrYztwKyspclt0K3ArMV09LTE7YnJlYWt9fX1lbHNlIGlmKDU9PWEubHR5cGUmJjI9PWguZm10KWZvcih2YXIgVT1lLl9sY3RmLmdldEludGVydmFsKGguY0RlZixyW3RdKSxnPWguY0RlZltVKzJdLFM9aC5zY3NldFtnXSxtPTA7bTxTLmxlbmd0aDttKyspe3ZhciBiPVNbbV0seT1iLmlucHV0O2lmKCEoeS5sZW5ndGg+bykpe2Zvcih2PSEwLHA9MDtwPHkubGVuZ3RoO3ArKyl7dmFyIEY9ZS5fbGN0Zi5nZXRJbnRlcnZhbChoLmNEZWYsclt0KzErcF0pO2lmKC0xPT1VJiZoLmNEZWZbRisyXSE9eVtwXSl7dj0hMTticmVha319aWYodil7dmFyIF89Yi5zdWJzdExvb2t1cFJlY29yZHM7Zm9yKGQ9MDtkPF8ubGVuZ3RoO2QrPTIpX1tkXSxfW2QrMV07fX19ZWxzZSBpZig2PT1hLmx0eXBlJiYzPT1oLmZtdCl7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguYmFja0N2Zyx0LWguYmFja0N2Zy5sZW5ndGgpKWNvbnRpbnVlO2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmlucHRDdmcsdCkpY29udGludWU7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguYWhlZEN2Zyx0K2guaW5wdEN2Zy5sZW5ndGgpKWNvbnRpbnVlO3ZhciBDPWgubG9va3VwUmVjO2ZvcihtPTA7bTxDLmxlbmd0aDttKz0yKXtVPUNbbV07dmFyIHg9bltDW20rMV1dO2UuVS5fYXBwbHlTdWJzKHIsdCtVLHgsbik7fX19fSxlLlUuX2dsc0NvdmVyZWQ9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXtpZigtMT09ZS5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRbbl0sclthK25dKSlyZXR1cm4gITF9cmV0dXJuICEwfSxlLlUuZ2x5cGhzVG9QYXRoPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49e2NtZHM6W10sY3JkczpbXX0sbz0wLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIGk9dFtzXTtpZigtMSE9aSl7Zm9yKHZhciBoPXM8dC5sZW5ndGgtMSYmLTEhPXRbcysxXT90W3MrMV06MCxmPWUuVS5nbHlwaFRvUGF0aChyLGkpLGQ9MDtkPGYuY3Jkcy5sZW5ndGg7ZCs9MiluLmNyZHMucHVzaChmLmNyZHNbZF0rbyksbi5jcmRzLnB1c2goZi5jcmRzW2QrMV0pO2EmJm4uY21kcy5wdXNoKGEpO2ZvcihkPTA7ZDxmLmNtZHMubGVuZ3RoO2QrKyluLmNtZHMucHVzaChmLmNtZHNbZF0pO2EmJm4uY21kcy5wdXNoKFwiWFwiKSxvKz1yLmhtdHguYVdpZHRoW2ldLHM8dC5sZW5ndGgtMSYmKG8rPWUuVS5nZXRQYWlyQWRqdXN0bWVudChyLGksaCkpO319cmV0dXJuIG59LGUuVS5QPXt9LGUuVS5QLm1vdmVUbz1mdW5jdGlvbihyLGUsdCl7ci5jbWRzLnB1c2goXCJNXCIpLHIuY3Jkcy5wdXNoKGUsdCk7fSxlLlUuUC5saW5lVG89ZnVuY3Rpb24ocixlLHQpe3IuY21kcy5wdXNoKFwiTFwiKSxyLmNyZHMucHVzaChlLHQpO30sZS5VLlAuY3VydmVUbz1mdW5jdGlvbihyLGUsdCxhLG4sbyxzKXtyLmNtZHMucHVzaChcIkNcIiksci5jcmRzLnB1c2goZSx0LGEsbixvLHMpO30sZS5VLlAucWN1cnZlVG89ZnVuY3Rpb24ocixlLHQsYSxuKXtyLmNtZHMucHVzaChcIlFcIiksci5jcmRzLnB1c2goZSx0LGEsbik7fSxlLlUuUC5jbG9zZVBhdGg9ZnVuY3Rpb24ocil7ci5jbWRzLnB1c2goXCJaXCIpO30sZS5VLl9kcmF3Q0ZGPWZ1bmN0aW9uKHIsdCxhLG4sbyl7Zm9yKHZhciBzPXQuc3RhY2ssaT10Lm5TdGVtcyxoPXQuaGF2ZVdpZHRoLGY9dC53aWR0aCxkPXQub3Blbix1PTAsbD10Lngsdj10LnksYz0wLHA9MCxVPTAsZz0wLFM9MCxtPTAsYj0wLHk9MCxGPTAsXz0wLEM9e3ZhbDowLHNpemU6MH07dTxyLmxlbmd0aDspe2UuQ0ZGLmdldENoYXJTdHJpbmcocix1LEMpO3ZhciB4PUMudmFsO2lmKHUrPUMuc2l6ZSxcIm8xXCI9PXh8fFwibzE4XCI9PXgpcy5sZW5ndGglMiE9MCYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMDtlbHNlIGlmKFwibzNcIj09eHx8XCJvMjNcIj09eCl7cy5sZW5ndGglMiE9MCYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMDt9ZWxzZSBpZihcIm80XCI9PXgpcy5sZW5ndGg+MSYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksZCYmZS5VLlAuY2xvc2VQYXRoKG8pLHYrPXMucG9wKCksZS5VLlAubW92ZVRvKG8sbCx2KSxkPSEwO2Vsc2UgaWYoXCJvNVwiPT14KWZvcig7cy5sZW5ndGg+MDspbCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpO2Vsc2UgaWYoXCJvNlwiPT14fHxcIm83XCI9PXgpZm9yKHZhciBQPXMubGVuZ3RoLEk9XCJvNlwiPT14LHc9MDt3PFA7dysrKXt2YXIgTz1zLnNoaWZ0KCk7ST9sKz1POnYrPU8sST0hSSxlLlUuUC5saW5lVG8obyxsLHYpO31lbHNlIGlmKFwibzhcIj09eHx8XCJvMjRcIj09eCl7UD1zLmxlbmd0aDtmb3IodmFyIFQ9MDtUKzY8PVA7KWM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdiksVCs9NjtcIm8yNFwiPT14JiYobCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpKTt9ZWxzZSB7aWYoXCJvMTFcIj09eClicmVhaztpZihcIm8xMjM0XCI9PXh8fFwibzEyMzVcIj09eHx8XCJvMTIzNlwiPT14fHxcIm8xMjM3XCI9PXgpXCJvMTIzNFwiPT14JiYocD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxfPWc9cCtzLnNoaWZ0KCksbT1nLHk9dixsPShiPShTPShGPVUrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsXyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzNVwiPT14JiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxGPVUrcy5zaGlmdCgpLF89ZytzLnNoaWZ0KCksUz1GK3Muc2hpZnQoKSxtPV8rcy5zaGlmdCgpLGI9UytzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxsPWIrcy5zaGlmdCgpLHY9eStzLnNoaWZ0KCkscy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsXyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzNlwiPT14JiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksXz1nPXArcy5zaGlmdCgpLG09ZyxiPShTPShGPVUrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLGw9YitzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixfKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM3XCI9PXgmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLEY9VStzLnNoaWZ0KCksXz1nK3Muc2hpZnQoKSxTPUYrcy5zaGlmdCgpLG09XytzLnNoaWZ0KCksYj1TK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLE1hdGguYWJzKGItbCk+TWF0aC5hYnMoeS12KT9sPWIrcy5zaGlmdCgpOnY9eStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixfKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKTtlbHNlIGlmKFwibzE0XCI9PXgpe2lmKHMubGVuZ3RoPjAmJiFoJiYoZj1zLnNoaWZ0KCkrYS5ub21pbmFsV2lkdGhYLGg9ITApLDQ9PXMubGVuZ3RoKXt2YXIgaz1zLnNoaWZ0KCksRz1zLnNoaWZ0KCksRD1zLnNoaWZ0KCksQj1zLnNoaWZ0KCksTD1lLkNGRi5nbHlwaEJ5U0UoYSxEKSxSPWUuQ0ZGLmdseXBoQnlTRShhLEIpO2UuVS5fZHJhd0NGRihhLkNoYXJTdHJpbmdzW0xdLHQsYSxuLG8pLHQueD1rLHQueT1HLGUuVS5fZHJhd0NGRihhLkNoYXJTdHJpbmdzW1JdLHQsYSxuLG8pO31kJiYoZS5VLlAuY2xvc2VQYXRoKG8pLGQ9ITEpO31lbHNlIGlmKFwibzE5XCI9PXh8fFwibzIwXCI9PXgpe3MubGVuZ3RoJTIhPTAmJiFoJiYoZj1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITAsdSs9aSs3Pj4zO31lbHNlIGlmKFwibzIxXCI9PXgpcy5sZW5ndGg+MiYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksdis9cy5wb3AoKSxsKz1zLnBvcCgpLGQmJmUuVS5QLmNsb3NlUGF0aChvKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGQ9ITA7ZWxzZSBpZihcIm8yMlwiPT14KXMubGVuZ3RoPjEmJiFoJiYoZj1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLGwrPXMucG9wKCksZCYmZS5VLlAuY2xvc2VQYXRoKG8pLGUuVS5QLm1vdmVUbyhvLGwsdiksZD0hMDtlbHNlIGlmKFwibzI1XCI9PXgpe2Zvcig7cy5sZW5ndGg+NjspbCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpO2M9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7fWVsc2UgaWYoXCJvMjZcIj09eClmb3Iocy5sZW5ndGglMiYmKGwrPXMuc2hpZnQoKSk7cy5sZW5ndGg+MDspYz1sLHA9ditzLnNoaWZ0KCksbD1VPWMrcy5zaGlmdCgpLHY9KGc9cCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO2Vsc2UgaWYoXCJvMjdcIj09eClmb3Iocy5sZW5ndGglMiYmKHYrPXMuc2hpZnQoKSk7cy5sZW5ndGg+MDspcD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7ZWxzZSBpZihcIm8xMFwiPT14fHxcIm8yOVwiPT14KXt2YXIgQT1cIm8xMFwiPT14P246YTtpZigwPT1zLmxlbmd0aCljb25zb2xlLmRlYnVnKFwiZXJyb3I6IGVtcHR5IHN0YWNrXCIpO2Vsc2Uge3ZhciBXPXMucG9wKCksTT1BLlN1YnJzW1crQS5CaWFzXTt0Lng9bCx0Lnk9dix0Lm5TdGVtcz1pLHQuaGF2ZVdpZHRoPWgsdC53aWR0aD1mLHQub3Blbj1kLGUuVS5fZHJhd0NGRihNLHQsYSxuLG8pLGw9dC54LHY9dC55LGk9dC5uU3RlbXMsaD10LmhhdmVXaWR0aCxmPXQud2lkdGgsZD10Lm9wZW47fX1lbHNlIGlmKFwibzMwXCI9PXh8fFwibzMxXCI9PXgpe3ZhciBWPXMubGVuZ3RoLE49KFQ9MCxcIm8zMVwiPT14KTtmb3IoVCs9Vi0oUD0tMyZWKTtUPFA7KU4/KHA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksdj0oZz1wK3Muc2hpZnQoKSkrcy5zaGlmdCgpLFAtVD09NT8obD1VK3Muc2hpZnQoKSxUKyspOmw9VSxOPSExKTooYz1sLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksUC1UPT01Pyh2PWcrcy5zaGlmdCgpLFQrKyk6dj1nLE49ITApLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdiksVCs9NDt9ZWxzZSB7aWYoXCJvXCI9PSh4K1wiXCIpLmNoYXJBdCgwKSl0aHJvdyBjb25zb2xlLmRlYnVnKFwiVW5rbm93biBvcGVyYXRpb246IFwiK3gscikseDtzLnB1c2goeCk7fX19dC54PWwsdC55PXYsdC5uU3RlbXM9aSx0LmhhdmVXaWR0aD1oLHQud2lkdGg9Zix0Lm9wZW49ZDt9O3ZhciB0PWUsYT17VHlwcjp0fTtyZXR1cm4gci5UeXByPXQsci5kZWZhdWx0PWEsT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscn0oe30pLlR5cHJ9XG5cbiAgLyohXG4gIEN1c3RvbSBidW5kbGUgb2Ygd29mZjJvdGYgKGh0dHBzOi8vZ2l0aHViLmNvbS9hcnR5LW5hbWUvd29mZjJvdGYpIHdpdGggZmZsYXRlXG4gIChodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZSkgZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuIFxuICBPcmlnaW5hbCBsaWNlbnNlcyBhcHBseTogXG4gIC0gZmZsYXRlOiBodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZS9ibG9iL21hc3Rlci9MSUNFTlNFIChNSVQpXG4gIC0gd29mZjJvdGYuanM6IGh0dHBzOi8vZ2l0aHViLmNvbS9hcnR5LW5hbWUvd29mZjJvdGYvYmxvYi9tYXN0ZXIvd29mZjJvdGYuanMgKEFwYWNoZTIpXG4gICovXG4gIGZ1bmN0aW9uIHdvZmYyb3RmRmFjdG9yeSgpe3JldHVybiBmdW5jdGlvbihyKXt2YXIgZT1VaW50OEFycmF5LG49VWludDE2QXJyYXksdD1VaW50MzJBcnJheSxhPW5ldyBlKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxpPW5ldyBlKFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzLDAsMF0pLG89bmV3IGUoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxmPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciBhPW5ldyBuKDMxKSxpPTA7aTwzMTsrK2kpYVtpXT1lKz0xPDxyW2ktMV07dmFyIG89bmV3IHQoYVszMF0pO2ZvcihpPTE7aTwzMDsrK2kpZm9yKHZhciBmPWFbaV07ZjxhW2krMV07KytmKW9bZl09Zi1hW2ldPDw1fGk7cmV0dXJuIFthLG9dfSx1PWYoYSwyKSx2PXVbMF0scz11WzFdO3ZbMjhdPTI1OCxzWzI1OF09Mjg7Zm9yKHZhciBsPWYoaSwwKVswXSxjPW5ldyBuKDMyNzY4KSxnPTA7ZzwzMjc2ODsrK2cpe3ZhciBoPSg0MzY5MCZnKT4+PjF8KDIxODQ1JmcpPDwxO2g9KDYxNjgwJihoPSg1MjQyOCZoKT4+PjJ8KDEzMTA3JmgpPDwyKSk+Pj40fCgzODU1JmgpPDw0LGNbZ109KCg2NTI4MCZoKT4+Pjh8KDI1NSZoKTw8OCk+Pj4xO312YXIgdz1mdW5jdGlvbihyLGUsdCl7Zm9yKHZhciBhPXIubGVuZ3RoLGk9MCxvPW5ldyBuKGUpO2k8YTsrK2kpKytvW3JbaV0tMV07dmFyIGYsdT1uZXcgbihlKTtmb3IoaT0wO2k8ZTsrK2kpdVtpXT11W2ktMV0rb1tpLTFdPDwxO2lmKHQpe2Y9bmV3IG4oMTw8ZSk7dmFyIHY9MTUtZTtmb3IoaT0wO2k8YTsrK2kpaWYocltpXSlmb3IodmFyIHM9aTw8NHxyW2ldLGw9ZS1yW2ldLGc9dVtyW2ldLTFdKys8PGwsaD1nfCgxPDxsKS0xO2c8PWg7KytnKWZbY1tnXT4+PnZdPXM7fWVsc2UgZm9yKGY9bmV3IG4oYSksaT0wO2k8YTsrK2kpcltpXSYmKGZbaV09Y1t1W3JbaV0tMV0rK10+Pj4xNS1yW2ldKTtyZXR1cm4gZn0sZD1uZXcgZSgyODgpO2ZvcihnPTA7ZzwxNDQ7KytnKWRbZ109ODtmb3IoZz0xNDQ7ZzwyNTY7KytnKWRbZ109OTtmb3IoZz0yNTY7ZzwyODA7KytnKWRbZ109Nztmb3IoZz0yODA7ZzwyODg7KytnKWRbZ109ODt2YXIgbT1uZXcgZSgzMik7Zm9yKGc9MDtnPDMyOysrZyltW2ddPTU7dmFyIGI9dyhkLDksMSkscD13KG0sNSwxKSx5PWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT1yWzBdLG49MTtuPHIubGVuZ3RoOysrbilyW25dPmUmJihlPXJbbl0pO3JldHVybiBlfSxMPWZ1bmN0aW9uKHIsZSxuKXt2YXIgdD1lLzh8MDtyZXR1cm4gKHJbdF18clt0KzFdPDw4KT4+KDcmZSkmbn0sVT1mdW5jdGlvbihyLGUpe3ZhciBuPWUvOHwwO3JldHVybiAocltuXXxyW24rMV08PDh8cltuKzJdPDwxNik+Pig3JmUpfSxrPVtcInVuZXhwZWN0ZWQgRU9GXCIsXCJpbnZhbGlkIGJsb2NrIHR5cGVcIixcImludmFsaWQgbGVuZ3RoL2xpdGVyYWxcIixcImludmFsaWQgZGlzdGFuY2VcIixcInN0cmVhbSBmaW5pc2hlZFwiLFwibm8gc3RyZWFtIGhhbmRsZXJcIiwsXCJubyBjYWxsYmFja1wiLFwiaW52YWxpZCBVVEYtOCBkYXRhXCIsXCJleHRyYSBmaWVsZCB0b28gbG9uZ1wiLFwiZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5XCIsXCJmaWxlbmFtZSB0b28gbG9uZ1wiLFwic3RyZWFtIGZpbmlzaGluZ1wiLFwiaW52YWxpZCB6aXAgZGF0YVwiXSxUPWZ1bmN0aW9uKHIsZSxuKXt2YXIgdD1uZXcgRXJyb3IoZXx8a1tyXSk7aWYodC5jb2RlPXIsRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHQsVCksIW4pdGhyb3cgdDtyZXR1cm4gdH0sTz1mdW5jdGlvbihyLGYsdSl7dmFyIHM9ci5sZW5ndGg7aWYoIXN8fHUmJiF1LmwmJnM8NSlyZXR1cm4gZnx8bmV3IGUoMCk7dmFyIGM9IWZ8fHUsZz0hdXx8dS5pO3V8fCh1PXt9KSxmfHwoZj1uZXcgZSgzKnMpKTt2YXIgaCxkPWZ1bmN0aW9uKHIpe3ZhciBuPWYubGVuZ3RoO2lmKHI+bil7dmFyIHQ9bmV3IGUoTWF0aC5tYXgoMipuLHIpKTt0LnNldChmKSxmPXQ7fX0sbT11LmZ8fDAsaz11LnB8fDAsTz11LmJ8fDAsQT11LmwseD11LmQsRT11Lm0sRD11Lm4sTT04KnM7ZG97aWYoIUEpe3UuZj1tPUwocixrLDEpO3ZhciBTPUwocixrKzEsMyk7aWYoays9MywhUyl7dmFyIFY9clsoST0oKGg9aykvOHwwKSsoNyZoJiYxKSs0KS00XXxyW0ktM108PDgsXz1JK1Y7aWYoXz5zKXtnJiZUKDApO2JyZWFrfWMmJmQoTytWKSxmLnNldChyLnN1YmFycmF5KEksXyksTyksdS5iPU8rPVYsdS5wPWs9OCpfO2NvbnRpbnVlfWlmKDE9PVMpQT1iLHg9cCxFPTksRD01O2Vsc2UgaWYoMj09Uyl7dmFyIGo9TChyLGssMzEpKzI1Nyx6PUwocixrKzEwLDE1KSs0LEM9aitMKHIsays1LDMxKSsxO2srPTE0O2Zvcih2YXIgRj1uZXcgZShDKSxQPW5ldyBlKDE5KSxxPTA7cTx6OysrcSlQW29bcV1dPUwocixrKzMqcSw3KTtrKz0zKno7dmFyIEI9eShQKSxHPSgxPDxCKS0xLEg9dyhQLEIsMSk7Zm9yKHE9MDtxPEM7KXt2YXIgSSxKPUhbTChyLGssRyldO2lmKGsrPTE1JkosKEk9Sj4+PjQpPDE2KUZbcSsrXT1JO2Vsc2Uge3ZhciBLPTAsTj0wO2ZvcigxNj09ST8oTj0zK0wocixrLDMpLGsrPTIsSz1GW3EtMV0pOjE3PT1JPyhOPTMrTChyLGssNyksays9Myk6MTg9PUkmJihOPTExK0wocixrLDEyNyksays9Nyk7Ti0tOylGW3ErK109Szt9fXZhciBRPUYuc3ViYXJyYXkoMCxqKSxSPUYuc3ViYXJyYXkoaik7RT15KFEpLEQ9eShSKSxBPXcoUSxFLDEpLHg9dyhSLEQsMSk7fWVsc2UgVCgxKTtpZihrPk0pe2cmJlQoMCk7YnJlYWt9fWMmJmQoTysxMzEwNzIpO2Zvcih2YXIgVz0oMTw8RSktMSxYPSgxPDxEKS0xLFk9azs7WT1rKXt2YXIgWj0oSz1BW1UocixrKSZXXSk+Pj40O2lmKChrKz0xNSZLKT5NKXtnJiZUKDApO2JyZWFrfWlmKEt8fFQoMiksWjwyNTYpZltPKytdPVo7ZWxzZSB7aWYoMjU2PT1aKXtZPWssQT1udWxsO2JyZWFrfXZhciAkPVotMjU0O2lmKFo+MjY0KXt2YXIgcnI9YVtxPVotMjU3XTskPUwocixrLCgxPDxyciktMSkrdltxXSxrKz1ycjt9dmFyIGVyPXhbVShyLGspJlhdLG5yPWVyPj4+NDtlcnx8VCgzKSxrKz0xNSZlcjtSPWxbbnJdO2lmKG5yPjMpe3JyPWlbbnJdO1IrPVUocixrKSYoMTw8cnIpLTEsays9cnI7fWlmKGs+TSl7ZyYmVCgwKTticmVha31jJiZkKE8rMTMxMDcyKTtmb3IodmFyIHRyPU8rJDtPPHRyO08rPTQpZltPXT1mW08tUl0sZltPKzFdPWZbTysxLVJdLGZbTysyXT1mW08rMi1SXSxmW08rM109ZltPKzMtUl07Tz10cjt9fXUubD1BLHUucD1ZLHUuYj1PLEEmJihtPTEsdS5tPUUsdS5kPXgsdS5uPUQpO313aGlsZSghbSk7cmV0dXJuIE89PWYubGVuZ3RoP2Y6ZnVuY3Rpb24ocixhLGkpeyhudWxsPT1hfHxhPDApJiYoYT0wKSwobnVsbD09aXx8aT5yLmxlbmd0aCkmJihpPXIubGVuZ3RoKTt2YXIgbz1uZXcociBpbnN0YW5jZW9mIG4/bjpyIGluc3RhbmNlb2YgdD90OmUpKGktYSk7cmV0dXJuIG8uc2V0KHIuc3ViYXJyYXkoYSxpKSksb30oZiwwLE8pfSxBPW5ldyBlKDApO3ZhciB4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyO3RyeXt4LmRlY29kZShBLHtzdHJlYW06ITB9KSwxO31jYXRjaChyKXt9cmV0dXJuIHIuY29udmVydF9zdHJlYW1zPWZ1bmN0aW9uKHIpe3ZhciBlPW5ldyBEYXRhVmlldyhyKSxuPTA7ZnVuY3Rpb24gdCgpe3ZhciByPWUuZ2V0VWludDE2KG4pO3JldHVybiBuKz0yLHJ9ZnVuY3Rpb24gYSgpe3ZhciByPWUuZ2V0VWludDMyKG4pO3JldHVybiBuKz00LHJ9ZnVuY3Rpb24gaShyKXttLnNldFVpbnQxNihiLHIpLGIrPTI7fWZ1bmN0aW9uIG8ocil7bS5zZXRVaW50MzIoYixyKSxiKz00O31mb3IodmFyIGY9e3NpZ25hdHVyZTphKCksZmxhdm9yOmEoKSxsZW5ndGg6YSgpLG51bVRhYmxlczp0KCkscmVzZXJ2ZWQ6dCgpLHRvdGFsU2ZudFNpemU6YSgpLG1ham9yVmVyc2lvbjp0KCksbWlub3JWZXJzaW9uOnQoKSxtZXRhT2Zmc2V0OmEoKSxtZXRhTGVuZ3RoOmEoKSxtZXRhT3JpZ0xlbmd0aDphKCkscHJpdk9mZnNldDphKCkscHJpdkxlbmd0aDphKCl9LHU9MDtNYXRoLnBvdygyLHUpPD1mLm51bVRhYmxlczspdSsrO3UtLTtmb3IodmFyIHY9MTYqTWF0aC5wb3coMix1KSxzPTE2KmYubnVtVGFibGVzLXYsbD0xMixjPVtdLGc9MDtnPGYubnVtVGFibGVzO2crKyljLnB1c2goe3RhZzphKCksb2Zmc2V0OmEoKSxjb21wTGVuZ3RoOmEoKSxvcmlnTGVuZ3RoOmEoKSxvcmlnQ2hlY2tzdW06YSgpfSksbCs9MTY7dmFyIGgsdz1uZXcgVWludDhBcnJheSgxMisxNipjLmxlbmd0aCtjLnJlZHVjZSgoZnVuY3Rpb24ocixlKXtyZXR1cm4gcitlLm9yaWdMZW5ndGgrNH0pLDApKSxkPXcuYnVmZmVyLG09bmV3IERhdGFWaWV3KGQpLGI9MDtyZXR1cm4gbyhmLmZsYXZvciksaShmLm51bVRhYmxlcyksaSh2KSxpKHUpLGkocyksYy5mb3JFYWNoKChmdW5jdGlvbihyKXtvKHIudGFnKSxvKHIub3JpZ0NoZWNrc3VtKSxvKGwpLG8oci5vcmlnTGVuZ3RoKSxyLm91dE9mZnNldD1sLChsKz1yLm9yaWdMZW5ndGgpJTQhPTAmJihsKz00LWwlNCk7fSkpLGMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG4sdD1yLnNsaWNlKGUub2Zmc2V0LGUub2Zmc2V0K2UuY29tcExlbmd0aCk7aWYoZS5jb21wTGVuZ3RoIT1lLm9yaWdMZW5ndGgpe3ZhciBhPW5ldyBVaW50OEFycmF5KGUub3JpZ0xlbmd0aCk7bj1uZXcgVWludDhBcnJheSh0LDIpLE8obixhKTt9ZWxzZSBhPW5ldyBVaW50OEFycmF5KHQpO3cuc2V0KGEsZS5vdXRPZmZzZXQpO3ZhciBpPTA7KGw9ZS5vdXRPZmZzZXQrZS5vcmlnTGVuZ3RoKSU0IT0wJiYoaT00LWwlNCksdy5zZXQobmV3IFVpbnQ4QXJyYXkoaSkuYnVmZmVyLGUub3V0T2Zmc2V0K2Uub3JpZ0xlbmd0aCksaD1sK2k7fSkpLGQuc2xpY2UoMCxoKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscn0oe30pLmNvbnZlcnRfc3RyZWFtc31cblxuICAvKipcbiAgICogQSBmYWN0b3J5IHdyYXBwZXIgcGFyc2luZyBhIGZvbnQgZmlsZSB1c2luZyBUeXByLlxuICAgKiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgV09GRiBmaWxlcyAobm90IFdPRkYyKS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90Zikge1xuICAgIGNvbnN0IGNtZEFyZ0xlbmd0aHMgPSB7XG4gICAgICBNOiAyLFxuICAgICAgTDogMixcbiAgICAgIFE6IDQsXG4gICAgICBDOiA2LFxuICAgICAgWjogMFxuICAgIH07XG5cbiAgICAvLyB7am9pblR5cGU6IFwic2tpcCtzdGVwLC4uLlwifVxuICAgIGNvbnN0IGpvaW5pbmdUeXBlUmF3RGF0YSA9IHtcIkNcIjpcIjE4ZyxjYSwzNjgsMWt6XCIsXCJEXCI6XCIxN2ssNiwyLDIrNCw1K2MsMis2LDIrMSwxMCsxLDkrZixqKzExLDIrMSxhLDIsMisxLDE1KzIsMyxqKzIsNiszLDIrOCwyLDIsMisxLHcrYSw0K2UsMyszLDIsMysyLDMrNSwyMyt3LDJmKzQsMywyKzksMixiLDIrMywzLDFrKzksNisxLDMrMSwyKzIsMitkLDMwZyxwK3ksMSwxKzFnLGYreCwyLHNkMisxZCxqZjMrNCxmKzMsMis0LDIrMixiKzMsNDIsMiw0KzIsMisxLDIsMyx0KzEsOWYrdywyLGVsKzIsMitnLGQrMiwybCwyKzEsNSwzKzEsMisxLDIsMyw2LDE2d20rMXZcIixcIlJcIjpcIjE3bSszLDIsMiw2KzMsbSwxNSsyLDIrMixoK2gsMTMsMys4LDIsMiwzKzEsMixwKzEseCw1KzQsNSxhLDIsMiwzLHUsYysyLGcrMSw1LDIrMSw0KzEsNWosNisxLDIsYiwyKzIsZiwyKzEsMXMrMiwyLDMrMSw3LDFlejAsMiwyKzEsNCs0LGIsNCwzLGIsNDIsMisyLDQsMywyKzEsMixvKzMsYWUsZXAseCwybysyLDMrMSwzLDUrMSw2XCIsXCJMXCI6XCJ4OXUsamZmLGEsZmQsanZcIixcIlRcIjpcIjR0LGdqKzMzLDdvKzQsMSsxLDdjKzE4LDIsMisxLDIrMSwyLDIxK2EsMiwxYitrLGgsMnUrNiwzKzUsMysxLDIrMyx5LDIsditxLDJrK2EsMW4rOCxhLHArMywyKzgsMisyLDIrNCwxOCsyLDNjK2UsMit2LDFrLDIsNSs3LDUsNCs2LGIrMSx1LDFuLDUrMyw5LGwrMSxyLDMrMSwxbSw1KzEsNSsxLDMrMiw0LHYrMSw0LGMrMSwxbSw1KzQsMisxLDUsbCsxLG4rNSwyLDFuLDMsMiszLDksOCsxLGMrMSx2LDFxLGQsMWYsNCwxbSsyLDYrMiwyKzMsOCsxLGMrMSx1LDFuLDMsNyw2KzEsbCsxLHQrMSwxbSsxLDUrMyw5LGwrMSx1LDIxLDgrMiwyLDJqLDMrNixkKzcsMnIsMys4LGMrNSwyMysxLHMsMiwyLDFrK2QsMis0LDIrMSw2K2EsMit6LGEsMnYrMywyKzUsMisxLDMrMSxxKzEsNSsyLGgrMyxlLDMrMSw3LGcsamsrMixxYisyLHUrMix1KzEsdisxLDF0KzEsMis2LDksMythLGEsMWErMiwzYysxLHosM2IrMiw1KzEsYSw3KzIsNjQrMSwzLDFuLDIrNiwyLDIsMys3LDcrOSwzLDFkK2QsMSwxKzEsMXMrMywxZCwyKzQsMiw2LDE1KzgsZCsxLHgrMywzKzEsMisyLDFsLDIrMSw0LDIrMiwxbis3LDMrMSw0OSsyLDIrYywyKzYsNSw3LDQrMSw1aisxbCwyKzQsZWssMysxLHIrNCwxZSs0LDYrNSwycCtjLDErMywxLDErMiwxK2IsMmRiKzIsM3ksMnArdixmZiszLDMwKzEsbjl4LDErMiwyKzkseCsxLDI5KzEsN2wsNCw1LHErMSw2LDQ4KzEscitoLGUsMTMrNyxxK2EsMWIrMiwxZCwzKzMsMysxLDE0LDF3KzUsMysxLDMrMSxkLDksMWMsMWcsMisyLDMrMSw2KzEsMiwxNysxLDksNm4sMyw1LGZuNSxraStmLGgrZiw1cyw2eSsyLGVhLDZiLDQ2KzQsMWFmKzIsMisxLDYrMywxNSsyLDUsNG0rMSxmeSszLGFzKzEsNGErYSw0eCwxaitlLDFsKzIsMWUrMywzKzEsMXkrMiwxMSs0LDIrNywxcixkKzEsMWgrOCxiKzMsMywybysyLDMsMisxLDcsNGgsNCs3LG0rMSwxbSsxLDQsMTIrNiw0KzQsNWcrNywzKzIsMixvLDJkKzUsMiw1KzEsMisxLDZuKzMsNysxLDIrMSxzKzEsMmUrNywzLDIrMSwyeiwyLDMrNSwyLDJ1KzIsMyszLDIrNCw3OCs4LDIrMSw3NSsxLDIsNSw0MSszLDMrMSw1LHgrOSwxNSs1LDMrMyw5LGErNSwzKzIsMWIrYywyKzEsYmIrNiwyKzUsMiwyYitsLDMrNiwyKzEsMisxLDNmKzUsNCwyKzEsMis2LDIsMjErMSw0LDIsOW8rMSw0NzArOCxhdDQrNCwxbys2LHQ1LDFzKzMsMmEsZjVsKzEsMiszLDQzbysyLGErNywxKzcsMys2LHYrMyw0NSsyLDFqMCsxaSw1KzFkLDksZixuKzQsMitlLDExdCs2LDIrZywzKzYsMisxLDIrNCw3YSs2LGM2KzMsMTV0KzYsMzIrNiwxLGd6YXUsdisybiwzbCs2blwifTtcblxuICAgIGNvbnN0IEpUX0xFRlQgPSAxLCAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGpvaW5zIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLCBidXQgZG9lcyBub3Qgam9pbiB3aXRoIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyLlxuICAgICAgSlRfUklHSFQgPSAyLCAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGpvaW5zIHdpdGggdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIsIGJ1dCBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLlxuICAgICAgSlRfRFVBTCA9IDQsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBhbmQgam9pbnMgd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgICBKVF9UUkFOU1BBUkVOVCA9IDgsIC8vaW5kaWNhdGVzIHRoYXQgdGhlIGNoYXJhY3RlciBkb2VzIG5vdCBqb2luIHdpdGggYWRqYWNlbnQgY2hhcmFjdGVycyBhbmQgdGhhdCB0aGUgY2hhcmFjdGVyIG11c3QgYmUgc2tpcHBlZCBvdmVyIHdoZW4gdGhlIHNoYXBpbmcgZW5naW5lIGlzIGV2YWx1YXRpbmcgdGhlIGpvaW5pbmcgcG9zaXRpb25zIGluIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy4gV2hlbiBhIEpUX1RSQU5TUEFSRU5UIGNoYXJhY3RlciBpcyBlbmNvdW50ZXJlZCBpbiBhIHNlcXVlbmNlLCB0aGUgSk9JTklOR19UWVBFIG9mIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyIHBhc3NlcyB0aHJvdWdoLiBEaWFjcml0aWNhbCBtYXJrcyBhcmUgZnJlcXVlbnRseSBhc3NpZ25lZCB0aGlzIHZhbHVlLlxuICAgICAgSlRfSk9JTl9DQVVTSU5HID0gMTYsIC8vaW5kaWNhdGVzIHRoYXQgdGhlIGNoYXJhY3RlciBmb3JjZXMgdGhlIHVzZSBvZiBqb2luaW5nIGZvcm1zIHdpdGggdGhlIHByZWNlZGluZyBhbmQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzLiBLYXNoaWRhcyBhbmQgdGhlIFplcm8gV2lkdGggSm9pbmVyIChVKzIwMEQpIGFyZSBib3RoIEpPSU5fQ0FVU0lORyBjaGFyYWN0ZXJzLlxuICAgICAgSlRfTk9OX0pPSU5JTkcgPSAzMjsgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHByZWNlZGluZyBvciB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3Rlci4sXG5cbiAgICBsZXQgam9pbmluZ1R5cGVNYXA7XG4gICAgZnVuY3Rpb24gZ2V0Q2hhckpvaW5pbmdUeXBlKGNoKSB7XG4gICAgICBpZiAoIWpvaW5pbmdUeXBlTWFwKSB7XG4gICAgICAgIGNvbnN0IG0gPSB7XG4gICAgICAgICAgUjogSlRfUklHSFQsXG4gICAgICAgICAgTDogSlRfTEVGVCxcbiAgICAgICAgICBEOiBKVF9EVUFMLFxuICAgICAgICAgIEM6IEpUX0pPSU5fQ0FVU0lORyxcbiAgICAgICAgICBVOiBKVF9OT05fSk9JTklORyxcbiAgICAgICAgICBUOiBKVF9UUkFOU1BBUkVOVFxuICAgICAgICB9O1xuICAgICAgICBqb2luaW5nVHlwZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBqb2luaW5nVHlwZVJhd0RhdGEpIHtcbiAgICAgICAgICBsZXQgbGFzdENvZGUgPSAwO1xuICAgICAgICAgIGpvaW5pbmdUeXBlUmF3RGF0YVt0eXBlXS5zcGxpdCgnLCcpLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IFtza2lwLCBzdGVwXSA9IHJhbmdlLnNwbGl0KCcrJyk7XG4gICAgICAgICAgICBza2lwID0gcGFyc2VJbnQoc2tpcCwzNik7XG4gICAgICAgICAgICBzdGVwID0gc3RlcCA/IHBhcnNlSW50KHN0ZXAsIDM2KSA6IDA7XG4gICAgICAgICAgICBqb2luaW5nVHlwZU1hcC5zZXQobGFzdENvZGUgKz0gc2tpcCwgbVt0eXBlXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RlcDsgaS0tOykge1xuICAgICAgICAgICAgICBqb2luaW5nVHlwZU1hcC5zZXQoKytsYXN0Q29kZSwgbVt0eXBlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBqb2luaW5nVHlwZU1hcC5nZXQoY2gpIHx8IEpUX05PTl9KT0lOSU5HXG4gICAgfVxuXG4gICAgY29uc3QgSVNPTCA9IDEsIElOSVQgPSAyLCBGSU5BID0gMywgTUVESSA9IDQ7XG4gICAgY29uc3QgZm9ybXNUb0ZlYXR1cmVzID0gW251bGwsICdpc29sJywgJ2luaXQnLCAnZmluYScsICdtZWRpJ107XG5cbiAgICBmdW5jdGlvbiBkZXRlY3RKb2luaW5nRm9ybXMoc3RyKSB7XG4gICAgICAvLyBUaGlzIGltcGxlbWVudHMgdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uOHdpbGxpcy9vcGVudHlwZS1zaGFwaW5nLWRvY3VtZW50cy9ibG9iL21hc3Rlci9vcGVudHlwZS1zaGFwaW5nLWFyYWJpYy1nZW5lcmFsLm1kXG4gICAgICBjb25zdCBqb2luaW5nRm9ybXMgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgIGxldCBwcmV2Sm9pbmluZ1R5cGUgPSBKVF9OT05fSk9JTklORztcbiAgICAgIGxldCBwcmV2Rm9ybSA9IElTT0w7XG4gICAgICBsZXQgcHJldkluZGV4ID0gLTE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgICBsZXQgam9pbmluZ1R5cGUgPSBnZXRDaGFySm9pbmluZ1R5cGUoY29kZSkgfCAwO1xuICAgICAgICBsZXQgZm9ybSA9IElTT0w7XG4gICAgICAgIGlmIChqb2luaW5nVHlwZSAmIEpUX1RSQU5TUEFSRU5UKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkpvaW5pbmdUeXBlICYgKEpUX0xFRlQgfCBKVF9EVUFMIHwgSlRfSk9JTl9DQVVTSU5HKSkge1xuICAgICAgICAgIGlmIChqb2luaW5nVHlwZSAmIChKVF9SSUdIVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgICAgICBmb3JtID0gRklOQTtcbiAgICAgICAgICAgIC8vIGlzb2wtPmluaXQsIGZpbmEtPm1lZGlcbiAgICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSVNPTCB8fCBwcmV2Rm9ybSA9PT0gRklOQSkge1xuICAgICAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChqb2luaW5nVHlwZSAmIChKVF9MRUZUIHwgSlRfTk9OX0pPSU5JTkcpKSB7XG4gICAgICAgICAgICAvLyBtZWRpLT5maW5hLCBpbml0LT5pc29sXG4gICAgICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldkpvaW5pbmdUeXBlICYgKEpUX1JJR0hUIHwgSlRfTk9OX0pPSU5JTkcpKSB7XG4gICAgICAgICAgLy8gbWVkaS0+ZmluYSwgaW5pdC0+aXNvbFxuICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSU5JVCB8fCBwcmV2Rm9ybSA9PT0gTUVESSkge1xuICAgICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0tLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldkZvcm0gPSBqb2luaW5nRm9ybXNbaV0gPSBmb3JtO1xuICAgICAgICBwcmV2Sm9pbmluZ1R5cGUgPSBqb2luaW5nVHlwZTtcbiAgICAgICAgcHJldkluZGV4ID0gaTtcbiAgICAgICAgaWYgKGNvZGUgPiAweGZmZmYpIGkrKztcbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKHN0ci5zcGxpdCgnJykubWFwKGNoID0+IGNoLmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KSkpXG4gICAgICAvLyBjb25zb2xlLmxvZyhzdHIuc3BsaXQoJycpLm1hcChjaCA9PiBnZXRDaGFySm9pbmluZ1R5cGUoY2guY29kZVBvaW50QXQoMCkpKSlcbiAgICAgIC8vIGNvbnNvbGUubG9nKEFycmF5LmZyb20oam9pbmluZ0Zvcm1zKS5tYXAoZiA9PiBmb3Jtc1RvRmVhdHVyZXNbZl0gfHwgJ25vbmUnKSlcbiAgICAgIHJldHVybiBqb2luaW5nRm9ybXNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdUb0dseXBocyAoZm9udCwgc3RyKSB7XG4gICAgICBjb25zdCBnbHlwaElkcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2MgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICAgIGlmIChjYyA+IDB4ZmZmZikgaSsrO1xuICAgICAgICBnbHlwaElkcy5wdXNoKFR5cHIuVS5jb2RlVG9HbHlwaChmb250LCBjYykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBnc3ViID0gZm9udFsnR1NVQiddO1xuICAgICAgaWYgKGdzdWIpIHtcbiAgICAgICAgY29uc3Qge2xvb2t1cExpc3QsIGZlYXR1cmVMaXN0fSA9IGdzdWI7XG4gICAgICAgIGxldCBqb2luaW5nRm9ybXM7XG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEZlYXR1cmVzID0gL14ocmxpZ3xsaWdhfG1zZXR8aXNvbHxpbml0fGZpbmF8bWVkaXxoYWxmfHByZXN8Ymx3cykkLztcbiAgICAgICAgY29uc3QgdXNlZExvb2t1cHMgPSBbXTtcbiAgICAgICAgZmVhdHVyZUxpc3QuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkRmVhdHVyZXMudGVzdChmZWF0dXJlLnRhZykpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRpID0gMDsgdGkgPCBmZWF0dXJlLnRhYi5sZW5ndGg7IHRpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHVzZWRMb29rdXBzW2ZlYXR1cmUudGFiW3RpXV0pIGNvbnRpbnVlXG4gICAgICAgICAgICAgIHVzZWRMb29rdXBzW2ZlYXR1cmUudGFiW3RpXV0gPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCB0YWIgPSBsb29rdXBMaXN0W2ZlYXR1cmUudGFiW3RpXV07XG4gICAgICAgICAgICAgIGNvbnN0IGlzSm9pbmluZ0ZlYXR1cmUgPSAvXihpc29sfGluaXR8ZmluYXxtZWRpKSQvLnRlc3QoZmVhdHVyZS50YWcpO1xuICAgICAgICAgICAgICBpZiAoaXNKb2luaW5nRmVhdHVyZSAmJiAham9pbmluZ0Zvcm1zKSB7IC8vbGF6eVxuICAgICAgICAgICAgICAgIGpvaW5pbmdGb3JtcyA9IGRldGVjdEpvaW5pbmdGb3JtcyhzdHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAobGV0IGNpID0gMDsgY2kgPCBnbHlwaElkcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWpvaW5pbmdGb3JtcyB8fCAhaXNKb2luaW5nRmVhdHVyZSB8fCBmb3Jtc1RvRmVhdHVyZXNbam9pbmluZ0Zvcm1zW2NpXV0gPT09IGZlYXR1cmUudGFnKSB7XG4gICAgICAgICAgICAgICAgICBUeXByLlUuX2FwcGx5U3VicyhnbHlwaElkcywgY2ksIHRhYiwgbG9va3VwTGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdseXBoSWRzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyc3ROdW0oLi4uYXJncykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1tpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcEZvbnRPYmoodHlwckZvbnQpIHtcbiAgICAgIGNvbnN0IGdseXBoTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgY29uc3Qgb3MyID0gdHlwckZvbnRbJ09TLzInXTtcbiAgICAgIGNvbnN0IGhoZWEgPSB0eXByRm9udC5oaGVhO1xuICAgICAgY29uc3QgdW5pdHNQZXJFbSA9IHR5cHJGb250LmhlYWQudW5pdHNQZXJFbTtcbiAgICAgIGNvbnN0IGFzY2VuZGVyID0gZmlyc3ROdW0ob3MyICYmIG9zMi5zVHlwb0FzY2VuZGVyLCBoaGVhICYmIGhoZWEuYXNjZW5kZXIsIHVuaXRzUGVyRW0pO1xuXG4gICAgICBjb25zdCBmb250T2JqID0ge1xuICAgICAgICB1bml0c1BlckVtLFxuICAgICAgICBhc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvRGVzY2VuZGVyLCBoaGVhICYmIGhoZWEuZGVzY2VuZGVyLCAwKSxcbiAgICAgICAgY2FwSGVpZ2h0OiBmaXJzdE51bShvczIgJiYgb3MyLnNDYXBIZWlnaHQsIGFzY2VuZGVyKSxcbiAgICAgICAgeEhlaWdodDogZmlyc3ROdW0ob3MyICYmIG9zMi5zeEhlaWdodCwgYXNjZW5kZXIpLFxuICAgICAgICBsaW5lR2FwOiBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvTGluZUdhcCwgaGhlYSAmJiBoaGVhLmxpbmVHYXApLFxuICAgICAgICBmb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgbGV0IGdseXBoWCA9IDA7XG4gICAgICAgICAgY29uc3QgZm9udFNjYWxlID0gMSAvIGZvbnRPYmoudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgICAgICAgY29uc3QgZ2x5cGhJbmRpY2VzID0gc3RyaW5nVG9HbHlwaHModHlwckZvbnQsIHRleHQpO1xuICAgICAgICAgIGxldCBjaGFySW5kZXggPSAwO1xuICAgICAgICAgIGxldCBwcmV2R2x5cGhJbmRleCA9IC0xO1xuICAgICAgICAgIGdseXBoSW5kaWNlcy5mb3JFYWNoKChnbHlwaEluZGV4LCBpKSA9PiB7XG4gICAgICAgICAgICAvLyBUeXByIHJldHVybnMgYSBnbHlwaCBpbmRleCBwZXIgc3RyaW5nIGNvZGVwb2ludCwgd2l0aCAtMXMgaW4gcGxhY2Ugb2YgdGhvc2UgdGhhdFxuICAgICAgICAgICAgLy8gd2VyZSBvbWl0dGVkIGR1ZSB0byBsaWdhdHVyZSBzdWJzdGl0dXRpb24uIFNvIHdlIGNhbiB0cmFjayBvcmlnaW5hbCBpbmRleCBpbiB0aGVcbiAgICAgICAgICAgIC8vIHN0cmluZyB2aWEgc2ltcGxlIGluY3JlbWVudCwgYW5kIHNraXAgZXZlcnl0aGluZyBlbHNlIHdoZW4gc2VlaW5nIGEgLTEuXG4gICAgICAgICAgICBpZiAoZ2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgbGV0IGdseXBoT2JqID0gZ2x5cGhNYXBbZ2x5cGhJbmRleF07XG4gICAgICAgICAgICAgIGlmICghZ2x5cGhPYmopIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7Y21kcywgY3Jkc30gPSBUeXByLlUuZ2x5cGhUb1BhdGgodHlwckZvbnQsIGdseXBoSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgcGF0aCBzdHJpbmdcbiAgICAgICAgICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCBjcmRzSWR4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY21kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbnVtQXJncyA9IGNtZEFyZ0xlbmd0aHNbY21kc1tpXV07XG4gICAgICAgICAgICAgICAgICBwYXRoICs9IGNtZHNbaV07XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBudW1BcmdzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSAoaiA+IDEgPyAnLCcgOiAnJykgKyBjcmRzW2NyZHNJZHgrK107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmluZCBleHRlbnRzIC0gR2x5ZiBnaXZlcyB0aGlzIGluIG1ldGFkYXRhIGJ1dCBub3QgQ0ZGLCBhbmQgVHlwciBkb2Vzbid0XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIHRoZSB0d28sIHNvIGl0J3Mgc2ltcGxlc3QganVzdCB0byBpdGVyYXRlIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICBsZXQgeE1pbiwgeU1pbiwgeE1heCwgeU1heDtcbiAgICAgICAgICAgICAgICBpZiAoY3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHhNaW4gPSB5TWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICB4TWF4ID0geU1heCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4ID0gY3Jkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSBjcmRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPCB4TWluKSB4TWluID0geDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCB5TWluKSB5TWluID0geTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPiB4TWF4KSB4TWF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPiB5TWF4KSB5TWF4ID0geTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeE1pbiA9IHhNYXggPSB5TWluID0geU1heCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaEluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBnbHlwaEluZGV4LFxuICAgICAgICAgICAgICAgICAgYWR2YW5jZVdpZHRoOiB0eXByRm9udC5obXR4LmFXaWR0aFtnbHlwaEluZGV4XSxcbiAgICAgICAgICAgICAgICAgIHhNaW4sXG4gICAgICAgICAgICAgICAgICB5TWluLFxuICAgICAgICAgICAgICAgICAgeE1heCxcbiAgICAgICAgICAgICAgICAgIHlNYXgsXG4gICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgcGF0aENvbW1hbmRDb3VudDogY21kcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAvLyBmb3JFYWNoUGF0aENvbW1hbmQoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIC8vICAgbGV0IGFyZ3NJbmRleCA9IDBcbiAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgYXJnc0FycmF5ID0gW11cbiAgICAgICAgICAgICAgICAgIC8vICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNtZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBudW1BcmdzID0gY21kQXJnTGVuZ3Roc1tjbWRzW2ldXVxuICAgICAgICAgICAgICAgICAgLy8gICAgIGFyZ3NBcnJheS5sZW5ndGggPSAxICsgbnVtQXJnc1xuICAgICAgICAgICAgICAgICAgLy8gICAgIGFyZ3NBcnJheVswXSA9IGNtZHNbaV1cbiAgICAgICAgICAgICAgICAgIC8vICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBudW1BcmdzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgIGFyZ3NBcnJheVtqXSA9IGNyZHNbYXJnc0luZGV4KytdXG4gICAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3NBcnJheSlcbiAgICAgICAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBLZXJuaW5nXG4gICAgICAgICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBnbHlwaFggKz0gVHlwci5VLmdldFBhaXJBZGp1c3RtZW50KHR5cHJGb250LCBwcmV2R2x5cGhJbmRleCwgZ2x5cGhJbmRleCkgKiBmb250U2NhbGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGdseXBoT2JqLCBnbHlwaFgsIGNoYXJJbmRleCk7XG5cbiAgICAgICAgICAgICAgaWYgKGdseXBoT2JqLmFkdmFuY2VXaWR0aCkge1xuICAgICAgICAgICAgICAgIGdseXBoWCArPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgICBnbHlwaFggKz0gbGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcHJldkdseXBoSW5kZXggPSBnbHlwaEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhckluZGV4ICs9ICh0ZXh0LmNvZGVQb2ludEF0KGNoYXJJbmRleCkgPiAweGZmZmYgPyAyIDogMSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGdseXBoWFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZm9udE9ialxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZShidWZmZXIpIHtcbiAgICAgIC8vIExvb2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBXT0ZGIGZpbGUgYW5kIGNvbnZlcnQgaXQgaWYgc286XG4gICAgICBjb25zdCBwZWVrID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCA0KTtcbiAgICAgIGNvbnN0IHRhZyA9IFR5cHIuX2Jpbi5yZWFkQVNDSUkocGVlaywgMCwgNCk7XG4gICAgICBpZiAodGFnID09PSAnd09GRicpIHtcbiAgICAgICAgYnVmZmVyID0gd29mZjJvdGYoYnVmZmVyKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSAnd09GMicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b2ZmMiBmb250cyBub3Qgc3VwcG9ydGVkJylcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwRm9udE9iaihUeXByLnBhcnNlKGJ1ZmZlcilbMF0pXG4gICAgfVxuICB9XG5cblxuICBjb25zdCB3b3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovdHJvaWthV29ya2VyVXRpbHMuZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICBuYW1lOiAnVHlwciBGb250IFBhcnNlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbdHlwckZhY3RvcnksIHdvZmYyb3RmRmFjdG9yeSwgcGFyc2VyRmFjdG9yeV0sXG4gICAgaW5pdCh0eXByRmFjdG9yeSwgd29mZjJvdGZGYWN0b3J5LCBwYXJzZXJGYWN0b3J5KSB7XG4gICAgICBjb25zdCBUeXByID0gdHlwckZhY3RvcnkoKTtcbiAgICAgIGNvbnN0IHdvZmYyb3RmID0gd29mZjJvdGZGYWN0b3J5KCk7XG4gICAgICByZXR1cm4gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90ZilcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IENPTkZJRyA9IHtcbiAgICBkZWZhdWx0Rm9udFVSTDogJ2h0dHBzOi8vZm9udHMuZ3N0YXRpYy5jb20vcy9yb2JvdG8vdjE4L0tGT21DbnFFdTkyRnIxTXU0bXhNLndvZmYnLCAvL1JvYm90byBSZWd1bGFyXG4gICAgc2RmR2x5cGhTaXplOiA2NCxcbiAgICBzZGZNYXJnaW46IDEgLyAxNixcbiAgICBzZGZFeHBvbmVudDogOSxcbiAgICB0ZXh0dXJlV2lkdGg6IDIwNDhcbiAgfTtcbiAgY29uc3QgdGVtcENvbG9yID0gLyojX19QVVJFX18qL25ldyB0aHJlZS5Db2xvcigpO1xuICBsZXQgaGFzUmVxdWVzdGVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gbm93JDEoKSB7XG4gICAgcmV0dXJuIChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpXG4gIH1cblxuICAvKipcbiAgICogQ3VzdG9taXplcyB0aGUgdGV4dCBidWlsZGVyIGNvbmZpZ3VyYXRpb24uIFRoaXMgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gdGhlIGZpcnN0IGZvbnQgcHJvY2Vzc2luZ1xuICAgKiByZXF1ZXN0LCBhbmQgYXBwbGllcyB0byBhbGwgZm9udHMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGVmYXVsdEZvbnRVUkwgLSBUaGUgVVJMIG9mIHRoZSBkZWZhdWx0IGZvbnQgdG8gdXNlIGZvciB0ZXh0IHByb2Nlc3NpbmdcbiAgICogICAgICAgICAgICAgICAgIHJlcXVlc3RzLCBpbiBjYXNlIG5vbmUgaXMgc3BlY2lmaWVkIG9yIHRoZSBzcGVjaWZpZWRlIGZvbnQgZmFpbHMgdG8gbG9hZCBvciBwYXJzZS5cbiAgICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIFwiUm9ib3RvIFJlZ3VsYXJcIiBmcm9tIEdvb2dsZSBGb250cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5zZGZHbHlwaFNpemUgLSBUaGUgZGVmYXVsdCBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREYgKHNpZ25lZCBkaXN0YW5jZSBmaWVsZClcbiAgICogICAgICAgICAgICAgICAgIHRleHR1cmUgdXNlZCBmb3IgcmVuZGVyaW5nLiBNdXN0IGJlIGEgcG93ZXItb2YtdHdvIG51bWJlciwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLFxuICAgKiAgICAgICAgICAgICAgICAgYnV0IG5vdGUgdGhhdCB0aGlzIGNhbiBhbHNvIGJlIG92ZXJyaWRkZW4gcGVyIGNhbGwgdG8gYGdldFRleHRSZW5kZXJJbmZvKClgLlxuICAgKiAgICAgICAgICAgICAgICAgTGFyZ2VyIHNpemVzIGNhbiBpbXByb3ZlIHRoZSBxdWFsaXR5IG9mIGdseXBoIHJlbmRlcmluZyBieSBpbmNyZWFzaW5nIHRoZSBzaGFycG5lc3NcbiAgICogICAgICAgICAgICAgICAgIG9mIGNvcm5lcnMgYW5kIHByZXZlbnRpbmcgbG9zcyBvZiB2ZXJ5IHRoaW4gbGluZXMsIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeS4gRGVmYXVsdHNcbiAgICogICAgICAgICAgICAgICAgIHRvIDY0IHdoaWNoIGlzIGdlbmVyYWxseSBhIGdvb2QgYmFsYW5jZSBvZiBzaXplIGFuZCBxdWFsaXR5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkV4cG9uZW50IC0gVGhlIGV4cG9uZW50IHVzZWQgd2hlbiBlbmNvZGluZyB0aGUgU0RGIHZhbHVlcy4gQSBoaWdoZXIgZXhwb25lbnRcbiAgICogICAgICAgICAgICAgICAgIHNoaWZ0cyB0aGUgZW5jb2RlZCA4LWJpdCB2YWx1ZXMgdG8gYWNoaWV2ZSBoaWdoZXIgcHJlY2lzaW9uL2FjY3VyYWN5IGF0IHRleGVscyBuZWFyZXJcbiAgICogICAgICAgICAgICAgICAgIHRoZSBnbHlwaCdzIHBhdGgsIHdpdGggbG93ZXIgcHJlY2lzaW9uIGZ1cnRoZXIgYXdheS4gRGVmYXVsdHMgdG8gOS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5zZGZNYXJnaW4gLSBIb3cgbXVjaCBzcGFjZSB0byByZXNlcnZlIGluIHRoZSBTREYgYXMgbWFyZ2luIG91dHNpZGUgdGhlIGdseXBoJ3NcbiAgICogICAgICAgICAgICAgICAgIHBhdGgsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgU0RGIHdpZHRoLiBBIGxhcmdlciBtYXJnaW4gaW5jcmVhc2VzIHRoZSBxdWFsaXR5IG9mXG4gICAqICAgICAgICAgICAgICAgICBleHRydWRlZCBnbHlwaCBvdXRsaW5lcywgYnV0IGRlY3JlYXNlcyB0aGUgcHJlY2lzaW9uIGF2YWlsYWJsZSBmb3IgdGhlIGdseXBoIGl0c2VsZi5cbiAgICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIDEvMTZ0aCBvZiB0aGUgZ2x5cGggc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy50ZXh0dXJlV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIFNERiB0ZXh0dXJlOyBtdXN0IGJlIGEgcG93ZXIgb2YgMi4gRGVmYXVsdHMgdG9cbiAgICogICAgICAgICAgICAgICAgIDIwNDggd2hpY2ggaXMgYSBzYWZlIG1heGltdW0gdGV4dHVyZSBkaW1lbnNpb24gYWNjb3JkaW5nIHRvIHRoZSBzdGF0cyBhdFxuICAgKiAgICAgICAgICAgICAgICAgaHR0cHM6Ly93ZWJnbHN0YXRzLmNvbS93ZWJnbC9wYXJhbWV0ZXIvTUFYX1RFWFRVUkVfU0laRSBhbmQgc2hvdWxkIGFsbG93IGZvciBhXG4gICAqICAgICAgICAgICAgICAgICByZWFzb25hYmx5IGxhcmdlIG51bWJlciBvZiBnbHlwaHMgKGRlZmF1bHQgZ2x5cGggc2l6ZSBvZiA2NF4yIGFuZCBzYWZlIHRleHR1cmUgc2l6ZSBvZlxuICAgKiAgICAgICAgICAgICAgICAgMjA0OF4yLCB0aW1lcyA0IGNoYW5uZWxzLCBhbGxvd3MgZm9yIDQwOTYgZ2x5cGhzLikgVGhpcyBjYW4gYmUgaW5jcmVhc2VkIGlmIHlvdSBuZWVkIHRvXG4gICAqICAgICAgICAgICAgICAgICBpbmNyZWFzZSB0aGUgZ2x5cGggc2l6ZSBhbmQvb3IgaGF2ZSBhbiBleHRyYW9yZGluYXJ5IG51bWJlciBvZiBnbHlwaHMuXG4gICAqL1xuICBmdW5jdGlvbiBjb25maWd1cmVUZXh0QnVpbGRlcihjb25maWcpIHtcbiAgICBpZiAoaGFzUmVxdWVzdGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2NvbmZpZ3VyZVRleHRCdWlsZGVyIGNhbGxlZCBhZnRlciBmaXJzdCBmb250IHJlcXVlc3Q7IHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduKENPTkZJRywgY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVwb3NpdG9yeSBmb3IgYWxsIGZvbnQgU0RGIGF0bGFzIHRleHR1cmVzIGFuZCB0aGVpciBnbHlwaCBtYXBwaW5ncy4gVGhlcmUgaXMgYSBzZXBhcmF0ZSBhdGxhcyBmb3JcbiAgICogZWFjaCBzZGZHbHlwaFNpemUuIEVhY2ggYXRsYXMgaGFzIGEgc2luZ2xlIFRleHR1cmUgdGhhdCBob2xkcyBhbGwgZ2x5cGhzIGZvciBhbGwgZm9udHMuXG4gICAqXG4gICAqICAge1xuICAgKiAgICAgW3NkZkdseXBoU2l6ZV06IHtcbiAgICogICAgICAgZ2x5cGhDb3VudDogbnVtYmVyLFxuICAgKiAgICAgICBzZGZHbHlwaFNpemU6IG51bWJlcixcbiAgICogICAgICAgc2RmVGV4dHVyZTogVGV4dHVyZSxcbiAgICogICAgICAgc2RmQ2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAgICogICAgICAgY29udGV4dExvc3Q6IGJvb2xlYW4sXG4gICAqICAgICAgIGdseXBoc0J5Rm9udDogTWFwPGZvbnRVUkwsIE1hcDxnbHlwaElELCB7cGF0aCwgYXRsYXNJbmRleCwgc2RmVmlld0JveH0+PlxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICovXG4gIGNvbnN0IGF0bGFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBUcm9pa2FUZXh0UmVuZGVySW5mbyAtIEZvcm1hdCBvZiB0aGUgcmVzdWx0IGZyb20gYGdldFRleHRSZW5kZXJJbmZvYC5cbiAgICogQHByb3BlcnR5IHtvYmplY3R9IHBhcmFtZXRlcnMgLSBUaGUgbm9ybWFsaXplZCBpbnB1dCBhcmd1bWVudHMgdG8gdGhlIHJlbmRlciBjYWxsLlxuICAgKiBAcHJvcGVydHkge1RleHR1cmV9IHNkZlRleHR1cmUgLSBUaGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZGZHbHlwaFNpemUgLSBUaGUgc2l6ZSBvZiBlYWNoIGdseXBoJ3MgU0RGOyBzZWUgYGNvbmZpZ3VyZVRleHRCdWlsZGVyYC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZkV4cG9uZW50IC0gVGhlIGV4cG9uZW50IHVzZWQgaW4gZW5jb2RpbmcgdGhlIFNERidzIHZhbHVlczsgc2VlIGBjb25maWd1cmVUZXh0QnVpbGRlcmAuXG4gICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIExpc3Qgb2YgW21pblgsIG1pblksIG1heFgsIG1heFldIHF1YWQgYm91bmRzIGZvciBlYWNoIGdseXBoLlxuICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZ2x5cGhBdGxhc0luZGljZXMgLSBMaXN0IGhvbGRpbmcgZWFjaCBnbHlwaCdzIGluZGV4IGluIHRoZSBTREYgYXRsYXMuXG4gICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgW3IsIGcsIGJdIGNvbG9yLCBpZiBgY29sb3JSYW5nZXNgIHdhcyBzdXBwbGllZC5cbiAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IFtjYXJldFBvc2l0aW9uc10gLSBBIGxpc3Qgb2YgY2FyZXQgcG9zaXRpb25zIGZvciBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nOyBlYWNoIGlzXG4gICAqICAgICAgICAgICB0aHJlZSBlbGVtZW50czogdGhlIHN0YXJ0aW5nIFgsIHRoZSBlbmRpbmcgWCwgYW5kIHRoZSBib3R0b20gWSBmb3IgdGhlIGNhcmV0LlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2NhcmV0SGVpZ2h0XSAtIEFuIGFwcHJvcHJpYXRlIGhlaWdodCBmb3IgYWxsIHNlbGVjdGlvbiBjYXJldHMuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhc2NlbmRlciAtIFRoZSBmb250J3MgYXNjZW5kZXIgbWV0cmljLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVzY2VuZGVyIC0gVGhlIGZvbnQncyBkZXNjZW5kZXIgbWV0cmljLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gY2FwSGVpZ2h0IC0gVGhlIGZvbnQncyBjYXAgaGVpZ2h0IG1ldHJpYywgYmFzZWQgb24gdGhlIGhlaWdodCBvZiBMYXRpbiBjYXBpdGFsIGxldHRlcnMuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SGVpZ2h0IC0gVGhlIGZvbnQncyB4IGhlaWdodCBtZXRyaWMsIGJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgTGF0aW4gbG93ZXJjYXNlIGxldHRlcnMuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lSGVpZ2h0IC0gVGhlIGZpbmFsIGNvbXB1dGVkIGxpbmVIZWlnaHQgbWVhc3VyZW1lbnQuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3BCYXNlbGluZSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lLlxuICAgKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGJsb2NrQm91bmRzIC0gVGhlIHRvdGFsIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSByZWN0IG9mIHRoZSB3aG9sZSB0ZXh0IGJsb2NrO1xuICAgKiAgICAgICAgICAgdGhpcyBjYW4gaW5jbHVkZSBleHRyYSB2ZXJ0aWNhbCBzcGFjZSBiZXlvbmQgdGhlIHZpc2libGUgZ2x5cGhzIGR1ZSB0byBsaW5lSGVpZ2h0LCBhbmQgaXNcbiAgICogICAgICAgICAgIGVxdWl2YWxlbnQgdG8gdGhlIGRpbWVuc2lvbnMgb2YgYSBibG9jay1sZXZlbCB0ZXh0IGVsZW1lbnQgaW4gQ1NTLlxuICAgKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IHZpc2libGVCb3VuZHMgLSBUaGUgdG90YWwgW21pblgsIG1pblksIG1heFgsIG1heFldIHJlY3Qgb2YgdGhlIHdob2xlIHRleHQgYmxvY2s7XG4gICAqICAgICAgICAgICB1bmxpa2UgYGJsb2NrQm91bmRzYCB0aGlzIGlzIHRpZ2h0bHkgd3JhcHBlZCB0byB0aGUgdmlzaWJsZSBnbHlwaCBwYXRocy5cbiAgICogQHByb3BlcnR5IHtBcnJheTxvYmplY3Q+fSBjaHVua2VkQm91bmRzIC0gTGlzdCBvZiBib3VuZGluZyByZWN0cyBmb3IgZWFjaCBjb25zZWN1dGl2ZSBzZXQgb2YgTiBnbHlwaHMsXG4gICAqICAgICAgICAgICBpbiB0aGUgZm9ybWF0IGB7c3RhcnQ6TiwgZW5kOk4sIHJlY3Q6W21pblgsIG1pblksIG1heFgsIG1heFldfWAuXG4gICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0aW1pbmdzIC0gVGltaW5nIGluZm8gZm9yIHZhcmlvdXMgcGFydHMgb2YgdGhlIHJlbmRlcmluZyBsb2dpYyBpbmNsdWRpbmcgU0RGXG4gICAqICAgICAgICAgICBnZW5lcmF0aW9uLCB0eXBlc2V0dGluZywgZXRjLlxuICAgKiBAZnJvemVuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgZ2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2tcbiAgICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAgICovXG5cbiAgLyoqXG4gICAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHJlcXVlc3RpbmcgdGhlIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHRleHQgc3RyaW5nIHdpdGggZ2l2ZW4gZm9udCBwYXJhbWV0ZXJzLlxuICAgKiBUaGlzIGlzIGFuIGFzeW5jaHJvbm91cyBjYWxsLCBwZXJmb3JtaW5nIG1vc3Qgb2YgdGhlIGxvZ2ljIGluIGEgd2ViIHdvcmtlciB0aHJlYWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAqIEBwYXJhbSB7Z2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2t9IGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUZXh0UmVuZGVySW5mbyhhcmdzLCBjYWxsYmFjaykge1xuICAgIGhhc1JlcXVlc3RlZCA9IHRydWU7XG4gICAgYXJncyA9IGFzc2lnbih7fSwgYXJncyk7XG4gICAgY29uc3QgdG90YWxTdGFydCA9IG5vdyQxKCk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0IGZvbnQgaGVyZSB0byBhdm9pZCBhICdudWxsJyBhdGxhcywgYW5kIGNvbnZlcnQgcmVsYXRpdmVcbiAgICAvLyBVUkxzIHRvIGFic29sdXRlIHNvIHRoZXkgY2FuIGJlIHJlc29sdmVkIGluIHRoZSB3b3JrZXJcbiAgICBhcmdzLmZvbnQgPSB0b0Fic29sdXRlVVJMKGFyZ3MuZm9udCB8fCBDT05GSUcuZGVmYXVsdEZvbnRVUkwpO1xuXG4gICAgLy8gTm9ybWFsaXplIHRleHQgdG8gYSBzdHJpbmdcbiAgICBhcmdzLnRleHQgPSAnJyArIGFyZ3MudGV4dDtcblxuICAgIGFyZ3Muc2RmR2x5cGhTaXplID0gYXJncy5zZGZHbHlwaFNpemUgfHwgQ09ORklHLnNkZkdseXBoU2l6ZTtcblxuICAgIC8vIE5vcm1hbGl6ZSBjb2xvcnNcbiAgICBpZiAoYXJncy5jb2xvclJhbmdlcyAhPSBudWxsKSB7XG4gICAgICBsZXQgY29sb3JzID0ge307XG4gICAgICBmb3IgKGxldCBrZXkgaW4gYXJncy5jb2xvclJhbmdlcykge1xuICAgICAgICBpZiAoYXJncy5jb2xvclJhbmdlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgbGV0IHZhbCA9IGFyZ3MuY29sb3JSYW5nZXNba2V5XTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbCA9IHRlbXBDb2xvci5zZXQodmFsKS5nZXRIZXgoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29sb3JzW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3MuY29sb3JSYW5nZXMgPSBjb2xvcnM7XG4gICAgfVxuXG4gICAgT2JqZWN0LmZyZWV6ZShhcmdzKTtcblxuICAgIC8vIEluaXQgdGhlIGF0bGFzIGlmIG5lZWRlZFxuICAgIGNvbnN0IHt0ZXh0dXJlV2lkdGgsIHNkZkV4cG9uZW50fSA9IENPTkZJRztcbiAgICBjb25zdCB7c2RmR2x5cGhTaXplfSA9IGFyZ3M7XG4gICAgY29uc3QgZ2x5cGhzUGVyUm93ID0gKHRleHR1cmVXaWR0aCAvIHNkZkdseXBoU2l6ZSAqIDQpO1xuICAgIGxldCBhdGxhcyA9IGF0bGFzZXNbc2RmR2x5cGhTaXplXTtcbiAgICBpZiAoIWF0bGFzKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHRleHR1cmVXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBzZGZHbHlwaFNpemUgKiAyNTYgLyBnbHlwaHNQZXJSb3c7IC8vIHN0YXJ0IHRhbGwgZW5vdWdoIHRvIGZpdCAyNTYgZ2x5cGhzXG4gICAgICBhdGxhcyA9IGF0bGFzZXNbc2RmR2x5cGhTaXplXSA9IHtcbiAgICAgICAgZ2x5cGhDb3VudDogMCxcbiAgICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgICBzZGZDYW52YXM6IGNhbnZhcyxcbiAgICAgICAgc2RmVGV4dHVyZTogbmV3IHRocmVlLlRleHR1cmUoXG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHRocmVlLkxpbmVhckZpbHRlcixcbiAgICAgICAgICB0aHJlZS5MaW5lYXJGaWx0ZXJcbiAgICAgICAgKSxcbiAgICAgICAgY29udGV4dExvc3Q6IGZhbHNlLFxuICAgICAgICBnbHlwaHNCeUZvbnQ6IG5ldyBNYXAoKVxuICAgICAgfTtcbiAgICAgIGF0bGFzLnNkZlRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICBpbml0Q29udGV4dExvc3NIYW5kbGluZyhhdGxhcyk7XG4gICAgfVxuXG4gICAgY29uc3Qge3NkZlRleHR1cmUsIHNkZkNhbnZhc30gPSBhdGxhcztcbiAgICBsZXQgZm9udEdseXBocyA9IGF0bGFzLmdseXBoc0J5Rm9udC5nZXQoYXJncy5mb250KTtcbiAgICBpZiAoIWZvbnRHbHlwaHMpIHtcbiAgICAgIGF0bGFzLmdseXBoc0J5Rm9udC5zZXQoYXJncy5mb250LCBmb250R2x5cGhzID0gbmV3IE1hcCgpKTtcbiAgICB9XG5cbiAgICAvLyBJc3N1ZSByZXF1ZXN0IHRvIHRoZSB0eXBlc2V0dGluZyBlbmdpbmUgaW4gdGhlIHdvcmtlclxuICAgIHR5cGVzZXRJbldvcmtlcihhcmdzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCB7Z2x5cGhJZHMsIGdseXBoUG9zaXRpb25zLCBmb250U2l6ZSwgdW5pdHNQZXJFbSwgdGltaW5nc30gPSByZXN1bHQ7XG4gICAgICBjb25zdCBuZWVkZWRTREZzID0gW107XG4gICAgICBjb25zdCBnbHlwaEJvdW5kcyA9IG5ldyBGbG9hdDMyQXJyYXkoZ2x5cGhJZHMubGVuZ3RoICogNCk7XG4gICAgICBjb25zdCBmb250U2l6ZU11bHQgPSBmb250U2l6ZSAvIHVuaXRzUGVyRW07XG4gICAgICBsZXQgYm91bmRzSWR4ID0gMDtcbiAgICAgIGxldCBwb3NpdGlvbnNJZHggPSAwO1xuICAgICAgY29uc3QgcXVhZHNTdGFydCA9IG5vdyQxKCk7XG4gICAgICBnbHlwaElkcy5mb3JFYWNoKChnbHlwaElkLCBpKSA9PiB7XG4gICAgICAgIGxldCBnbHlwaEluZm8gPSBmb250R2x5cGhzLmdldChnbHlwaElkKTtcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgZ2x5cGhJZCBub3Qgc2VlbiBiZWZvcmUsIGFkZCBpdCB0byB0aGUgYXRsYXNcbiAgICAgICAgaWYgKCFnbHlwaEluZm8pIHtcbiAgICAgICAgICBjb25zdCB7cGF0aCwgcGF0aEJvdW5kc30gPSByZXN1bHQuZ2x5cGhEYXRhW2dseXBoSWRdO1xuXG4gICAgICAgICAgLy8gTWFyZ2luIGFyb3VuZCBwYXRoIGVkZ2VzIGluIFNERiwgYmFzZWQgb24gYSBwZXJjZW50YWdlIG9mIHRoZSBnbHlwaCdzIG1heCBkaW1lbnNpb24uXG4gICAgICAgICAgLy8gTm90ZSB3ZSBhZGQgYW4gZXh0cmEgMC41IHB4IG92ZXIgdGhlIGNvbmZpZ3VyZWQgdmFsdWUgYmVjYXVzZSB0aGUgb3V0ZXIgMC41IGRvZXNuJ3QgY29udGFpblxuICAgICAgICAgIC8vIHVzZWZ1bCBpbnRlcnBvbGF0ZWQgdmFsdWVzIGFuZCB3aWxsIGJlIGlnbm9yZWQgYW55d2F5LlxuICAgICAgICAgIGNvbnN0IGZvbnRVbml0c01hcmdpbiA9IE1hdGgubWF4KHBhdGhCb3VuZHNbMl0gLSBwYXRoQm91bmRzWzBdLCBwYXRoQm91bmRzWzNdIC0gcGF0aEJvdW5kc1sxXSlcbiAgICAgICAgICAgIC8gc2RmR2x5cGhTaXplICogKENPTkZJRy5zZGZNYXJnaW4gKiBzZGZHbHlwaFNpemUgKyAwLjUpO1xuXG4gICAgICAgICAgY29uc3QgYXRsYXNJbmRleCA9IGF0bGFzLmdseXBoQ291bnQrKztcbiAgICAgICAgICBjb25zdCBzZGZWaWV3Qm94ID0gW1xuICAgICAgICAgICAgcGF0aEJvdW5kc1swXSAtIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICAgIHBhdGhCb3VuZHNbMV0gLSBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgICBwYXRoQm91bmRzWzJdICsgZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgICAgcGF0aEJvdW5kc1szXSArIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICBdO1xuICAgICAgICAgIGZvbnRHbHlwaHMuc2V0KGdseXBoSWQsIChnbHlwaEluZm8gPSB7IHBhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3ggfSkpO1xuXG4gICAgICAgICAgLy8gQ29sbGVjdCB0aG9zZSB0aGF0IG5lZWQgU0RGIGdlbmVyYXRpb25cbiAgICAgICAgICBuZWVkZWRTREZzLnB1c2goZ2x5cGhJbmZvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBib3VuZHMgZm9yIHJlbmRlcmFibGUgcXVhZHNcbiAgICAgICAgLy8gVE9ETyBjYW4gd2UgZ2V0IHRoaXMgYmFjayBvZmYgdGhlIG1haW4gdGhyZWFkP1xuICAgICAgICBjb25zdCB7c2RmVmlld0JveH0gPSBnbHlwaEluZm87XG4gICAgICAgIGNvbnN0IHBvc1ggPSBnbHlwaFBvc2l0aW9uc1twb3NpdGlvbnNJZHgrK107XG4gICAgICAgIGNvbnN0IHBvc1kgPSBnbHlwaFBvc2l0aW9uc1twb3NpdGlvbnNJZHgrK107XG4gICAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1ggKyBzZGZWaWV3Qm94WzBdICogZm9udFNpemVNdWx0O1xuICAgICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NZICsgc2RmVmlld0JveFsxXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWCArIHNkZlZpZXdCb3hbMl0gKiBmb250U2l6ZU11bHQ7XG4gICAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1kgKyBzZGZWaWV3Qm94WzNdICogZm9udFNpemVNdWx0O1xuXG4gICAgICAgIC8vIENvbnZlcnQgZ2x5cGhJZCB0byBTREYgaW5kZXggZm9yIHRoZSBzaGFkZXJcbiAgICAgICAgZ2x5cGhJZHNbaV0gPSBnbHlwaEluZm8uYXRsYXNJbmRleDtcbiAgICAgIH0pO1xuICAgICAgdGltaW5ncy5xdWFkcyA9ICh0aW1pbmdzLnF1YWRzIHx8IDApICsgKG5vdyQxKCkgLSBxdWFkc1N0YXJ0KTtcblxuICAgICAgY29uc3Qgc2RmU3RhcnQgPSBub3ckMSgpO1xuICAgICAgdGltaW5ncy5zZGYgPSB7fTtcblxuICAgICAgLy8gR3JvdyB0aGUgdGV4dHVyZSBoZWlnaHQgYnkgcG93ZXIgb2YgMiBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBzZGZDYW52YXMuaGVpZ2h0O1xuICAgICAgY29uc3QgbmVlZGVkUm93cyA9IE1hdGguY2VpbChhdGxhcy5nbHlwaENvdW50IC8gZ2x5cGhzUGVyUm93KTtcbiAgICAgIGNvbnN0IG5lZWRlZEhlaWdodCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobmVlZGVkUm93cyAqIHNkZkdseXBoU2l6ZSkpKTtcbiAgICAgIGlmIChuZWVkZWRIZWlnaHQgPiBjdXJyZW50SGVpZ2h0KSB7XG4gICAgICAgIC8vIFNpbmNlIHJlc2l6aW5nIHRoZSBjYW52YXMgY2xlYXJzIGl0cyByZW5kZXIgYnVmZmVyLCBpdCBuZWVkcyBzcGVjaWFsIGhhbmRsaW5nIHRvIGNvcHkgdGhlIG9sZCBjb250ZW50cyBvdmVyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgSW5jcmVhc2luZyBTREYgdGV4dHVyZSBzaXplICR7Y3VycmVudEhlaWdodH0tPiR7bmVlZGVkSGVpZ2h0fWApO1xuICAgICAgICByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZyhzZGZDYW52YXMsIHRleHR1cmVXaWR0aCwgbmVlZGVkSGVpZ2h0KTtcbiAgICAgICAgLy8gQXMgb2YgVGhyZWUgcjEzNiB0ZXh0dXJlcyBjYW5ub3QgYmUgcmVzaXplZCBvbmNlIHRoZXkncmUgYWxsb2NhdGVkIG9uIHRoZSBHUFUsIHdlIG11c3QgZGlzcG9zZSB0byByZWFsbG9jYXRlIGl0XG4gICAgICAgIHNkZlRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBQcm9taXNlLmFsbChuZWVkZWRTREZzLm1hcChnbHlwaEluZm8gPT5cbiAgICAgICAgZ2VuZXJhdGVHbHlwaFNERihnbHlwaEluZm8sIGF0bGFzLCBhcmdzLmdwdUFjY2VsZXJhdGVTREYpLnRoZW4oKHt0aW1pbmd9KSA9PiB7XG4gICAgICAgICAgdGltaW5ncy5zZGZbZ2x5cGhJbmZvLmF0bGFzSW5kZXhdID0gdGltaW5nO1xuICAgICAgICB9KVxuICAgICAgKSkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChuZWVkZWRTREZzLmxlbmd0aCAmJiAhYXRsYXMuY29udGV4dExvc3QpIHtcbiAgICAgICAgICBzYWZhcmlQcmUxNVdvcmthcm91bmQoYXRsYXMpO1xuICAgICAgICAgIHNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRpbWluZ3Muc2RmVG90YWwgPSBub3ckMSgpIC0gc2RmU3RhcnQ7XG4gICAgICAgIHRpbWluZ3MudG90YWwgPSBub3ckMSgpIC0gdG90YWxTdGFydDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYFNERiAtICR7dGltaW5ncy5zZGZUb3RhbH0sIFRvdGFsIC0gJHt0aW1pbmdzLnRvdGFsIC0gdGltaW5ncy5mb250TG9hZH1gKVxuXG4gICAgICAgIC8vIEludm9rZSBjYWxsYmFjayB3aXRoIHRoZSB0ZXh0IGxheW91dCBhcnJheXMgYW5kIHVwZGF0ZWQgdGV4dHVyZVxuICAgICAgICBjYWxsYmFjayhPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBhcmdzLFxuICAgICAgICAgIHNkZlRleHR1cmUsXG4gICAgICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgICAgIHNkZkV4cG9uZW50LFxuICAgICAgICAgIGdseXBoQm91bmRzLFxuICAgICAgICAgIGdseXBoQXRsYXNJbmRpY2VzOiBnbHlwaElkcyxcbiAgICAgICAgICBnbHlwaENvbG9yczogcmVzdWx0LmdseXBoQ29sb3JzLFxuICAgICAgICAgIGNhcmV0UG9zaXRpb25zOiByZXN1bHQuY2FyZXRQb3NpdGlvbnMsXG4gICAgICAgICAgY2FyZXRIZWlnaHQ6IHJlc3VsdC5jYXJldEhlaWdodCxcbiAgICAgICAgICBjaHVua2VkQm91bmRzOiByZXN1bHQuY2h1bmtlZEJvdW5kcyxcbiAgICAgICAgICBhc2NlbmRlcjogcmVzdWx0LmFzY2VuZGVyLFxuICAgICAgICAgIGRlc2NlbmRlcjogcmVzdWx0LmRlc2NlbmRlcixcbiAgICAgICAgICBsaW5lSGVpZ2h0OiByZXN1bHQubGluZUhlaWdodCxcbiAgICAgICAgICBjYXBIZWlnaHQ6IHJlc3VsdC5jYXBIZWlnaHQsXG4gICAgICAgICAgeEhlaWdodDogcmVzdWx0LnhIZWlnaHQsXG4gICAgICAgICAgdG9wQmFzZWxpbmU6IHJlc3VsdC50b3BCYXNlbGluZSxcbiAgICAgICAgICBibG9ja0JvdW5kczogcmVzdWx0LmJsb2NrQm91bmRzLFxuICAgICAgICAgIHZpc2libGVCb3VuZHM6IHJlc3VsdC52aXNpYmxlQm91bmRzLFxuICAgICAgICAgIHRpbWluZ3M6IHJlc3VsdC50aW1pbmdzLFxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFdoaWxlIHRoZSB0eXBlc2V0dGluZyByZXF1ZXN0IGlzIGJlaW5nIGhhbmRsZWQsIGdvIGFoZWFkIGFuZCBtYWtlIHN1cmUgdGhlIGF0bGFzIGNhbnZhcyBjb250ZXh0IGlzXG4gICAgLy8gXCJ3YXJtZWQgdXBcIjsgdGhlIGZpcnN0IHJlcXVlc3Qgd2lsbCBiZSB0aGUgbG9uZ2VzdCBkdWUgdG8gc2hhZGVyIHByb2dyYW0gY29tcGlsYXRpb24gc28gdGhpcyBnZXRzXG4gICAgLy8gYSBoZWFkIHN0YXJ0IG9uIHRoYXQgcHJvY2VzcyBiZWZvcmUgU0RGcyBhY3R1YWxseSBzdGFydCBnZXR0aW5nIHByb2Nlc3NlZC5cbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICghYXRsYXMuY29udGV4dExvc3QpIHtcbiAgICAgICAgd2FybVVwU0RGQ2FudmFzKHNkZkNhbnZhcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUdseXBoU0RGKHtwYXRoLCBhdGxhc0luZGV4LCBzZGZWaWV3Qm94fSwge3NkZkdseXBoU2l6ZSwgc2RmQ2FudmFzLCBjb250ZXh0TG9zdH0sIHVzZUdQVSkge1xuICAgIGlmIChjb250ZXh0TG9zdCkge1xuICAgICAgLy8gSWYgdGhlIGNvbnRleHQgaXMgbG9zdCB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIGRvLCBqdXN0IHF1aXQgc2lsZW50bHkgYW5kIGxldCBpdFxuICAgICAgLy8gZ2V0IHJlZ2VuZXJhdGVkIHdoZW4gdGhlIGNvbnRleHQgaXMgcmVzdG9yZWRcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3RpbWluZzogLTF9KVxuICAgIH1cbiAgICBjb25zdCB7dGV4dHVyZVdpZHRoLCBzZGZFeHBvbmVudH0gPSBDT05GSUc7XG4gICAgY29uc3QgbWF4RGlzdCA9IE1hdGgubWF4KHNkZlZpZXdCb3hbMl0gLSBzZGZWaWV3Qm94WzBdLCBzZGZWaWV3Qm94WzNdIC0gc2RmVmlld0JveFsxXSk7XG4gICAgY29uc3Qgc3F1YXJlSW5kZXggPSBNYXRoLmZsb29yKGF0bGFzSW5kZXggLyA0KTtcbiAgICBjb25zdCB4ID0gc3F1YXJlSW5kZXggJSAodGV4dHVyZVdpZHRoIC8gc2RmR2x5cGhTaXplKSAqIHNkZkdseXBoU2l6ZTtcbiAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihzcXVhcmVJbmRleCAvICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpKSAqIHNkZkdseXBoU2l6ZTtcbiAgICBjb25zdCBjaGFubmVsID0gYXRsYXNJbmRleCAlIDQ7XG4gICAgcmV0dXJuIGdlbmVyYXRlU0RGKHNkZkdseXBoU2l6ZSwgc2RmR2x5cGhTaXplLCBwYXRoLCBzZGZWaWV3Qm94LCBtYXhEaXN0LCBzZGZFeHBvbmVudCwgc2RmQ2FudmFzLCB4LCB5LCBjaGFubmVsLCB1c2VHUFUpXG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29udGV4dExvc3NIYW5kbGluZyhhdGxhcykge1xuICAgIGNvbnN0IGNhbnZhcyA9IGF0bGFzLnNkZkNhbnZhcztcblxuICAgIC8qXG4gICAgLy8gQmVnaW4gY29udGV4dCBsb3NzIHNpbXVsYXRpb25cbiAgICBpZiAoIXdpbmRvdy5XZWJHTERlYnVnVXRpbHMpIHtcbiAgICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2ViR0xEZWJ1Z1V0aWxzU2NyaXB0JylcbiAgICAgIGlmICghc2NyaXB0KSB7XG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICAgIHNjcmlwdC5pZCA9ICdXZWJHTERlYnVnVXRpbHMnXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICAgICAgICBzY3JpcHQuc3JjID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9LaHJvbm9zR3JvdXAvV2ViR0xEZXZlbG9wZXJUb29sc0BiNDJlNzAyL3NyYy9kZWJ1Zy93ZWJnbC1kZWJ1Zy5qcydcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICBpbml0Q29udGV4dExvc3NIYW5kbGluZyhhdGxhcylcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgd2luZG93LldlYkdMRGVidWdVdGlscy5tYWtlTG9zdENvbnRleHRTaW11bGF0aW5nQ2FudmFzKGNhbnZhcylcbiAgICBjYW52YXMubG9zZUNvbnRleHRJbk5DYWxscyg1MDApXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgKGV2ZW50KSA9PiB7XG4gICAgICBjYW52YXMubG9zZUNvbnRleHRJbk5DYWxscyg1MDAwKVxuICAgIH0pXG4gICAgLy8gRW5kIGNvbnRleHQgbG9zcyBzaW11bGF0aW9uXG4gICAgKi9cblxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnQ29udGV4dCBMb3N0JywgZXZlbnQpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGF0bGFzLmNvbnRleHRMb3N0ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdDb250ZXh0IFJlc3RvcmVkJywgZXZlbnQpO1xuICAgICAgYXRsYXMuY29udGV4dExvc3QgPSBmYWxzZTtcbiAgICAgIC8vIFJlZ2VuZXJhdGUgYWxsIGdseXBocyBpbnRvIHRoZSByZXN0b3JlZCBjYW52YXM6XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgYXRsYXMuZ2x5cGhzQnlGb250LmZvckVhY2goZ2x5cGhNYXAgPT4ge1xuICAgICAgICBnbHlwaE1hcC5mb3JFYWNoKGdseXBoID0+IHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGdlbmVyYXRlR2x5cGhTREYoZ2x5cGgsIGF0bGFzLCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcyk7XG4gICAgICAgIGF0bGFzLnNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJlbG9hZCBhIGdpdmVuIGZvbnQgYW5kIG9wdGlvbmFsbHkgcHJlLWdlbmVyYXRlIGdseXBoIFNERnMgZm9yIG9uZSBvciBtb3JlIGNoYXJhY3RlciBzZXF1ZW5jZXMuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCBsb25nIHBhdXNlcyB3aGVuIGZpcnN0IHNob3dpbmcgdGV4dCBpbiBhIHNjZW5lLCBieSBwcmVsb2FkaW5nIHRoZVxuICAgKiBuZWVkZWQgZm9udHMgYW5kIGdseXBocyB1cCBmcm9udCBhbG9uZyB3aXRoIG90aGVyIGFzc2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZm9udCAtIFVSTCBvZiB0aGUgZm9udCBmaWxlIHRvIHByZWxvYWQuIElmIG5vdCBnaXZlbiwgdGhlIGRlZmF1bHQgZm9udCB3aWxsXG4gICAqICAgICAgICBiZSBsb2FkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLmNoYXJhY3RlcnMgLSBPbmUgb3IgbW9yZSBjaGFyYWN0ZXIgc2VxdWVuY2VzIGZvciB3aGljaCB0byBwcmUtXG4gICAqICAgICAgICBnZW5lcmF0ZSBnbHlwaCBTREZzLiBOb3RlIHRoYXQgdGhpcyB3aWxsIGhvbm9yIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbiwgc28geW91IG1heSBuZWVkXG4gICAqICAgICAgICB0byBzcGVjaWZ5IGxpZ2F0dXJlIHNlcXVlbmNlcyBpbiBhZGRpdGlvbiB0byB0aGVpciBpbmRpdmlkdWFsIGNoYXJhY3RlcnMgdG8gZ2V0IGFsbFxuICAgKiAgICAgICAgcG9zc2libGUgZ2x5cGhzLCBlLmcuIGBbXCJ0XCIsIFwiaFwiLCBcInRoXCJdYCB0byBnZXQgdGhlIFwidFwiIGFuZCBcImhcIiBnbHlwaHMgcGx1cyB0aGUgXCJ0aFwiIGxpZ2F0dXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZGZHbHlwaFNpemUgLSBUaGUgc2l6ZSBhdCB3aGljaCB0byBwcmVyZW5kZXIgdGhlIFNERiB0ZXh0dXJlcyBmb3IgdGhlXG4gICAqICAgICAgICBzcGVjaWZpZWQgYGNoYXJhY3RlcnNgLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBwcmVsb2FkaW5nIGlzIGNvbXBsZXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gcHJlbG9hZEZvbnQoe2ZvbnQsIGNoYXJhY3RlcnMsIHNkZkdseXBoU2l6ZX0sIGNhbGxiYWNrKSB7XG4gICAgbGV0IHRleHQgPSBBcnJheS5pc0FycmF5KGNoYXJhY3RlcnMpID8gY2hhcmFjdGVycy5qb2luKCdcXG4nKSA6ICcnICsgY2hhcmFjdGVycztcbiAgICBnZXRUZXh0UmVuZGVySW5mbyh7IGZvbnQsIHNkZkdseXBoU2l6ZSwgdGV4dCB9LCBjYWxsYmFjayk7XG4gIH1cblxuXG4gIC8vIExvY2FsIGFzc2lnbiBpbXBsIHNvIHdlIGRvbid0IGhhdmUgdG8gaW1wb3J0IHRyb2lrYS1jb3JlXG4gIGZ1bmN0aW9uIGFzc2lnbih0b09iaiwgZnJvbU9iaikge1xuICAgIGZvciAobGV0IGtleSBpbiBmcm9tT2JqKSB7XG4gICAgICBpZiAoZnJvbU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHRvT2JqW2tleV0gPSBmcm9tT2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b09ialxuICB9XG5cbiAgLy8gVXRpbGl0eSBmb3IgbWFraW5nIFVSTHMgYWJzb2x1dGVcbiAgbGV0IGxpbmtFbDtcbiAgZnVuY3Rpb24gdG9BYnNvbHV0ZVVSTChwYXRoKSB7XG4gICAgaWYgKCFsaW5rRWwpIHtcbiAgICAgIGxpbmtFbCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG4gICAgbGlua0VsLmhyZWYgPSBwYXRoO1xuICAgIHJldHVybiBsaW5rRWwuaHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFNhZmFyaSA8IHYxNSBzZWVtcyB1bmFibGUgdG8gdXNlIHRoZSBTREYgd2ViZ2wgY2FudmFzIGFzIGEgdGV4dHVyZS4gVGhpcyBhcHBsaWVzIGEgd29ya2Fyb3VuZFxuICAgKiB3aGVyZSBpdCByZWFkcyB0aGUgcGl4ZWxzIG91dCBvZiB0aGF0IGNhbnZhcyBhbmQgdXBsb2FkcyB0aGVtIGFzIGEgZGF0YSB0ZXh0dXJlIGluc3RlYWQsIGF0XG4gICAqIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGNvc3QuXG4gICAqL1xuICBmdW5jdGlvbiBzYWZhcmlQcmUxNVdvcmthcm91bmQoYXRsYXMpIHtcbiAgICAvLyBVc2UgY3JlYXRlSW1hZ2VCaXRtYXAgc3VwcG9ydCBhcyBhIHByb3h5IGZvciBTYWZhcmk8MTUsIGFsbCBvdGhlciBtYWluc3RyZWFtIGJyb3dzZXJzXG4gICAgLy8gaGF2ZSBzdXBwb3J0ZWQgaXQgZm9yIGEgbG9uZyB3aGlsZSBzbyBhbnkgZmFsc2UgcG9zaXRpdmVzIHNob3VsZCBiZSBtaW5pbWFsLlxuICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnU2FmYXJpPDE1OiBhcHBseWluZyBTREYgY2FudmFzIHdvcmthcm91bmQnKTtcbiAgICAgIGNvbnN0IHtzZGZDYW52YXMsIHNkZlRleHR1cmV9ID0gYXRsYXM7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzZGZDYW52YXM7XG4gICAgICBjb25zdCBnbCA9IGF0bGFzLnNkZkNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpO1xuICAgICAgbGV0IHBpeGVscyA9IHNkZlRleHR1cmUuaW1hZ2UuZGF0YTtcbiAgICAgIGlmICghcGl4ZWxzIHx8IHBpeGVscy5sZW5ndGggIT09IHdpZHRoICogaGVpZ2h0ICogNCkge1xuICAgICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICBzZGZUZXh0dXJlLmltYWdlID0ge3dpZHRoLCBoZWlnaHQsIGRhdGE6IHBpeGVsc307XG4gICAgICAgIHNkZlRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgICAgc2RmVGV4dHVyZS5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICB9XG4gIH1cblxuXG4gIGNvbnN0IHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovdHJvaWthV29ya2VyVXRpbHMuZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICBuYW1lOiAnVHlwZXNldHRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICBDT05GSUcsXG4gICAgICB3b3JrZXJNb2R1bGUsXG4gICAgICBjcmVhdGVUeXBlc2V0dGVyLFxuICAgICAgYmlkaUZhY3RvcnlfX2RlZmF1bHRbJ2RlZmF1bHQnXVxuICAgIF0sXG4gICAgaW5pdChjb25maWcsIGZvbnRQYXJzZXIsIGNyZWF0ZVR5cGVzZXR0ZXIsIGJpZGlGYWN0b3J5KSB7XG4gICAgICBjb25zdCB7ZGVmYXVsdEZvbnRVUkx9ID0gY29uZmlnO1xuICAgICAgcmV0dXJuIGNyZWF0ZVR5cGVzZXR0ZXIoZm9udFBhcnNlciwgYmlkaUZhY3RvcnkoKSwgeyBkZWZhdWx0Rm9udFVSTCB9KVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdHlwZXNldEluV29ya2VyID0gLyojX19QVVJFX18qL3Ryb2lrYVdvcmtlclV0aWxzLmRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgbmFtZTogJ1R5cGVzZXR0ZXInLFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdHlwZXNldHRlcldvcmtlck1vZHVsZSxcbiAgICBdLFxuICAgIGluaXQodHlwZXNldHRlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIHR5cGVzZXR0ZXIudHlwZXNldChhcmdzLCByZXNvbHZlKTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFRyYW5zZmVyYWJsZXMocmVzdWx0KSB7XG4gICAgICAvLyBNYXJrIGFycmF5IGJ1ZmZlcnMgYXMgdHJhbnNmZXJhYmxlIHRvIGF2b2lkIGNsb25pbmcgZHVyaW5nIHBvc3RNZXNzYWdlXG4gICAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW1xuICAgICAgICByZXN1bHQuZ2x5cGhQb3NpdGlvbnMuYnVmZmVyLFxuICAgICAgICByZXN1bHQuZ2x5cGhJZHMuYnVmZmVyXG4gICAgICBdO1xuICAgICAgaWYgKHJlc3VsdC5jYXJldFBvc2l0aW9ucykge1xuICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2gocmVzdWx0LmNhcmV0UG9zaXRpb25zLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmdseXBoQ29sb3JzKSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChyZXN1bHQuZ2x5cGhDb2xvcnMuYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVzXG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBkdW1wU0RGVGV4dHVyZXMoKSB7XG4gICAgT2JqZWN0LmtleXMoYXRsYXNlcykuZm9yRWFjaChzaXplID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGF0bGFzZXNbc2l6ZV0uc2RmQ2FudmFzO1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gY2FudmFzO1xuICAgICAgY29uc29sZS5sb2coXCIlYy5cIiwgYFxuICAgICAgYmFja2dyb3VuZDogdXJsKCR7Y2FudmFzLnRvRGF0YVVSTCgpfSk7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6ICR7d2lkdGh9cHggJHtoZWlnaHR9cHg7XG4gICAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICBmb250LXNpemU6IDA7XG4gICAgICBsaW5lLWhlaWdodDogJHtoZWlnaHR9cHg7XG4gICAgICBwYWRkaW5nLWxlZnQ6ICR7d2lkdGh9cHg7XG4gICAgYCk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB0ZW1wbGF0ZUdlb21ldHJpZXMgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRUZW1wbGF0ZUdlb21ldHJ5KGRldGFpbCkge1xuICAgIGxldCBnZW9tID0gdGVtcGxhdGVHZW9tZXRyaWVzW2RldGFpbF07XG4gICAgaWYgKCFnZW9tKSB7XG4gICAgICAvLyBHZW9tZXRyeSBpcyB0d28gcGxhbmVzIGJhY2stdG8tYmFjaywgd2hpY2ggd2lsbCBhbHdheXMgYmUgcmVuZGVyZWQgRnJvbnRTaWRlIG9ubHkgYnV0XG4gICAgICAvLyBhcHBlYXIgYXMgRG91YmxlU2lkZSBieSBkZWZhdWx0LiBGcm9udFNpZGUvQmFja1NpZGUgYXJlIGVtdWxhdGVkIHVzaW5nIGRyYXdSYW5nZS5cbiAgICAgIC8vIFdlIGRvIGl0IHRoaXMgd2F5IHRvIGF2b2lkIHRoZSBwZXJmb3JtYW5jZSBoaXQgb2YgdHdvIGRyYXcgY2FsbHMgZm9yIERvdWJsZVNpZGUgbWF0ZXJpYWxzXG4gICAgICAvLyBpbnRyb2R1Y2VkIGJ5IFRocmVlLmpzIGluIHIxMzAgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIxOTY3XG4gICAgICBjb25zdCBmcm9udCA9IG5ldyB0aHJlZS5QbGFuZUdlb21ldHJ5KDEsIDEsIGRldGFpbCwgZGV0YWlsKTtcbiAgICAgIGNvbnN0IGJhY2sgPSBmcm9udC5jbG9uZSgpO1xuICAgICAgY29uc3QgZnJvbnRBdHRycyA9IGZyb250LmF0dHJpYnV0ZXM7XG4gICAgICBjb25zdCBiYWNrQXR0cnMgPSBiYWNrLmF0dHJpYnV0ZXM7XG4gICAgICBjb25zdCBjb21iaW5lZCA9IG5ldyB0aHJlZS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgY29uc3QgdmVydENvdW50ID0gZnJvbnRBdHRycy51di5jb3VudDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydENvdW50OyBpKyspIHtcbiAgICAgICAgYmFja0F0dHJzLnBvc2l0aW9uLmFycmF5W2kgKiAzXSAqPSAtMTsgLy8gZmxpcCBwb3NpdGlvbiB4XG4gICAgICAgIGJhY2tBdHRycy5ub3JtYWwuYXJyYXlbaSAqIDMgKyAyXSAqPSAtMTsgLy8gZmxpcCBub3JtYWwgelxuICAgICAgfVxuICAgICAgWydwb3NpdGlvbicsICdub3JtYWwnLCAndXYnXS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBjb21iaW5lZC5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IHRocmVlLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgICAgWy4uLmZyb250QXR0cnNbbmFtZV0uYXJyYXksIC4uLmJhY2tBdHRyc1tuYW1lXS5hcnJheV0sXG4gICAgICAgICAgZnJvbnRBdHRyc1tuYW1lXS5pdGVtU2l6ZSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgY29tYmluZWQuc2V0SW5kZXgoWy4uLmZyb250LmluZGV4LmFycmF5LCAuLi5iYWNrLmluZGV4LmFycmF5Lm1hcChuID0+IG4gKyB2ZXJ0Q291bnQpXSk7XG4gICAgICBjb21iaW5lZC50cmFuc2xhdGUoMC41LCAwLjUsIDApO1xuICAgICAgZ2VvbSA9IHRlbXBsYXRlR2VvbWV0cmllc1tkZXRhaWxdID0gY29tYmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBnZW9tXG4gIH1cblxuICBjb25zdCBnbHlwaEJvdW5kc0F0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaEJvdW5kcyc7XG4gIGNvbnN0IGdseXBoSW5kZXhBdHRyTmFtZSA9ICdhVHJvaWthR2x5cGhJbmRleCc7XG4gIGNvbnN0IGdseXBoQ29sb3JBdHRyTmFtZSA9ICdhVHJvaWthR2x5cGhDb2xvcic7XG5cbiAgLyoqXG4gIEBjbGFzcyBHbHlwaHNHZW9tZXRyeVxuXG4gIEEgc3BlY2lhbGl6ZWQgR2VvbWV0cnkgZm9yIHJlbmRlcmluZyBhIHNldCBvZiB0ZXh0IGdseXBocy4gVXNlcyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSB0b1xuICByZW5kZXIgdGhlIGdseXBocyB1c2luZyBHUFUgaW5zdGFuY2luZyBvZiBhIHNpbmdsZSBxdWFkLCByYXRoZXIgdGhhbiBjb25zdHJ1Y3RpbmcgYSB3aG9sZVxuICBnZW9tZXRyeSB3aXRoIHZlcnRpY2VzLCBmb3IgbXVjaCBzbWFsbGVyIGF0dHJpYnV0ZSBhcnJheWJ1ZmZlcnMgYWNjb3JkaW5nIHRvIHRoaXMgbWF0aDpcblxuICAgIFdoZXJlIE4gPSBudW1iZXIgb2YgZ2x5cGhzLi4uXG5cbiAgICBJbnN0YW5jZWQ6XG4gICAgLSBwb3NpdGlvbjogNCAqIDNcbiAgICAtIGluZGV4OiAyICogM1xuICAgIC0gbm9ybWFsOiA0ICogM1xuICAgIC0gdXY6IDQgKiAyXG4gICAgLSBnbHlwaCB4L3kgYm91bmRzOiBOICogNFxuICAgIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgICA9IDVOICsgMzhcblxuICAgIE5vbi1pbnN0YW5jZWQ6XG4gICAgLSBwb3NpdGlvbjogTiAqIDQgKiAzXG4gICAgLSBpbmRleDogTiAqIDIgKiAzXG4gICAgLSBub3JtYWw6IE4gKiA0ICogM1xuICAgIC0gdXY6IE4gKiA0ICogMlxuICAgIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgICA9IDM5TlxuXG4gIEEgZG93bnNpZGUgb2YgdGhpcyBpcyB0aGUgcmFyZS1idXQtcG9zc2libGUgbGFjayBvZiB0aGUgaW5zdGFuY2VkIGFycmF5cyBleHRlbnNpb24sXG4gIHdoaWNoIHdlIGNvdWxkIHBvdGVudGlhbGx5IHdvcmsgYXJvdW5kIHdpdGggYSBmYWxsYmFjayBub24taW5zdGFuY2VkIGltcGxlbWVudGF0aW9uLlxuXG4gICovXG4gIGNsYXNzIEdseXBoc0dlb21ldHJ5IGV4dGVuZHMgdGhyZWUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcblxuICAgICAgdGhpcy5kZXRhaWwgPSAxO1xuICAgICAgdGhpcy5jdXJ2ZVJhZGl1cyA9IDA7XG5cbiAgICAgIC8vIERlZmluZSBncm91cHMgZm9yIHJlbmRlcmluZyB0ZXh0IG91dGxpbmUgYXMgYSBzZXBhcmF0ZSBwYXNzOyB0aGVzZSB3aWxsIG9ubHlcbiAgICAgIC8vIGJlIHVzZWQgd2hlbiB0aGUgYG1hdGVyaWFsYCBnZXR0ZXIgcmV0dXJucyBhbiBhcnJheSwgaS5lLiBvdXRsaW5lV2lkdGggPiAwLlxuICAgICAgdGhpcy5ncm91cHMgPSBbXG4gICAgICAgIHtzdGFydDogMCwgY291bnQ6IEluZmluaXR5LCBtYXRlcmlhbEluZGV4OiAwfSxcbiAgICAgICAge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHksIG1hdGVyaWFsSW5kZXg6IDF9XG4gICAgICBdO1xuXG4gICAgICAvLyBQcmVhbGxvY2F0ZSBlbXB0eSBib3VuZGluZyBvYmplY3RzXG4gICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IHRocmVlLlNwaGVyZSgpO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyB0aHJlZS5Cb3gzKCk7XG4gICAgfVxuXG4gICAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlICgpIHtcbiAgICAgIC8vIE5vLW9wOyB3ZSdsbCBzeW5jIHRoZSBib3VuZGluZ1NwaGVyZSBwcm9hY3RpdmVseSB3aGVuIG5lZWRlZC5cbiAgICB9XG5cbiAgICBjb21wdXRlQm91bmRpbmdCb3goKSB7XG4gICAgICAvLyBOby1vcDsgd2UnbGwgc3luYyB0aGUgYm91bmRpbmdCb3ggcHJvYWN0aXZlbHkgd2hlbiBuZWVkZWQuXG4gICAgfVxuXG4gICAgLy8gU2luY2Ugb3VyIGJhc2UgZ2VvbWV0cnkgY29udGFpbnMgdHJpYW5nbGVzIGZvciBib3RoIGZyb250IGFuZCBiYWNrIHNpZGVzLCB3ZSBjYW4gZW11bGF0ZVxuICAgIC8vIHRoZSBcInNpZGVcIiBieSByZXN0cmljdGluZyB0aGUgZHJhdyByYW5nZS5cbiAgICBzZXRTaWRlKHNpZGUpIHtcbiAgICAgIGNvbnN0IHZlcnRzID0gdGhpcy5nZXRJbmRleCgpLmNvdW50O1xuICAgICAgdGhpcy5zZXREcmF3UmFuZ2Uoc2lkZSA9PT0gdGhyZWUuQmFja1NpZGUgPyB2ZXJ0cyAvIDIgOiAwLCBzaWRlID09PSB0aHJlZS5Eb3VibGVTaWRlID8gdmVydHMgOiB2ZXJ0cyAvIDIpO1xuICAgIH1cblxuICAgIHNldCBkZXRhaWwoZGV0YWlsKSB7XG4gICAgICBpZiAoZGV0YWlsICE9PSB0aGlzLl9kZXRhaWwpIHtcbiAgICAgICAgdGhpcy5fZGV0YWlsID0gZGV0YWlsO1xuICAgICAgICBpZiAodHlwZW9mIGRldGFpbCAhPT0gJ251bWJlcicgfHwgZGV0YWlsIDwgMSkge1xuICAgICAgICAgIGRldGFpbCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRwbCA9IGdldFRlbXBsYXRlR2VvbWV0cnkoZGV0YWlsKVxuICAgICAgICA7Wydwb3NpdGlvbicsICdub3JtYWwnLCAndXYnXS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyXSA9IHRwbC5hdHRyaWJ1dGVzW2F0dHJdLmNsb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldEluZGV4KHRwbC5nZXRJbmRleCgpLmNsb25lKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGV0YWlsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RldGFpbFxuICAgIH1cblxuICAgIHNldCBjdXJ2ZVJhZGl1cyhyKSB7XG4gICAgICBpZiAociAhPT0gdGhpcy5fY3VydmVSYWRpdXMpIHtcbiAgICAgICAgdGhpcy5fY3VydmVSYWRpdXMgPSByO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1cnZlUmFkaXVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnZlUmFkaXVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBnZW9tZXRyeSBmb3IgYSBuZXcgc2V0IG9mIGdseXBocy5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZ2x5cGhCb3VuZHMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBwbGFuYXIgYm91bmRzIGZvciBhbGwgZ2x5cGhzXG4gICAgICogICAgICAgIHRvIGJlIHJlbmRlcmVkLCA0IGVudHJpZXMgZm9yIGVhY2ggZ2x5cGg6IHgxLHgyLHkxLHkxXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGdseXBoQXRsYXNJbmRpY2VzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgaW5kZXggb2YgZWFjaCBnbHlwaCB3aXRoaW5cbiAgICAgKiAgICAgICAgdGhlIFNERiBhdGxhcyB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJsb2NrQm91bmRzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgW21pblgsIG1pblksIG1heFgsIG1heFldIGFjcm9zcyBhbGwgZ2x5cGhzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NodW5rZWRCb3VuZHNdIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIGJvdW5kcyBmb3IgZWFjaCBjaHVuayBvZiBOXG4gICAgICogICAgICAgIGNvbnNlY3V0aXZlIGdseXBoczogYHtzdGFydDpOLCBlbmQ6TiwgcmVjdDpbbWluWCwgbWluWSwgbWF4WCwgbWF4WV19YC4gVGhpcyBjYW4gYmVcbiAgICAgKiAgICAgICAgdXNlZCB3aXRoIGBhcHBseUNsaXBSZWN0YCB0byBjaG9vc2UgYW4gb3B0aW1pemVkIGBpbnN0YW5jZUNvdW50YC5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtnbHlwaENvbG9yc10gLSBBbiBhcnJheSBob2xkaW5nIHIsZyxiIHZhbHVlcyBmb3IgZWFjaCBnbHlwaC5cbiAgICAgKi9cbiAgICB1cGRhdGVHbHlwaHMoZ2x5cGhCb3VuZHMsIGdseXBoQXRsYXNJbmRpY2VzLCBibG9ja0JvdW5kcywgY2h1bmtlZEJvdW5kcywgZ2x5cGhDb2xvcnMpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgaW5zdGFuY2UgYXR0cmlidXRlc1xuICAgICAgdXBkYXRlQnVmZmVyQXR0cih0aGlzLCBnbHlwaEJvdW5kc0F0dHJOYW1lLCBnbHlwaEJvdW5kcywgNCk7XG4gICAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoSW5kZXhBdHRyTmFtZSwgZ2x5cGhBdGxhc0luZGljZXMsIDEpO1xuICAgICAgdXBkYXRlQnVmZmVyQXR0cih0aGlzLCBnbHlwaENvbG9yQXR0ck5hbWUsIGdseXBoQ29sb3JzLCAzKTtcbiAgICAgIHRoaXMuX2Jsb2NrQm91bmRzID0gYmxvY2tCb3VuZHM7XG4gICAgICB0aGlzLl9jaHVua2VkQm91bmRzID0gY2h1bmtlZEJvdW5kcztcbiAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IGdseXBoQXRsYXNJbmRpY2VzLmxlbmd0aDtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICAgIH1cblxuICAgIF91cGRhdGVCb3VuZHMoKSB7XG4gICAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ibG9ja0JvdW5kcztcbiAgICAgIGlmIChib3VuZHMpIHtcbiAgICAgICAgY29uc3QgeyBjdXJ2ZVJhZGl1cywgYm91bmRpbmdCb3g6IGJib3ggfSA9IHRoaXM7XG4gICAgICAgIGlmIChjdXJ2ZVJhZGl1cykge1xuICAgICAgICAgIGNvbnN0IHsgUEksIGZsb29yLCBtaW4sIG1heCwgc2luLCBjb3MgfSA9IE1hdGg7XG4gICAgICAgICAgY29uc3QgaGFsZlBpID0gUEkgLyAyO1xuICAgICAgICAgIGNvbnN0IHR3b1BpID0gUEkgKiAyO1xuICAgICAgICAgIGNvbnN0IGFic1IgPSBNYXRoLmFicyhjdXJ2ZVJhZGl1cyk7XG4gICAgICAgICAgY29uc3QgbGVmdEFuZ2xlID0gYm91bmRzWzBdIC8gYWJzUjtcbiAgICAgICAgICBjb25zdCByaWdodEFuZ2xlID0gYm91bmRzWzJdIC8gYWJzUjtcbiAgICAgICAgICBjb25zdCBtaW5YID0gZmxvb3IoKGxlZnRBbmdsZSArIGhhbGZQaSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgaGFsZlBpKSAvIHR3b1BpKVxuICAgICAgICAgICAgPyAtYWJzUiA6IG1pbihzaW4obGVmdEFuZ2xlKSAqIGFic1IsIHNpbihyaWdodEFuZ2xlKSAqIGFic1IpO1xuICAgICAgICAgIGNvbnN0IG1heFggPSBmbG9vcigobGVmdEFuZ2xlIC0gaGFsZlBpKSAvIHR3b1BpKSAhPT0gZmxvb3IoKHJpZ2h0QW5nbGUgLSBoYWxmUGkpIC8gdHdvUGkpXG4gICAgICAgICAgICA/IGFic1IgOiBtYXgoc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgICBjb25zdCBtYXhaID0gZmxvb3IoKGxlZnRBbmdsZSArIFBJKSAvIHR3b1BpKSAhPT0gZmxvb3IoKHJpZ2h0QW5nbGUgKyBQSSkgLyB0d29QaSlcbiAgICAgICAgICAgID8gYWJzUiAqIDIgOiBtYXgoYWJzUiAtIGNvcyhsZWZ0QW5nbGUpICogYWJzUiwgYWJzUiAtIGNvcyhyaWdodEFuZ2xlKSAqIGFic1IpO1xuICAgICAgICAgIGJib3gubWluLnNldChtaW5YLCBib3VuZHNbMV0sIGN1cnZlUmFkaXVzIDwgMCA/IC1tYXhaIDogMCk7XG4gICAgICAgICAgYmJveC5tYXguc2V0KG1heFgsIGJvdW5kc1szXSwgY3VydmVSYWRpdXMgPCAwID8gMCA6IG1heFopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJib3gubWluLnNldChib3VuZHNbMF0sIGJvdW5kc1sxXSwgMCk7XG4gICAgICAgICAgYmJveC5tYXguc2V0KGJvdW5kc1syXSwgYm91bmRzWzNdLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBiYm94LmdldEJvdW5kaW5nU3BoZXJlKHRoaXMuYm91bmRpbmdTcGhlcmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgY2xpcHBpbmcgcmVjdCwgYW5kIHRoZSBjaHVua2VkQm91bmRzIGZyb20gdGhlIGxhc3QgdXBkYXRlR2x5cGhzIGNhbGwsIGNob29zZSB0aGUgbG93ZXN0XG4gICAgICogYGluc3RhbmNlQ291bnRgIHRoYXQgd2lsbCBzaG93IGFsbCBnbHlwaHMgd2l0aGluIHRoZSBjbGlwcGVkIHZpZXcuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uXG4gICAgICogZm9yIGxvbmcgYmxvY2tzIG9mIHRleHQgdGhhdCBhcmUgY2xpcHBlZCwgdG8gc2tpcCB2ZXJ0ZXggc2hhZGVyIGV2YWx1YXRpb24gZm9yIGdseXBocyB0aGF0IHdvdWxkXG4gICAgICogYmUgY2xpcHBlZCBhbnl3YXkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgc2luY2UgYGRyYXdFbGVtZW50c0luc3RhbmNlZFtBTkdMRV1gIG9ubHkgYWNjZXB0cyBhbiBpbnN0YW5jZSBjb3VudCBhbmQgbm90IGEgc3RhcnRpbmdcbiAgICAgKiBvZmZzZXQsIHRoaXMgb3B0aW1pemF0aW9uIGJlY29tZXMgbGVzcyBlZmZlY3RpdmUgYXMgdGhlIGNsaXBSZWN0IG1vdmVzIGNsb3NlciB0byB0aGUgZW5kIG9mIHRoZVxuICAgICAqIHRleHQgYmxvY2suIFdlIGNvdWxkIGZpeCB0aGF0IGJ5IHN3aXRjaGluZyBmcm9tIGluc3RhbmNpbmcgdG8gYSBmdWxsIGdlb21ldHJ5IHdpdGggYSBkcmF3UmFuZ2UsXG4gICAgICogYnV0IGF0IHRoZSBleHBlbnNlIG9mIG11Y2ggbGFyZ2VyIGF0dHJpYnV0ZSBidWZmZXJzIChzZWUgY2xhc3Nkb2MgYWJvdmUuKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtWZWN0b3I0fSBjbGlwUmVjdFxuICAgICAqL1xuICAgIGFwcGx5Q2xpcFJlY3QoY2xpcFJlY3QpIHtcbiAgICAgIGxldCBjb3VudCA9IHRoaXMuZ2V0QXR0cmlidXRlKGdseXBoSW5kZXhBdHRyTmFtZSkuY291bnQ7XG4gICAgICBsZXQgY2h1bmtzID0gdGhpcy5fY2h1bmtlZEJvdW5kcztcbiAgICAgIGlmIChjaHVua3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNodW5rcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBjb3VudCA9IGNodW5rc1tpXS5lbmQ7XG4gICAgICAgICAgbGV0IHJlY3QgPSBjaHVua3NbaV0ucmVjdDtcbiAgICAgICAgICAvLyBub3RlOiBib3RoIHJlY3RzIGFyZSBsLWItci10XG4gICAgICAgICAgaWYgKHJlY3RbMV0gPCBjbGlwUmVjdC53ICYmIHJlY3RbM10gPiBjbGlwUmVjdC55ICYmIHJlY3RbMF0gPCBjbGlwUmVjdC56ICYmIHJlY3RbMl0gPiBjbGlwUmVjdC54KSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gY291bnQ7XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiB1cGRhdGVCdWZmZXJBdHRyKGdlb20sIGF0dHJOYW1lLCBuZXdBcnJheSwgaXRlbVNpemUpIHtcbiAgICBjb25zdCBhdHRyID0gZ2VvbS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgIGlmIChuZXdBcnJheSkge1xuICAgICAgLy8gSWYgbGVuZ3RoIGlzbid0IGNoYW5naW5nLCBqdXN0IHVwZGF0ZSB0aGUgYXR0cmlidXRlJ3MgYXJyYXkgZGF0YVxuICAgICAgaWYgKGF0dHIgJiYgYXR0ci5hcnJheS5sZW5ndGggPT09IG5ld0FycmF5Lmxlbmd0aCkge1xuICAgICAgICBhdHRyLmFycmF5LnNldChuZXdBcnJheSk7XG4gICAgICAgIGF0dHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VvbS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIG5ldyB0aHJlZS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUobmV3QXJyYXksIGl0ZW1TaXplKSk7XG4gICAgICAgIC8vIElmIHRoZSBuZXcgYXR0cmlidXRlIGhhcyBhIGRpZmZlcmVudCBzaXplLCB3ZSBhbHNvIGhhdmUgdG8gKGFzIG9mIHIxMTcpIG1hbnVhbGx5IGNsZWFyIHRoZVxuICAgICAgICAvLyBpbnRlcm5hbCBjYWNoZWQgbWF4IGluc3RhbmNlIGNvdW50LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTk3MDZcbiAgICAgICAgLy8gSXQncyB1bmNsZWFyIGlmIHRoaXMgaXMgYSB0aHJlZWpzIGJ1ZyBvciBhIHRydWx5IHVuc3VwcG9ydGVkIHNjZW5hcmlvOyBkaXNjdXNzaW9uIGluXG4gICAgICAgIC8vIHRoYXQgdGlja2V0IGlzIGFtYmlndW91cyBhcyB0byB3aGV0aGVyIHJlcGxhY2luZyBhIEJ1ZmZlckF0dHJpYnV0ZSB3aXRoIG9uZSBvZiBhXG4gICAgICAgIC8vIGRpZmZlcmVudCBzaXplIGlzIHN1cHBvcnRlZCwgYnV0IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8xNzQxOCBzdHJvbmdseVxuICAgICAgICAvLyBpbXBsaWVzIGl0IHNob3VsZCBiZSBzdXBwb3J0ZWQuIEl0J3MgcG9zc2libGUgd2UgbmVlZCB0b1xuICAgICAgICBkZWxldGUgZ2VvbS5fbWF4SW5zdGFuY2VDb3VudDsgLy9mb3IgcjExNyssIGNvdWxkIGJlIGZyYWdpbGVcbiAgICAgICAgZ2VvbS5kaXNwb3NlKCk7IC8vZm9yIHIxMTgrLCBtb3JlIHJvYnVzdCBmZWVsaW5nLCBidXQgbW9yZSBoZWF2eS1oYW5kZWQgdGhhbiBJJ2QgbGlrZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0cikge1xuICAgICAgZ2VvbS5kZWxldGVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGxhbmd1YWdlPUdMU0xcbiAgY29uc3QgVkVSVEVYX0RFRlMgPSBgXG51bmlmb3JtIHZlYzIgdVRyb2lrYVNERlRleHR1cmVTaXplO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGR2x5cGhTaXplO1xudW5pZm9ybSB2ZWM0IHVUcm9pa2FUb3RhbEJvdW5kcztcbnVuaWZvcm0gdmVjNCB1VHJvaWthQ2xpcFJlY3Q7XG51bmlmb3JtIG1hdDMgdVRyb2lrYU9yaWVudDtcbnVuaWZvcm0gYm9vbCB1VHJvaWthVXNlR2x5cGhDb2xvcnM7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FEaXN0YW5jZU9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUJsdXJSYWRpdXM7XG51bmlmb3JtIHZlYzIgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthQ3VydmVSYWRpdXM7XG5hdHRyaWJ1dGUgdmVjNCBhVHJvaWthR2x5cGhCb3VuZHM7XG5hdHRyaWJ1dGUgZmxvYXQgYVRyb2lrYUdseXBoSW5kZXg7XG5hdHRyaWJ1dGUgdmVjMyBhVHJvaWthR2x5cGhDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhVVjtcbnZhcnlpbmcgdmVjNCB2VHJvaWthVGV4dHVyZVVWQm91bmRzO1xudmFyeWluZyBmbG9hdCB2VHJvaWthVGV4dHVyZUNoYW5uZWw7XG52YXJ5aW5nIHZlYzMgdlRyb2lrYUdseXBoQ29sb3I7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoRGltZW5zaW9ucztcbmA7XG5cbiAgLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG4gIGNvbnN0IFZFUlRFWF9UUkFOU0ZPUk0gPSBgXG52ZWM0IGJvdW5kcyA9IGFUcm9pa2FHbHlwaEJvdW5kcztcbmJvdW5kcy54eiArPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueDtcbmJvdW5kcy55dyAtPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueTtcblxudmVjNCBvdXRsaW5lQm91bmRzID0gdmVjNChcbiAgYm91bmRzLnh5IC0gdVRyb2lrYURpc3RhbmNlT2Zmc2V0IC0gdVRyb2lrYUJsdXJSYWRpdXMsXG4gIGJvdW5kcy56dyArIHVUcm9pa2FEaXN0YW5jZU9mZnNldCArIHVUcm9pa2FCbHVyUmFkaXVzXG4pO1xudmVjNCBjbGlwcGVkQm91bmRzID0gdmVjNChcbiAgY2xhbXAob3V0bGluZUJvdW5kcy54eSwgdVRyb2lrYUNsaXBSZWN0Lnh5LCB1VHJvaWthQ2xpcFJlY3QuencpLFxuICBjbGFtcChvdXRsaW5lQm91bmRzLnp3LCB1VHJvaWthQ2xpcFJlY3QueHksIHVUcm9pa2FDbGlwUmVjdC56dylcbik7XG5cbnZlYzIgY2xpcHBlZFhZID0gKG1peChjbGlwcGVkQm91bmRzLnh5LCBjbGlwcGVkQm91bmRzLnp3LCBwb3NpdGlvbi54eSkgLSBib3VuZHMueHkpIC8gKGJvdW5kcy56dyAtIGJvdW5kcy54eSk7XG5cbnBvc2l0aW9uLnh5ID0gbWl4KGJvdW5kcy54eSwgYm91bmRzLnp3LCBjbGlwcGVkWFkpO1xuXG51diA9IChwb3NpdGlvbi54eSAtIHVUcm9pa2FUb3RhbEJvdW5kcy54eSkgLyAodVRyb2lrYVRvdGFsQm91bmRzLnp3IC0gdVRyb2lrYVRvdGFsQm91bmRzLnh5KTtcblxuZmxvYXQgcmFkID0gdVRyb2lrYUN1cnZlUmFkaXVzO1xuaWYgKHJhZCAhPSAwLjApIHtcbiAgZmxvYXQgYW5nbGUgPSBwb3NpdGlvbi54IC8gcmFkO1xuICBwb3NpdGlvbi54eiA9IHZlYzIoc2luKGFuZ2xlKSAqIHJhZCwgcmFkIC0gY29zKGFuZ2xlKSAqIHJhZCk7XG4gIG5vcm1hbC54eiA9IHZlYzIoc2luKGFuZ2xlKSwgY29zKGFuZ2xlKSk7XG59XG4gIFxucG9zaXRpb24gPSB1VHJvaWthT3JpZW50ICogcG9zaXRpb247XG5ub3JtYWwgPSB1VHJvaWthT3JpZW50ICogbm9ybWFsO1xuXG52VHJvaWthR2x5cGhVViA9IGNsaXBwZWRYWS54eTtcbnZUcm9pa2FHbHlwaERpbWVuc2lvbnMgPSB2ZWMyKGJvdW5kc1syXSAtIGJvdW5kc1swXSwgYm91bmRzWzNdIC0gYm91bmRzWzFdKTtcblxuJHsnJy8qIE5PVEU6IGl0IHNlZW1zIGltcG9ydGFudCB0byBjYWxjdWxhdGUgdGhlIGdseXBoJ3MgYm91bmRpbmcgdGV4dHVyZSBVVnMgaGVyZSBpbiB0aGVcbiAgdmVydGV4IHNoYWRlciwgcmF0aGVyIHRoYW4gaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgYXMgdGhlIGxhdHRlciBnaXZlcyBzdHJhbmdlIGFydGlmYWN0c1xuICBvbiBzb21lIGdseXBocyAodGhvc2UgaW4gdGhlIGxlZnRtb3N0IHRleHR1cmUgY29sdW1uKSBvbiBzb21lIHN5c3RlbXMuIFRoZSBleGFjdCByZWFzb25cbiAgaXNuJ3QgdW5kZXJzdG9vZCBidXQgZG9pbmcgdGhpcyBoZXJlLCB0aGVuIG1peCgpLWluZyBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLCBzZWVtcyB0byB3b3JrLiAqL31cbmZsb2F0IHR4Q29scyA9IHVUcm9pa2FTREZUZXh0dXJlU2l6ZS54IC8gdVRyb2lrYVNERkdseXBoU2l6ZTtcbnZlYzIgdHhVdlBlclNxdWFyZSA9IHVUcm9pa2FTREZHbHlwaFNpemUgLyB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG52ZWMyIHR4U3RhcnRVViA9IHR4VXZQZXJTcXVhcmUgKiB2ZWMyKFxuICBtb2QoZmxvb3IoYVRyb2lrYUdseXBoSW5kZXggLyA0LjApLCB0eENvbHMpLFxuICBmbG9vcihmbG9vcihhVHJvaWthR2x5cGhJbmRleCAvIDQuMCkgLyB0eENvbHMpXG4pO1xudlRyb2lrYVRleHR1cmVVVkJvdW5kcyA9IHZlYzQodHhTdGFydFVWLCB2ZWMyKHR4U3RhcnRVVikgKyB0eFV2UGVyU3F1YXJlKTtcbnZUcm9pa2FUZXh0dXJlQ2hhbm5lbCA9IG1vZChhVHJvaWthR2x5cGhJbmRleCwgNC4wKTtcbmA7XG5cbiAgLy8gbGFuZ3VhZ2U9R0xTTFxuICBjb25zdCBGUkFHTUVOVF9ERUZTID0gYFxudW5pZm9ybSBzYW1wbGVyMkQgdVRyb2lrYVNERlRleHR1cmU7XG51bmlmb3JtIHZlYzIgdVRyb2lrYVNERlRleHR1cmVTaXplO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGR2x5cGhTaXplO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGRXhwb25lbnQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FEaXN0YW5jZU9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUZpbGxPcGFjaXR5O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthT3V0bGluZU9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FCbHVyUmFkaXVzO1xudW5pZm9ybSB2ZWMzIHVUcm9pa2FTdHJva2VDb2xvcjtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVN0cm9rZVdpZHRoO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlT3BhY2l0eTtcbnVuaWZvcm0gYm9vbCB1VHJvaWthU0RGRGVidWc7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoVVY7XG52YXJ5aW5nIHZlYzQgdlRyb2lrYVRleHR1cmVVVkJvdW5kcztcbnZhcnlpbmcgZmxvYXQgdlRyb2lrYVRleHR1cmVDaGFubmVsO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaERpbWVuc2lvbnM7XG5cbmZsb2F0IHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZShmbG9hdCBhbHBoYSkge1xuICAvLyBJbnZlcnNlIG9mIGV4cG9uZW50aWFsIGVuY29kaW5nIGluIHdlYmdsLXNkZi1nZW5lcmF0b3JcbiAgJHsnJy8qIFRPRE8gLSB0aGVyZSdzIHNvbWUgc2xpZ2h0IGluYWNjdXJhY3kgaGVyZSB3aGVuIGRlYWxpbmcgd2l0aCBpbnRlcnBvbGF0ZWQgYWxwaGEgdmFsdWVzOyB0aG9zZVxuICAgIGFyZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgd2hlcmUgdGhlIGVuY29kaW5nIGlzIGV4cG9uZW50aWFsLiBMb29rIGludG8gaW1wcm92aW5nIHRoaXMgYnkgcm91bmRpbmdcbiAgICB0byBuZWFyZXN0IDIgd2hvbGUgdGV4ZWxzLCBkZWNvZGluZyB0aG9zZSBleHBvbmVudGlhbCB2YWx1ZXMsIGFuZCBsaW5lYXJseSBpbnRlcnBvbGF0aW5nIHRoZSByZXN1bHQuXG4gICovfVxuICBmbG9hdCBtYXhEaW1lbnNpb24gPSBtYXgodlRyb2lrYUdseXBoRGltZW5zaW9ucy54LCB2VHJvaWthR2x5cGhEaW1lbnNpb25zLnkpO1xuICBmbG9hdCBhYnNEaXN0ID0gKDEuMCAtIHBvdygyLjAgKiAoYWxwaGEgPiAwLjUgPyAxLjAgLSBhbHBoYSA6IGFscGhhKSwgMS4wIC8gdVRyb2lrYVNERkV4cG9uZW50KSkgKiBtYXhEaW1lbnNpb247XG4gIGZsb2F0IHNpZ25lZERpc3QgPSBhYnNEaXN0ICogKGFscGhhID4gMC41ID8gLTEuMCA6IDEuMCk7XG4gIHJldHVybiBzaWduZWREaXN0O1xufVxuXG5mbG9hdCB0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh2ZWMyIGdseXBoVVYpIHtcbiAgdmVjMiB0ZXh0dXJlVVYgPSBtaXgodlRyb2lrYVRleHR1cmVVVkJvdW5kcy54eSwgdlRyb2lrYVRleHR1cmVVVkJvdW5kcy56dywgZ2x5cGhVVik7XG4gIHZlYzQgcmdiYSA9IHRleHR1cmUyRCh1VHJvaWthU0RGVGV4dHVyZSwgdGV4dHVyZVVWKTtcbiAgZmxvYXQgY2ggPSBmbG9vcih2VHJvaWthVGV4dHVyZUNoYW5uZWwgKyAwLjUpOyAvL05PVEU6IGNhbid0IHVzZSByb3VuZCgpIGluIFdlYkdMMVxuICByZXR1cm4gY2ggPT0gMC4wID8gcmdiYS5yIDogY2ggPT0gMS4wID8gcmdiYS5nIDogY2ggPT0gMi4wID8gcmdiYS5iIDogcmdiYS5hO1xufVxuXG5mbG9hdCB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZSh2ZWMyIHV2KSB7XG4gIHJldHVybiB0cm9pa2FTZGZWYWx1ZVRvU2lnbmVkRGlzdGFuY2UodHJvaWthR2x5cGhVdlRvU2RmVmFsdWUodXYpKTtcbn1cblxuZmxvYXQgdHJvaWthR2V0QUFEaXN0KCkge1xuICAkeycnLypcbiAgICBXaGVuIHRoZSBzdGFuZGFyZCBkZXJpdmF0aXZlcyBleHRlbnNpb24gaXMgYXZhaWxhYmxlLCB3ZSBjaG9vc2UgYW4gYW50aWFsaWFzaW5nIGFscGhhIHRocmVzaG9sZCBiYXNlZFxuICAgIG9uIHRoZSBwb3RlbnRpYWwgY2hhbmdlIGluIHRoZSBTREYncyBhbHBoYSBmcm9tIHRoaXMgZnJhZ21lbnQgdG8gaXRzIG5laWdoYm9yLiBUaGlzIHN0cmF0ZWd5IG1heGltaXplcyBcbiAgICByZWFkYWJpbGl0eSBhbmQgZWRnZSBjcmlzcG5lc3MgYXQgYWxsIHNpemVzIGFuZCBzY3JlZW4gcmVzb2x1dGlvbnMuXG4gICovfVxuICAjaWYgZGVmaW5lZChHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMpIHx8IF9fVkVSU0lPTl9fID49IDMwMFxuICByZXR1cm4gbGVuZ3RoKGZ3aWR0aCh2VHJvaWthR2x5cGhVViAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpKSAqIDAuNTtcbiAgI2Vsc2VcbiAgcmV0dXJuIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueCAvIDY0LjA7XG4gICNlbmRpZlxufVxuXG5mbG9hdCB0cm9pa2FHZXRGcmFnRGlzdFZhbHVlKCkge1xuICB2ZWMyIGNsYW1wZWRHbHlwaFVWID0gY2xhbXAodlRyb2lrYUdseXBoVVYsIDAuNSAvIHVUcm9pa2FTREZHbHlwaFNpemUsIDEuMCAtIDAuNSAvIHVUcm9pa2FTREZHbHlwaFNpemUpO1xuICBmbG9hdCBkaXN0YW5jZSA9IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKGNsYW1wZWRHbHlwaFVWKTtcbiBcbiAgLy8gRXh0cmFwb2xhdGUgZGlzdGFuY2Ugd2hlbiBvdXRzaWRlIGJvdW5kczpcbiAgZGlzdGFuY2UgKz0gY2xhbXBlZEdseXBoVVYgPT0gdlRyb2lrYUdseXBoVVYgPyAwLjAgOiBcbiAgICBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG5cbiAgJHsnJy8qIFxuICAvLyBUT0RPIG1vcmUgcmVmaW5lZCBleHRyYXBvbGF0ZWQgZGlzdGFuY2UgYnkgYWRqdXN0aW5nIGZvciBhbmdsZSBvZiBncmFkaWVudCBhdCBlZGdlLi4uXG4gIC8vIFRoaXMgaGFzIHBvdGVudGlhbCBidXQgY3VycmVudGx5IGdpdmVzIHZlcnkgamFnZ2VkIGV4dGVuc2lvbnMsIG1heWJlIGR1ZSB0byBwcmVjaXNpb24gaXNzdWVzP1xuICBmbG9hdCB1dlN0ZXAgPSAxLjAgLyB1VHJvaWthU0RGR2x5cGhTaXplO1xuICB2ZWMyIG5laWdoYm9yMVVWID0gY2xhbXBlZEdseXBoVVYgKyAoXG4gICAgdlRyb2lrYUdseXBoVVYueCAhPSBjbGFtcGVkR2x5cGhVVi54ID8gdmVjMigwLjAsIHV2U3RlcCAqIHNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIHNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueCksIDAuMCkgOlxuICAgIHZlYzIoMC4wKVxuICApO1xuICB2ZWMyIG5laWdoYm9yMlVWID0gY2xhbXBlZEdseXBoVVYgKyAoXG4gICAgdlRyb2lrYUdseXBoVVYueCAhPSBjbGFtcGVkR2x5cGhVVi54ID8gdmVjMigwLjAsIHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLnkpKSA6XG4gICAgdlRyb2lrYUdseXBoVVYueSAhPSBjbGFtcGVkR2x5cGhVVi55ID8gdmVjMih1dlN0ZXAgKiAtc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIGZsb2F0IG5laWdoYm9yMURpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IxVVYpO1xuICBmbG9hdCBuZWlnaGJvcjJEaXN0YW5jZSA9IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKG5laWdoYm9yMlVWKTtcbiAgZmxvYXQgZGlzdFRvVW5jbGFtcGVkID0gbGVuZ3RoKCh2VHJvaWthR2x5cGhVViAtIGNsYW1wZWRHbHlwaFVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBkaXN0VG9OZWlnaGJvciA9IGxlbmd0aCgoY2xhbXBlZEdseXBoVVYgLSBuZWlnaGJvcjFVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcbiAgZmxvYXQgZ3JhZGllbnRBbmdsZTEgPSBtaW4oYXNpbihhYnMobmVpZ2hib3IxRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBkaXN0VG9OZWlnaGJvciksIFBJIC8gMi4wKTtcbiAgZmxvYXQgZ3JhZGllbnRBbmdsZTIgPSBtaW4oYXNpbihhYnMobmVpZ2hib3IyRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBkaXN0VG9OZWlnaGJvciksIFBJIC8gMi4wKTtcbiAgZGlzdGFuY2UgKz0gKGNvcyhncmFkaWVudEFuZ2xlMSkgKyBjb3MoZ3JhZGllbnRBbmdsZTIpKSAvIDIuMCAqIGRpc3RUb1VuY2xhbXBlZDtcbiAgKi99XG5cbiAgcmV0dXJuIGRpc3RhbmNlO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRFZGdlQWxwaGEoZmxvYXQgZGlzdGFuY2UsIGZsb2F0IGRpc3RhbmNlT2Zmc2V0LCBmbG9hdCBhYURpc3QpIHtcbiAgI2lmIGRlZmluZWQoSVNfREVQVEhfTUFURVJJQUwpIHx8IGRlZmluZWQoSVNfRElTVEFOQ0VfTUFURVJJQUwpXG4gIGZsb2F0IGFscGhhID0gc3RlcCgtZGlzdGFuY2VPZmZzZXQsIC1kaXN0YW5jZSk7XG4gICNlbHNlXG5cbiAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKFxuICAgIGRpc3RhbmNlT2Zmc2V0ICsgYWFEaXN0LFxuICAgIGRpc3RhbmNlT2Zmc2V0IC0gYWFEaXN0LFxuICAgIGRpc3RhbmNlXG4gICk7XG4gICNlbmRpZlxuXG4gIHJldHVybiBhbHBoYTtcbn1cbmA7XG5cbiAgLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG4gIGNvbnN0IEZSQUdNRU5UX1RSQU5TRk9STSA9IGBcbmZsb2F0IGFhRGlzdCA9IHRyb2lrYUdldEFBRGlzdCgpO1xuZmxvYXQgZnJhZ0Rpc3RhbmNlID0gdHJvaWthR2V0RnJhZ0Rpc3RWYWx1ZSgpO1xuZmxvYXQgZWRnZUFscGhhID0gdVRyb2lrYVNERkRlYnVnID9cbiAgdHJvaWthR2x5cGhVdlRvU2RmVmFsdWUodlRyb2lrYUdseXBoVVYpIDpcbiAgdHJvaWthR2V0RWRnZUFscGhhKGZyYWdEaXN0YW5jZSwgdVRyb2lrYURpc3RhbmNlT2Zmc2V0LCBtYXgoYWFEaXN0LCB1VHJvaWthQmx1clJhZGl1cykpO1xuXG4jaWYgIWRlZmluZWQoSVNfREVQVEhfTUFURVJJQUwpICYmICFkZWZpbmVkKElTX0RJU1RBTkNFX01BVEVSSUFMKVxudmVjNCBmaWxsUkdCQSA9IGdsX0ZyYWdDb2xvcjtcbmZpbGxSR0JBLmEgKj0gdVRyb2lrYUZpbGxPcGFjaXR5O1xudmVjNCBzdHJva2VSR0JBID0gdVRyb2lrYVN0cm9rZVdpZHRoID09IDAuMCA/IGZpbGxSR0JBIDogdmVjNCh1VHJvaWthU3Ryb2tlQ29sb3IsIHVUcm9pa2FTdHJva2VPcGFjaXR5KTtcbmlmIChmaWxsUkdCQS5hID09IDAuMCkgZmlsbFJHQkEucmdiID0gc3Ryb2tlUkdCQS5yZ2I7XG5nbF9GcmFnQ29sb3IgPSBtaXgoZmlsbFJHQkEsIHN0cm9rZVJHQkEsIHNtb290aHN0ZXAoXG4gIC11VHJvaWthU3Ryb2tlV2lkdGggLSBhYURpc3QsXG4gIC11VHJvaWthU3Ryb2tlV2lkdGggKyBhYURpc3QsXG4gIGZyYWdEaXN0YW5jZVxuKSk7XG5nbF9GcmFnQ29sb3IuYSAqPSBlZGdlQWxwaGE7XG4jZW5kaWZcblxuaWYgKGVkZ2VBbHBoYSA9PSAwLjApIHtcbiAgZGlzY2FyZDtcbn1cbmA7XG5cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWF0ZXJpYWwgZm9yIHJlbmRlcmluZyB0ZXh0LCBkZXJpdmVkIGZyb20gYSBiYXNlTWF0ZXJpYWxcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgY29uc3QgdGV4dE1hdGVyaWFsID0gdHJvaWthVGhyZWVVdGlscy5jcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsLCB7XG4gICAgICBjaGFpbmVkOiB0cnVlLFxuICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICBkZXJpdmF0aXZlczogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHVUcm9pa2FTREZUZXh0dXJlOiB7dmFsdWU6IG51bGx9LFxuICAgICAgICB1VHJvaWthU0RGVGV4dHVyZVNpemU6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjIoKX0sXG4gICAgICAgIHVUcm9pa2FTREZHbHlwaFNpemU6IHt2YWx1ZTogMH0sXG4gICAgICAgIHVUcm9pa2FTREZFeHBvbmVudDoge3ZhbHVlOiAwfSxcbiAgICAgICAgdVRyb2lrYVRvdGFsQm91bmRzOiB7dmFsdWU6IG5ldyB0aHJlZS5WZWN0b3I0KDAsMCwwLDApfSxcbiAgICAgICAgdVRyb2lrYUNsaXBSZWN0OiB7dmFsdWU6IG5ldyB0aHJlZS5WZWN0b3I0KDAsMCwwLDApfSxcbiAgICAgICAgdVRyb2lrYURpc3RhbmNlT2Zmc2V0OiB7dmFsdWU6IDB9LFxuICAgICAgICB1VHJvaWthT3V0bGluZU9wYWNpdHk6IHt2YWx1ZTogMH0sXG4gICAgICAgIHVUcm9pa2FGaWxsT3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgICAgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0OiB7dmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IyKCl9LFxuICAgICAgICB1VHJvaWthQ3VydmVSYWRpdXM6IHt2YWx1ZTogMH0sXG4gICAgICAgIHVUcm9pa2FCbHVyUmFkaXVzOiB7dmFsdWU6IDB9LFxuICAgICAgICB1VHJvaWthU3Ryb2tlV2lkdGg6IHt2YWx1ZTogMH0sXG4gICAgICAgIHVUcm9pa2FTdHJva2VDb2xvcjoge3ZhbHVlOiBuZXcgdGhyZWUuQ29sb3IoKX0sXG4gICAgICAgIHVUcm9pa2FTdHJva2VPcGFjaXR5OiB7dmFsdWU6IDF9LFxuICAgICAgICB1VHJvaWthT3JpZW50OiB7dmFsdWU6IG5ldyB0aHJlZS5NYXRyaXgzKCl9LFxuICAgICAgICB1VHJvaWthVXNlR2x5cGhDb2xvcnM6IHt2YWx1ZTogdHJ1ZX0sXG4gICAgICAgIHVUcm9pa2FTREZEZWJ1Zzoge3ZhbHVlOiBmYWxzZX1cbiAgICAgIH0sXG4gICAgICB2ZXJ0ZXhEZWZzOiBWRVJURVhfREVGUyxcbiAgICAgIHZlcnRleFRyYW5zZm9ybTogVkVSVEVYX1RSQU5TRk9STSxcbiAgICAgIGZyYWdtZW50RGVmczogRlJBR01FTlRfREVGUyxcbiAgICAgIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm06IEZSQUdNRU5UX1RSQU5TRk9STSxcbiAgICAgIGN1c3RvbVJld3JpdGVyKHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSkge1xuICAgICAgICBsZXQgdURpZmZ1c2VSRSA9IC9cXGJ1bmlmb3JtXFxzK3ZlYzNcXHMrZGlmZnVzZVxcYi87XG4gICAgICAgIGlmICh1RGlmZnVzZVJFLnRlc3QoZnJhZ21lbnRTaGFkZXIpKSB7XG4gICAgICAgICAgLy8gUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIGBkaWZmdXNlYCB3aXRoIG91ciB2YXJ5aW5nXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UodURpZmZ1c2VSRSwgJ3ZhcnlpbmcgdmVjMyB2VHJvaWthR2x5cGhDb2xvcicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxiZGlmZnVzZVxcYi9nLCAndlRyb2lrYUdseXBoQ29sb3InKTtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZlcnRleCBzaGFkZXIgZGVjbGFyZXMgdGhlIHVuaWZvcm0gc28gd2UgY2FuIGdyYWIgaXQgYXMgYSBmYWxsYmFja1xuICAgICAgICAgIGlmICghdURpZmZ1c2VSRS50ZXN0KHZlcnRleFNoYWRlcikpIHtcbiAgICAgICAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAgICAgICB0cm9pa2FUaHJlZVV0aWxzLnZvaWRNYWluUmVnRXhwLFxuICAgICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxuJCZcXG52VHJvaWthR2x5cGhDb2xvciA9IHVUcm9pa2FVc2VHbHlwaENvbG9ycyA/IGFUcm9pa2FHbHlwaENvbG9yIC8gMjU1LjAgOiBkaWZmdXNlO1xcbidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRm9yY2UgdHJhbnNwYXJlbmN5IC0gVE9ETyBpcyB0aGlzIHJlYXNvbmFibGU/XG4gICAgdGV4dE1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRleHRNYXRlcmlhbCwge1xuICAgICAgaXNUcm9pa2FUZXh0TWF0ZXJpYWw6IHt2YWx1ZTogdHJ1ZX0sXG5cbiAgICAgIC8vIFdlYkdMU2hhZG93TWFwIHJldmVyc2VzIHRoZSBzaWRlIG9mIHRoZSBzaGFkb3cgbWF0ZXJpYWwgYnkgZGVmYXVsdCwgd2hpY2ggZmFpbHNcbiAgICAgIC8vIGZvciBwbGFuZXMsIHNvIGhlcmUgd2UgZm9yY2UgdGhlIGBzaGFkb3dTaWRlYCB0byBhbHdheXMgbWF0Y2ggdGhlIG1haW4gc2lkZS5cbiAgICAgIHNoYWRvd1NpZGU6IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNpZGVcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KCkge1xuICAgICAgICAgIC8vbm8tb3BcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRleHRNYXRlcmlhbFxuICB9XG5cbiAgY29uc3QgZGVmYXVsdE1hdGVyaWFsID0gLyojX19QVVJFX18qLyBuZXcgdGhyZWUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICBzaWRlOiB0aHJlZS5Eb3VibGVTaWRlLFxuICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gIH0pO1xuICBjb25zdCBkZWZhdWx0U3Ryb2tlQ29sb3IgPSAweDgwODA4MDtcblxuICBjb25zdCB0ZW1wTWF0NCA9IC8qI19fUFVSRV9fKi8gbmV3IHRocmVlLk1hdHJpeDQoKTtcbiAgY29uc3QgdGVtcFZlYzNhID0gLyojX19QVVJFX18qLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wVmVjM2IgPSAvKiNfX1BVUkVfXyovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBBcnJheSA9IFtdO1xuICBjb25zdCBvcmlnaW4gPSAvKiNfX1BVUkVfXyovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gIGNvbnN0IGRlZmF1bHRPcmllbnQgPSAnK3greSc7XG5cbiAgZnVuY3Rpb24gZmlyc3Qobykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG8pID8gb1swXSA6IG9cbiAgfVxuXG4gIGxldCBnZXRGbGF0UmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gICAgY29uc3QgbWVzaCA9IG5ldyB0aHJlZS5NZXNoKFxuICAgICAgbmV3IHRocmVlLlBsYW5lR2VvbWV0cnkoMSwgMSksXG4gICAgICBkZWZhdWx0TWF0ZXJpYWxcbiAgICApO1xuICAgIGdldEZsYXRSYXljYXN0TWVzaCA9ICgpID0+IG1lc2g7XG4gICAgcmV0dXJuIG1lc2hcbiAgfTtcbiAgbGV0IGdldEN1cnZlZFJheWNhc3RNZXNoID0gKCkgPT4ge1xuICAgIGNvbnN0IG1lc2ggPSBuZXcgdGhyZWUuTWVzaChcbiAgICAgIG5ldyB0aHJlZS5QbGFuZUdlb21ldHJ5KDEsIDEsIDMyLCAxKSxcbiAgICAgIGRlZmF1bHRNYXRlcmlhbFxuICAgICk7XG4gICAgZ2V0Q3VydmVkUmF5Y2FzdE1lc2ggPSAoKSA9PiBtZXNoO1xuICAgIHJldHVybiBtZXNoXG4gIH07XG5cbiAgY29uc3Qgc3luY1N0YXJ0RXZlbnQgPSB7IHR5cGU6ICdzeW5jc3RhcnQnIH07XG4gIGNvbnN0IHN5bmNDb21wbGV0ZUV2ZW50ID0geyB0eXBlOiAnc3luY2NvbXBsZXRlJyB9O1xuXG4gIGNvbnN0IFNZTkNBQkxFX1BST1BTID0gW1xuICAgICdmb250JyxcbiAgICAnZm9udFNpemUnLFxuICAgICdsZXR0ZXJTcGFjaW5nJyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ21heFdpZHRoJyxcbiAgICAnb3ZlcmZsb3dXcmFwJyxcbiAgICAndGV4dCcsXG4gICAgJ2RpcmVjdGlvbicsXG4gICAgJ3RleHRBbGlnbicsXG4gICAgJ3RleHRJbmRlbnQnLFxuICAgICd3aGl0ZVNwYWNlJyxcbiAgICAnYW5jaG9yWCcsXG4gICAgJ2FuY2hvclknLFxuICAgICdjb2xvclJhbmdlcycsXG4gICAgJ3NkZkdseXBoU2l6ZSdcbiAgXTtcblxuICBjb25zdCBDT1BZQUJMRV9QUk9QUyA9IFNZTkNBQkxFX1BST1BTLmNvbmNhdChcbiAgICAnbWF0ZXJpYWwnLFxuICAgICdjb2xvcicsXG4gICAgJ2RlcHRoT2Zmc2V0JyxcbiAgICAnY2xpcFJlY3QnLFxuICAgICdjdXJ2ZVJhZGl1cycsXG4gICAgJ29yaWVudGF0aW9uJyxcbiAgICAnZ2x5cGhHZW9tZXRyeURldGFpbCdcbiAgKTtcblxuICAvKipcbiAgICogQGNsYXNzIFRleHRcbiAgICpcbiAgICogQSBUaHJlZUpTIE1lc2ggdGhhdCByZW5kZXJzIGEgc3RyaW5nIG9mIHRleHQgb24gYSBwbGFuZSBpbiAzRCBzcGFjZSB1c2luZyBzaWduZWQgZGlzdGFuY2VcbiAgICogZmllbGRzIChTREYpLlxuICAgKi9cbiAgY2xhc3MgVGV4dCBleHRlbmRzIHRocmVlLk1lc2gge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2x5cGhzR2VvbWV0cnkoKTtcbiAgICAgIHN1cGVyKGdlb21ldHJ5LCBudWxsKTtcblxuICAgICAgLy8gPT09IFRleHQgbGF5b3V0IHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gdGV4dFxuICAgICAgICogVGhlIHN0cmluZyBvZiB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICovXG4gICAgICB0aGlzLnRleHQgPSAnJztcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBhbmNob3JYXG4gICAgICAgKiBEZWZpbmVzIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIGluIHRoZSB0ZXh0IGJsb2NrIHRoYXQgc2hvdWxkIGxpbmUgdXAgd2l0aCB0aGUgbG9jYWwgb3JpZ2luLlxuICAgICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgeCBwb3NpdGlvbiBpbiBsb2NhbCB1bml0cywgYSBzdHJpbmcgcGVyY2VudGFnZSBvZiB0aGUgdG90YWxcbiAgICAgICAqIHRleHQgYmxvY2sgd2lkdGggZS5nLiBgJzI1JSdgLCBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXl3b3JkIHN0cmluZ3M6ICdsZWZ0JywgJ2NlbnRlcicsXG4gICAgICAgKiBvciAncmlnaHQnLlxuICAgICAgICovXG4gICAgICB0aGlzLmFuY2hvclggPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGFuY2hvclhcbiAgICAgICAqIERlZmluZXMgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIGluIHRoZSB0ZXh0IGJsb2NrIHRoYXQgc2hvdWxkIGxpbmUgdXAgd2l0aCB0aGUgbG9jYWwgb3JpZ2luLlxuICAgICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgeSBwb3NpdGlvbiBpbiBsb2NhbCB1bml0cyAobm90ZTogZG93biBpcyBuZWdhdGl2ZSB5KSwgYSBzdHJpbmdcbiAgICAgICAqIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsIHRleHQgYmxvY2sgaGVpZ2h0IGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOlxuICAgICAgICogJ3RvcCcsICd0b3AtYmFzZWxpbmUnLCAndG9wLWNhcCcsICd0b3AtZXgnLCAnbWlkZGxlJywgJ2JvdHRvbS1iYXNlbGluZScsIG9yICdib3R0b20nLlxuICAgICAgICovXG4gICAgICB0aGlzLmFuY2hvclkgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gY3VydmVSYWRpdXNcbiAgICAgICAqIERlZmluZXMgYSBjeWxpbmRyaWNhbCByYWRpdXMgYWxvbmcgd2hpY2ggdGhlIHRleHQncyBwbGFuZSB3aWxsIGJlIGN1cnZlZC4gUG9zaXRpdmUgbnVtYmVycyBwdXRcbiAgICAgICAqIHRoZSBjeWxpbmRlcidzIGNlbnRlcmxpbmUgKG9yaWVudGVkIHZlcnRpY2FsbHkpIHRoYXQgZGlzdGFuY2UgaW4gZnJvbnQgb2YgdGhlIHRleHQsIGZvciBhIGNvbmNhdmVcbiAgICAgICAqIGN1cnZhdHVyZSwgd2hpbGUgbmVnYXRpdmUgbnVtYmVycyBwdXQgaXQgYmVoaW5kIHRoZSB0ZXh0IGZvciBhIGNvbnZleCBjdXJ2YXR1cmUuIFRoZSBjZW50ZXJsaW5lXG4gICAgICAgKiB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgdGV4dCdzIGxvY2FsIG9yaWdpbjsgeW91IGNhbiB1c2UgYGFuY2hvclhgIHRvIG9mZnNldCBpdC5cbiAgICAgICAqXG4gICAgICAgKiBTaW5jZSBlYWNoIGdseXBoIGlzIGJ5IGRlZmF1bHQgcmVuZGVyZWQgd2l0aCBhIHNpbXBsZSBxdWFkLCBlYWNoIGdseXBoIHJlbWFpbnMgYSBmbGF0IHBsYW5lXG4gICAgICAgKiBpbnRlcm5hbGx5LiBZb3UgY2FuIHVzZSBgZ2x5cGhHZW9tZXRyeURldGFpbGAgdG8gYWRkIG1vcmUgdmVydGljZXMgZm9yIGN1cnZhdHVyZSBpbnNpZGUgZ2x5cGhzLlxuICAgICAgICovXG4gICAgICB0aGlzLmN1cnZlUmFkaXVzID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRpcmVjdGlvblxuICAgICAgICogU2V0cyB0aGUgYmFzZSBkaXJlY3Rpb24gZm9yIHRoZSB0ZXh0LiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBcImF1dG9cIiB3aWxsIGNob29zZSBhIGRpcmVjdGlvbiBiYXNlZFxuICAgICAgICogb24gdGhlIHRleHQncyBjb250ZW50IGFjY29yZGluZyB0byB0aGUgYmlkaSBzcGVjLiBBIHZhbHVlIG9mIFwibHRyXCIgb3IgXCJydGxcIiB3aWxsIGZvcmNlIHRoZSBkaXJlY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2F1dG8nO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZm9udFxuICAgICAgICogVVJMIG9mIGEgY3VzdG9tIGZvbnQgdG8gYmUgdXNlZC4gRm9udCBmaWxlcyBjYW4gYmUgaW4gLnR0ZiwgLm90Ziwgb3IgLndvZmYgKG5vdCAud29mZjIpIGZvcm1hdHMuXG4gICAgICAgKiBEZWZhdWx0cyB0byB0aGUgUm9ib3RvIGZvbnQgbG9hZGVkIGZyb20gR29vZ2xlIEZvbnRzLlxuICAgICAgICovXG4gICAgICB0aGlzLmZvbnQgPSBudWxsOyAvL3dpbGwgdXNlIGRlZmF1bHQgZnJvbSBUZXh0QnVpbGRlclxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZm9udFNpemVcbiAgICAgICAqIFRoZSBzaXplIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgZm9udCBpbiBsb2NhbCB1bml0czsgY29ycmVzcG9uZHMgdG8gdGhlIGVtLWJveCBoZWlnaHRcbiAgICAgICAqIG9mIHRoZSBjaG9zZW4gYGZvbnRgLlxuICAgICAgICovXG4gICAgICB0aGlzLmZvbnRTaXplID0gMC4xO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbGV0dGVyU3BhY2luZ1xuICAgICAgICogU2V0cyBhIHVuaWZvcm0gYWRqdXN0bWVudCB0byBzcGFjaW5nIGJldHdlZW4gbGV0dGVycyBhZnRlciBrZXJuaW5nIGlzIGFwcGxpZWQuIFBvc2l0aXZlXG4gICAgICAgKiBudW1iZXJzIGluY3JlYXNlIHNwYWNpbmcgYW5kIG5lZ2F0aXZlIG51bWJlcnMgZGVjcmVhc2UgaXQuXG4gICAgICAgKi9cbiAgICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gbGluZUhlaWdodFxuICAgICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGVhY2ggbGluZSBvZiB0ZXh0LCBhcyBhIG11bHRpcGxlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byAnbm9ybWFsJ1xuICAgICAgICogd2hpY2ggY2hvb3NlcyBhIHJlYXNvbmFibGUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBjaG9zZW4gZm9udCdzIGFzY2VuZGVyL2Rlc2NlbmRlciBtZXRyaWNzLlxuICAgICAgICovXG4gICAgICB0aGlzLmxpbmVIZWlnaHQgPSAnbm9ybWFsJztcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG1heFdpZHRoXG4gICAgICAgKiBUaGUgbWF4aW11bSB3aWR0aCBvZiB0aGUgdGV4dCBibG9jaywgYWJvdmUgd2hpY2ggdGV4dCBtYXkgc3RhcnQgd3JhcHBpbmcgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICogYHdoaXRlU3BhY2VgIGFuZCBgb3ZlcmZsb3dXcmFwYCBwcm9wZXJ0aWVzLlxuICAgICAgICovXG4gICAgICB0aGlzLm1heFdpZHRoID0gSW5maW5pdHk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBvdmVyZmxvd1dyYXBcbiAgICAgICAqIERlZmluZXMgaG93IHRleHQgd3JhcHMgaWYgdGhlIGB3aGl0ZVNwYWNlYCBwcm9wZXJ0eSBpcyBgbm9ybWFsYC4gQ2FuIGJlIGVpdGhlciBgJ25vcm1hbCdgXG4gICAgICAgKiB0byBicmVhayBhdCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsIG9yIGAnYnJlYWstd29yZCdgIHRvIGFsbG93IGJyZWFraW5nIHdpdGhpbiB3b3Jkcy5cbiAgICAgICAqIERlZmF1bHRzIHRvIGAnbm9ybWFsJ2AuXG4gICAgICAgKi9cbiAgICAgIHRoaXMub3ZlcmZsb3dXcmFwID0gJ25vcm1hbCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0QWxpZ25cbiAgICAgICAqIFRoZSBob3Jpem9udGFsIGFsaWdubWVudCBvZiBlYWNoIGxpbmUgb2YgdGV4dCB3aXRoaW4gdGhlIG92ZXJhbGwgdGV4dCBib3VuZGluZyBib3guXG4gICAgICAgKi9cbiAgICAgIHRoaXMudGV4dEFsaWduID0gJ2xlZnQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gdGV4dEluZGVudFxuICAgICAgICogSW5kZW50YXRpb24gZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBsaW5lOyBzZWUgQ1NTIGB0ZXh0LWluZGVudGAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMudGV4dEluZGVudCA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB3aGl0ZVNwYWNlXG4gICAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGV4dCBzaG91bGQgd3JhcCB3aGVuIGEgbGluZSByZWFjaGVzIHRoZSBgbWF4V2lkdGhgLiBDYW5cbiAgICAgICAqIGJlIGVpdGhlciBgJ25vcm1hbCdgICh0aGUgZGVmYXVsdCksIHRvIGFsbG93IHdyYXBwaW5nIGFjY29yZGluZyB0byB0aGUgYG92ZXJmbG93V3JhcGAgcHJvcGVydHksXG4gICAgICAgKiBvciBgJ25vd3JhcCdgIHRvIHByZXZlbnQgd3JhcHBpbmcuIE5vdGUgdGhhdCBgJ25vcm1hbCdgIGhlcmUgaG9ub3JzIG5ld2xpbmUgY2hhcmFjdGVycyB0b1xuICAgICAgICogbWFudWFsbHkgYnJlYWsgbGluZXMsIG1ha2luZyBpdCBiZWhhdmUgbW9yZSBsaWtlIGAncHJlLXdyYXAnYCBkb2VzIGluIENTUy5cbiAgICAgICAqL1xuICAgICAgdGhpcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG5cblxuICAgICAgLy8gPT09IFByZXNlbnRhdGlvbiBwcm9wZXJ0aWVzOiA9PT0gLy9cblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtUSFJFRS5NYXRlcmlhbH0gbWF0ZXJpYWxcbiAgICAgICAqIERlZmluZXMgYSBfYmFzZV8gbWF0ZXJpYWwgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyB0aGUgdGV4dC4gVGhpcyBtYXRlcmlhbCB3aWxsIGJlXG4gICAgICAgKiBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIHdpdGggYSBtYXRlcmlhbCBkZXJpdmVkIGZyb20gaXQsIHRoYXQgYWRkcyBzaGFkZXIgY29kZSB0b1xuICAgICAgICogZGVjcmVhc2UgdGhlIGFscGhhIGZvciBlYWNoIGZyYWdtZW50IChwaXhlbCkgb3V0c2lkZSB0aGUgdGV4dCBnbHlwaHMsIHdpdGggYW50aWFsaWFzaW5nLlxuICAgICAgICogQnkgZGVmYXVsdCBpdCB3aWxsIGRlcml2ZSBmcm9tIGEgc2ltcGxlIHdoaXRlIE1lc2hCYXNpY01hdGVyaWFsLCBidXQgeW91IGNhbiB1c2UgYW55XG4gICAgICAgKiBvZiB0aGUgb3RoZXIgbWVzaCBtYXRlcmlhbHMgdG8gZ2FpbiBvdGhlciBmZWF0dXJlcyBsaWtlIGxpZ2h0aW5nLCB0ZXh0dXJlIG1hcHMsIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiBBbHNvIHNlZSB0aGUgYGNvbG9yYCBzaG9ydGN1dCBwcm9wZXJ0eS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gY29sb3JcbiAgICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3Igc2V0dGluZyB0aGUgYGNvbG9yYCBvZiB0aGUgdGV4dCdzIG1hdGVyaWFsLiBZb3UgY2FuIHVzZSB0aGlzXG4gICAgICAgKiBpZiB5b3UgZG9uJ3Qgd2FudCB0byBzcGVjaWZ5IGEgd2hvbGUgY3VzdG9tIGBtYXRlcmlhbGAuIEFsc28sIGlmIHlvdSBkbyB1c2UgYSBjdXN0b21cbiAgICAgICAqIGBtYXRlcmlhbGAsIHRoaXMgY29sb3Igd2lsbCBvbmx5IGJlIHVzZWQgZm9yIHRoaXMgcGFydGljdWFyIFRleHQgaW5zdGFuY2UsIGV2ZW4gaWZcbiAgICAgICAqIHRoYXQgc2FtZSBtYXRlcmlhbCBpbnN0YW5jZSBpcyBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIFRleHQgb2JqZWN0cy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5jb2xvciA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7b2JqZWN0fG51bGx9IGNvbG9yUmFuZ2VzXG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBUaGlzIGFsbG93cyBtb3JlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG9mIGNvbG9ycyBmb3IgaW5kaXZpZHVhbCBvciByYW5nZXMgb2YgY2hhcmFjdGVycyxcbiAgICAgICAqIHRha2luZyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hdGVyaWFsJ3MgYGNvbG9yYC4gSXRzIGZvcm1hdCBpcyBhbiBPYmplY3Qgd2hvc2Uga2V5cyBlYWNoXG4gICAgICAgKiBkZWZpbmUgYSBzdGFydGluZyBjaGFyYWN0ZXIgaW5kZXggZm9yIGEgcmFuZ2UsIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIHRoZSBjb2xvciBmb3IgZWFjaFxuICAgICAgICogcmFuZ2UuIFRoZSBjb2xvciB2YWx1ZSBjYW4gYmUgYSBudW1lcmljIGhleCBjb2xvciB2YWx1ZSwgYSBgVEhSRUUuQ29sb3JgIG9iamVjdCwgb3JcbiAgICAgICAqIGFueSBvZiB0aGUgc3RyaW5ncyBhY2NlcHRlZCBieSBgVEhSRUUuQ29sb3JgLlxuICAgICAgICovXG4gICAgICB0aGlzLmNvbG9yUmFuZ2VzID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lV2lkdGhcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIFRoZSB3aWR0aCBvZiBhbiBvdXRsaW5lL2hhbG8gdG8gYmUgZHJhd24gYXJvdW5kIGVhY2ggdGV4dCBnbHlwaCB1c2luZyB0aGUgYG91dGxpbmVDb2xvcmAgYW5kIGBvdXRsaW5lT3BhY2l0eWAuXG4gICAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLlxuICAgICAgICogYFwiMTIlXCJgIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAsIHdoaWNoIG1lYW5zXG4gICAgICAgKiBubyBvdXRsaW5lIHdpbGwgYmUgZHJhd24gdW5sZXNzIGFuIGBvdXRsaW5lT2Zmc2V0WC9ZYCBvciBgb3V0bGluZUJsdXJgIGlzIHNldC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5vdXRsaW5lV2lkdGggPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IG91dGxpbmVDb2xvclxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IG91dGxpbmUsIGlmIGBvdXRsaW5lV2lkdGhgL2BvdXRsaW5lQmx1cmAvYG91dGxpbmVPZmZzZXRYL1lgIGFyZSBzZXQuXG4gICAgICAgKiBEZWZhdWx0cyB0byBibGFjay5cbiAgICAgICAqL1xuICAgICAgdGhpcy5vdXRsaW5lQ29sb3IgPSAweDAwMDAwMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG91dGxpbmVPcGFjaXR5XG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb3V0bGluZSwgaWYgYG91dGxpbmVXaWR0aGAvYG91dGxpbmVCbHVyYC9gb3V0bGluZU9mZnNldFgvWWAgYXJlIHNldC5cbiAgICAgICAqIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5vdXRsaW5lT3BhY2l0eSA9IDE7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZUJsdXJcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIEEgYmx1ciByYWRpdXMgYXBwbGllZCB0byB0aGUgb3V0ZXIgZWRnZSBvZiB0aGUgdGV4dCdzIG91dGxpbmUuIElmIHRoZSBgb3V0bGluZVdpZHRoYCBpc1xuICAgICAgICogemVybywgdGhlIGJsdXIgd2lsbCBiZSBhcHBsaWVkIGF0IHRoZSBnbHlwaCBlZGdlLCBsaWtlIENTUydzIGB0ZXh0LXNoYWRvd2AgYmx1ciByYWRpdXMuXG4gICAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLlxuICAgICAgICogYFwiMTIlXCJgIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMub3V0bGluZUJsdXIgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVPZmZzZXRYXG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBBIGhvcml6b250YWwgb2Zmc2V0IGZvciB0aGUgdGV4dCBvdXRsaW5lLlxuICAgICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAgICovXG4gICAgICB0aGlzLm91dGxpbmVPZmZzZXRYID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lT2Zmc2V0WVxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogQSB2ZXJ0aWNhbCBvZmZzZXQgZm9yIHRoZSB0ZXh0IG91dGxpbmUuXG4gICAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMub3V0bGluZU9mZnNldFkgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IHN0cm9rZVdpZHRoXG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBUaGUgd2lkdGggb2YgYW4gaW5uZXIgc3Ryb2tlIGRyYXduIGluc2lkZSBlYWNoIHRleHQgZ2x5cGggdXNpbmcgdGhlIGBzdHJva2VDb2xvcmAgYW5kIGBzdHJva2VPcGFjaXR5YC5cbiAgICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gc3Ryb2tlQ29sb3JcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBzdHJva2UsIGlmIGBzdHJva2VXaWR0aGAgaXMgZ3JlYXRlciB0aGFuIHplcm8uIERlZmF1bHRzIHRvIGdyYXkuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBkZWZhdWx0U3Ryb2tlQ29sb3I7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBzdHJva2VPcGFjaXR5XG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgc3Ryb2tlLCBpZiBgc3Ryb2tlV2lkdGhgIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBmaWxsT3BhY2l0eVxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIGdseXBoJ3MgZmlsbCBmcm9tIDAgdG8gMS4gVGhpcyBiZWhhdmVzIGxpa2UgdGhlIG1hdGVyaWFsJ3MgYG9wYWNpdHlgIGJ1dCBhbGxvd3NcbiAgICAgICAqIGdpdmluZyB0aGUgZmlsbCBhIGRpZmZlcmVudCBvcGFjaXR5IHRoYW4gdGhlIGBzdHJva2VPcGFjaXR5YC4gQSBmaWxsT3BhY2l0eSBvZiBgMGAgbWFrZXMgdGhlXG4gICAgICAgKiBpbnRlcmlvciBvZiB0aGUgZ2x5cGggaW52aXNpYmxlLCBsZWF2aW5nIGp1c3QgdGhlIGBzdHJva2VXaWR0aGAuIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBkZXB0aE9mZnNldFxuICAgICAgICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBzZXR0aW5nIHRoZSBtYXRlcmlhbCdzIGBwb2x5Z29uT2Zmc2V0YCBhbmQgcmVsYXRlZCBwcm9wZXJ0aWVzLFxuICAgICAgICogd2hpY2ggY2FuIGJlIHVzZWZ1bCBpbiBwcmV2ZW50aW5nIHotZmlnaHRpbmcgd2hlbiB0aGlzIHRleHQgaXMgbGFpZCBvbiB0b3Agb2YgYW5vdGhlclxuICAgICAgICogcGxhbmUgaW4gdGhlIHNjZW5lLiBQb3NpdGl2ZSBudW1iZXJzIGFyZSBmdXJ0aGVyIGZyb20gdGhlIGNhbWVyYSwgbmVnYXRpdmVzIGNsb3Nlci5cbiAgICAgICAqL1xuICAgICAgdGhpcy5kZXB0aE9mZnNldCA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7QXJyYXk8bnVtYmVyPn0gY2xpcFJlY3RcbiAgICAgICAqIElmIHNwZWNpZmllZCwgZGVmaW5lcyBhIGBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV1gIG9mIGEgcmVjdGFuZ2xlIG91dHNpZGUgb2Ygd2hpY2ggYWxsXG4gICAgICAgKiBwaXhlbHMgd2lsbCBiZSBkaXNjYXJkZWQuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gY2xpcCBvdmVyZmxvd2luZyB0ZXh0IHdoZW5cbiAgICAgICAqIGB3aGl0ZVNwYWNlPSdub3dyYXAnYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5jbGlwUmVjdCA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBvcmllbnRhdGlvblxuICAgICAgICogRGVmaW5lcyB0aGUgYXhpcyBwbGFuZSBvbiB3aGljaCB0aGUgdGV4dCBzaG91bGQgYmUgbGFpZCBvdXQgd2hlbiB0aGUgbWVzaCBoYXMgbm8gZXh0cmFcbiAgICAgICAqIHJvdGF0aW9uIHRyYW5zZm9ybS4gSXQgaXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIHdpdGggdHdvIGF4ZXM6IHRoZSBob3Jpem9udGFsIGF4aXMgd2l0aFxuICAgICAgICogcG9zaXRpdmUgcG9pbnRpbmcgcmlnaHQsIGFuZCB0aGUgdmVydGljYWwgYXhpcyB3aXRoIHBvc2l0aXZlIHBvaW50aW5nIHVwLiBCeSBkZWZhdWx0IHRoaXNcbiAgICAgICAqIGlzICcreCt5JywgbWVhbmluZyB0aGUgdGV4dCBzaXRzIG9uIHRoZSB4eSBwbGFuZSB3aXRoIHRoZSB0ZXh0J3MgdG9wIHRvd2FyZCBwb3NpdGl2ZSB5XG4gICAgICAgKiBhbmQgZmFjaW5nIHBvc2l0aXZlIHouIEEgdmFsdWUgb2YgJyt4LXonIHdvdWxkIHBsYWNlIGl0IG9uIHRoZSB4eiBwbGFuZSB3aXRoIHRoZSB0ZXh0J3NcbiAgICAgICAqIHRvcCB0b3dhcmQgbmVnYXRpdmUgeiBhbmQgZmFjaW5nIHBvc2l0aXZlIHkuXG4gICAgICAgKi9cbiAgICAgIHRoaXMub3JpZW50YXRpb24gPSBkZWZhdWx0T3JpZW50O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZ2x5cGhHZW9tZXRyeURldGFpbFxuICAgICAgICogQ29udHJvbHMgbnVtYmVyIG9mIHZlcnRpY2FsL2hvcml6b250YWwgc2VnbWVudHMgdGhhdCBtYWtlIHVwIGVhY2ggZ2x5cGgncyByZWN0YW5ndWxhclxuICAgICAgICogcGxhbmUuIERlZmF1bHRzIHRvIDEuIFRoaXMgY2FuIGJlIGluY3JlYXNlZCB0byBwcm92aWRlIG1vcmUgZ2VvbWV0cmljYWwgZGV0YWlsIGZvciBjdXN0b21cbiAgICAgICAqIHZlcnRleCBzaGFkZXIgZWZmZWN0cywgZm9yIGV4YW1wbGUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZ2x5cGhHZW9tZXRyeURldGFpbCA9IDE7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfG51bGx9IHNkZkdseXBoU2l6ZVxuICAgICAgICogVGhlIHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKSB1c2VkIGZvciByZW5kZXJpbmcuIFRoaXMgbXVzdCBiZSBhXG4gICAgICAgKiBwb3dlci1vZi10d28gbnVtYmVyLiBEZWZhdWx0cyB0byA2NCB3aGljaCBpcyBnZW5lcmFsbHkgYSBnb29kIGJhbGFuY2Ugb2Ygc2l6ZSBhbmQgcXVhbGl0eVxuICAgICAgICogZm9yIG1vc3QgZm9udHMuIExhcmdlciBzaXplcyBjYW4gaW1wcm92ZSB0aGUgcXVhbGl0eSBvZiBnbHlwaCByZW5kZXJpbmcgYnkgaW5jcmVhc2luZ1xuICAgICAgICogdGhlIHNoYXJwbmVzcyBvZiBjb3JuZXJzIGFuZCBwcmV2ZW50aW5nIGxvc3Mgb2YgdmVyeSB0aGluIGxpbmVzLCBhdCB0aGUgZXhwZW5zZSBvZlxuICAgICAgICogaW5jcmVhc2VkIG1lbW9yeSBmb290cHJpbnQgYW5kIGxvbmdlciBTREYgZ2VuZXJhdGlvbiB0aW1lLlxuICAgICAgICovXG4gICAgICB0aGlzLnNkZkdseXBoU2l6ZSA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gZ3B1QWNjZWxlcmF0ZVNERlxuICAgICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBTREYgZ2VuZXJhdGlvbiBwcm9jZXNzIHdpbGwgYmUgR1BVLWFjY2VsZXJhdGVkIHdpdGggV2ViR0wgd2hlbiBwb3NzaWJsZSxcbiAgICAgICAqIG1ha2luZyBpdCBtdWNoIGZhc3RlciBlc3BlY2lhbGx5IGZvciBjb21wbGV4IGdseXBocywgYW5kIGZhbGxpbmcgYmFjayB0byBhIEphdmFTY3JpcHQgdmVyc2lvblxuICAgICAgICogZXhlY3V0ZWQgaW4gd2ViIHdvcmtlcnMgd2hlbiBzdXBwb3J0IGlzbid0IGF2YWlsYWJsZS4gSXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHN1cHBvcnQsXG4gICAgICAgKiBidXQgaXQncyBzdGlsbCBzb21ld2hhdCBleHBlcmltZW50YWwsIHNvIHlvdSBjYW4gc2V0IGl0IHRvIGBmYWxzZWAgdG8gZm9yY2UgaXQgdG8gdXNlIHRoZSBKU1xuICAgICAgICogdmVyc2lvbiBpZiB5b3UgZW5jb3VudGVyIGlzc3VlcyB3aXRoIGl0LlxuICAgICAgICovXG4gICAgICB0aGlzLmdwdUFjY2VsZXJhdGVTREYgPSB0cnVlO1xuXG4gICAgICB0aGlzLmRlYnVnU0RGID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdGV4dCByZW5kZXJpbmcgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHRleHQtcmVsYXRlZCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMuXG4gICAgICogVGhpcyBpcyBhbiBhc3luYyBwcm9jZXNzLCBzbyB5b3UgY2FuIHBhc3MgaW4gYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIGl0XG4gICAgICogZmluaXNoZXMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAqL1xuICAgIHN5bmMoY2FsbGJhY2spIHtcbiAgICAgIGlmICh0aGlzLl9uZWVkc1N5bmMpIHtcbiAgICAgICAgdGhpcy5fbmVlZHNTeW5jID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbm90aGVyIHN5bmMgc3RpbGwgaW4gcHJvZ3Jlc3MsIHF1ZXVlXG4gICAgICAgIGlmICh0aGlzLl9pc1N5bmNpbmcpIHtcbiAgICAgICAgICAodGhpcy5fcXVldWVkU3luY3MgfHwgKHRoaXMuX3F1ZXVlZFN5bmNzID0gW10pKS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9pc1N5bmNpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzeW5jU3RhcnRFdmVudCk7XG5cbiAgICAgICAgICBnZXRUZXh0UmVuZGVySW5mbyh7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgICAgICBmb250OiB0aGlzLmZvbnQsXG4gICAgICAgICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSB8fCAwLjEsXG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcgfHwgMCxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMubGluZUhlaWdodCB8fCAnbm9ybWFsJyxcbiAgICAgICAgICAgIG1heFdpZHRoOiB0aGlzLm1heFdpZHRoLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbiB8fCAnYXV0bycsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRoaXMudGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dEluZGVudDogdGhpcy50ZXh0SW5kZW50LFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgICAgICAgb3ZlcmZsb3dXcmFwOiB0aGlzLm92ZXJmbG93V3JhcCxcbiAgICAgICAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yWCxcbiAgICAgICAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgICAgICAgIGNvbG9yUmFuZ2VzOiB0aGlzLmNvbG9yUmFuZ2VzLFxuICAgICAgICAgICAgaW5jbHVkZUNhcmV0UG9zaXRpb25zOiB0cnVlLCAvL1RPRE8gcGFyYW1ldGVyaXplXG4gICAgICAgICAgICBzZGZHbHlwaFNpemU6IHRoaXMuc2RmR2x5cGhTaXplLFxuICAgICAgICAgICAgZ3B1QWNjZWxlcmF0ZVNERjogdGhpcy5ncHVBY2NlbGVyYXRlU0RGLFxuICAgICAgICAgIH0sIHRleHRSZW5kZXJJbmZvID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2lzU3luY2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHJlc3VsdCBmb3IgbGF0ZXIgdXNlIGluIG9uQmVmb3JlUmVuZGVyXG4gICAgICAgICAgICB0aGlzLl90ZXh0UmVuZGVySW5mbyA9IHRleHRSZW5kZXJJbmZvO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGdlb21ldHJ5IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkudXBkYXRlR2x5cGhzKFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaEJvdW5kcyxcbiAgICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhBdGxhc0luZGljZXMsXG4gICAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmJsb2NrQm91bmRzLFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5jaHVua2VkQm91bmRzLFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaENvbG9yc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgaGFkIGV4dHJhIHN5bmMgcmVxdWVzdHMgcXVldWVkIHVwLCBraWNrIGl0IG9mZlxuICAgICAgICAgICAgY29uc3QgcXVldWVkID0gdGhpcy5fcXVldWVkU3luY3M7XG4gICAgICAgICAgICBpZiAocXVldWVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3F1ZXVlZFN5bmNzID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5zeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICBxdWV1ZWQuZm9yRWFjaChmbiA9PiBmbiAmJiBmbigpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzeW5jQ29tcGxldGVFdmVudCk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgc3luYyBpZiBuZWVkZWQgLSBub3RlIGl0IHdvbid0IGNvbXBsZXRlIHVudGlsIG5leHQgZnJhbWUgYXQgdGhlXG4gICAgICogZWFybGllc3Qgc28gaWYgcG9zc2libGUgaXQncyBhIGdvb2QgaWRlYSB0byBjYWxsIHN5bmMoKSBtYW51YWxseSBhcyBzb29uIGFzXG4gICAgICogYWxsIHRoZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgb25CZWZvcmVSZW5kZXIocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApIHtcbiAgICAgIHRoaXMuc3luYygpO1xuXG4gICAgICAvLyBUaGlzIG1heSBub3QgYWx3YXlzIGJlIGEgdGV4dCBtYXRlcmlhbCwgZS5nLiBpZiB0aGVyZSdzIGEgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCBwcmVzZW50XG4gICAgICBpZiAobWF0ZXJpYWwuaXNUcm9pa2FUZXh0TWF0ZXJpYWwpIHtcbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gZm9yY2UgdGhlIG1hdGVyaWFsIHRvIEZyb250U2lkZSB0byBhdm9pZCB0aGUgZG91YmxlLWRyYXctY2FsbCBwZXJmb3JtYW5jZSBoaXRcbiAgICAgIC8vIGludHJvZHVjZWQgaW4gVGhyZWUuanMgcjEzMDogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIxOTY3IC0gVGhlIHNpZGVkbmVzc1xuICAgICAgLy8gaXMgaW5zdGVhZCBhcHBsaWVkIHZpYSBkcmF3UmFuZ2UgaW4gdGhlIEdseXBoc0dlb21ldHJ5LlxuICAgICAgbWF0ZXJpYWwuX2hhZE93blNpZGUgPSBtYXRlcmlhbC5oYXNPd25Qcm9wZXJ0eSgnc2lkZScpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRTaWRlKG1hdGVyaWFsLl9hY3R1YWxTaWRlID0gbWF0ZXJpYWwuc2lkZSk7XG4gICAgICBtYXRlcmlhbC5zaWRlID0gdGhyZWUuRnJvbnRTaWRlO1xuICAgIH1cblxuICAgIG9uQWZ0ZXJSZW5kZXIocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApIHtcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgbWF0ZXJpYWwgc2lkZVxuICAgICAgaWYgKG1hdGVyaWFsLl9oYWRPd25TaWRlKSB7XG4gICAgICAgIG1hdGVyaWFsLnNpZGUgPSBtYXRlcmlhbC5fYWN0dWFsU2lkZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBtYXRlcmlhbC5zaWRlOyAvLyBiYWNrIHRvIGluaGVyaXRpbmcgZnJvbSBiYXNlIG1hdGVyaWFsXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgdG8gZGlzcG9zZSB0aGUgZ2VvbWV0cnkgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBOb3RlOiB3ZSBkb24ndCBhbHNvIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgaGVyZSBiZWNhdXNlIGlmIGFueXRoaW5nIGVsc2UgaXNcbiAgICAgKiBzaGFyaW5nIHRoZSBzYW1lIGJhc2UgbWF0ZXJpYWwgaXQgd2lsbCByZXN1bHQgaW4gYSBwYXVzZSBuZXh0IGZyYW1lIGFzIHRoZSBwcm9ncmFtXG4gICAgICogaXMgcmVjb21waWxlZC4gSW5zdGVhZCB1c2VycyBjYW4gZGlzcG9zZSB0aGUgYmFzZSBtYXRlcmlhbCBtYW51YWxseSwgbGlrZSBub3JtYWwsXG4gICAgICogYW5kIHdlJ2xsIGFsc28gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBhdCB0aGF0IHRpbWUuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VHJvaWthVGV4dFJlbmRlckluZm98bnVsbH0gdGV4dFJlbmRlckluZm9cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBUaGUgY3VycmVudCBwcm9jZXNzZWQgcmVuZGVyaW5nIGRhdGEgZm9yIHRoaXMgVGV4dE1lc2gsIHJldHVybmVkIGJ5IHRoZSBUZXh0QnVpbGRlciBhZnRlclxuICAgICAqIGEgYHN5bmMoKWAgY2FsbC4gVGhpcyB3aWxsIGJlIGBudWxsYCBpbml0aWFsbHksIGFuZCBtYXkgYmUgc3RhbGUgZm9yIGEgc2hvcnQgcGVyaW9kIHVudGlsXG4gICAgICogdGhlIGFzeW5jaHJvdXMgYHN5bmMoKWAgcHJvY2VzcyBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgZ2V0IHRleHRSZW5kZXJJbmZvKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RleHRSZW5kZXJJbmZvIHx8IG51bGxcbiAgICB9XG5cbiAgICAvLyBIYW5kbGVyIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIHRoZSBiYXNlIG1hdGVyaWFsIHdpdGggb3VyIHVwZ3JhZGVzLiBXZSBkbyB0aGUgd3JhcHBpbmdcbiAgICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gICAgZ2V0IG1hdGVyaWFsKCkge1xuICAgICAgbGV0IGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICAgIGNvbnN0IGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgfHwgKHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRNYXRlcmlhbC5jbG9uZSgpKTtcbiAgICAgIGlmICghZGVyaXZlZE1hdGVyaWFsIHx8IGRlcml2ZWRNYXRlcmlhbC5iYXNlTWF0ZXJpYWwgIT09IGJhc2VNYXRlcmlhbCkge1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCk7XG4gICAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgICAgYmFzZU1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgYmFzZU1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gSWYgdGV4dCBvdXRsaW5lIGlzIGNvbmZpZ3VyZWQsIHJlbmRlciBpdCBhcyBhIHByZWxpbWluYXJ5IGRyYXcgdXNpbmcgVGhyZWUncyBtdWx0aS1tYXRlcmlhbFxuICAgICAgLy8gZmVhdHVyZSAoc2VlIEdseXBoc0dlb21ldHJ5IHdoaWNoIHNldHMgdXAgYGdyb3Vwc2AgZm9yIHRoaXMgcHVycG9zZSkgRG9pbmcgaXQgd2l0aCBtdWx0aVxuICAgICAgLy8gbWF0ZXJpYWxzIGVuc3VyZXMgdGhlIGxheWVycyBhcmUgYWx3YXlzIHJlbmRlcmVkIGNvbnNlY3V0aXZlbHkgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuICAgICAgLy8gRWFjaCBsYXllciB3aWxsIHRyaWdnZXIgb25CZWZvcmVSZW5kZXIgd2l0aCB0aGUgYXBwcm9wcmlhdGUgbWF0ZXJpYWwuXG4gICAgICBpZiAodGhpcy5vdXRsaW5lV2lkdGggfHwgdGhpcy5vdXRsaW5lQmx1ciB8fCB0aGlzLm91dGxpbmVPZmZzZXRYIHx8IHRoaXMub3V0bGluZU9mZnNldFkpIHtcbiAgICAgICAgbGV0IG91dGxpbmVNYXRlcmlhbCA9IGRlcml2ZWRNYXRlcmlhbC5fb3V0bGluZU10bDtcbiAgICAgICAgaWYgKCFvdXRsaW5lTWF0ZXJpYWwpIHtcbiAgICAgICAgICBvdXRsaW5lTWF0ZXJpYWwgPSBkZXJpdmVkTWF0ZXJpYWwuX291dGxpbmVNdGwgPSBPYmplY3QuY3JlYXRlKGRlcml2ZWRNYXRlcmlhbCwge1xuICAgICAgICAgICAgaWQ6IHt2YWx1ZTogZGVyaXZlZE1hdGVyaWFsLmlkICsgMC4xfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG91dGxpbmVNYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWwgPSB0cnVlO1xuICAgICAgICAgIG91dGxpbmVNYXRlcmlhbC5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgICAgICAgb3V0bGluZU1hdGVyaWFsLm1hcCA9IG51bGw7IC8vPz8/XG4gICAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgICAgICBvdXRsaW5lTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgb3V0bGluZU1hdGVyaWFsLFxuICAgICAgICAgIGRlcml2ZWRNYXRlcmlhbFxuICAgICAgICBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVyaXZlZE1hdGVyaWFsXG4gICAgICB9XG4gICAgfVxuICAgIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICAgIGlmIChiYXNlTWF0ZXJpYWwgJiYgYmFzZU1hdGVyaWFsLmlzVHJvaWthVGV4dE1hdGVyaWFsKSB7IC8vcHJldmVudCBkb3VibGUtZGVyaXZhdGlvblxuICAgICAgICB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbC5iYXNlTWF0ZXJpYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGdseXBoR2VvbWV0cnlEZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5kZXRhaWxcbiAgICB9XG4gICAgc2V0IGdseXBoR2VvbWV0cnlEZXRhaWwoZGV0YWlsKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmRldGFpbCA9IGRldGFpbDtcbiAgICB9XG5cbiAgICBnZXQgY3VydmVSYWRpdXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5jdXJ2ZVJhZGl1c1xuICAgIH1cbiAgICBzZXQgY3VydmVSYWRpdXMocikge1xuICAgICAgdGhpcy5nZW9tZXRyeS5jdXJ2ZVJhZGl1cyA9IHI7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuZCB1cGRhdGUgbWF0ZXJpYWwgZm9yIHNoYWRvd3MgdXBvbiByZXF1ZXN0OlxuICAgIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgICAgcmV0dXJuIGZpcnN0KHRoaXMubWF0ZXJpYWwpLmdldERlcHRoTWF0ZXJpYWwoKVxuICAgIH1cbiAgICBnZXQgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCgpIHtcbiAgICAgIHJldHVybiBmaXJzdCh0aGlzLm1hdGVyaWFsKS5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgICB9XG5cbiAgICBfcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCkge1xuICAgICAgY29uc3QgaXNPdXRsaW5lID0gbWF0ZXJpYWwuaXNUZXh0T3V0bGluZU1hdGVyaWFsO1xuICAgICAgY29uc3QgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcbiAgICAgIGNvbnN0IHRleHRJbmZvID0gdGhpcy50ZXh0UmVuZGVySW5mbztcbiAgICAgIGlmICh0ZXh0SW5mbykge1xuICAgICAgICBjb25zdCB7c2RmVGV4dHVyZSwgYmxvY2tCb3VuZHN9ID0gdGV4dEluZm87XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZUZXh0dXJlLnZhbHVlID0gc2RmVGV4dHVyZTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmVTaXplLnZhbHVlLnNldChzZGZUZXh0dXJlLmltYWdlLndpZHRoLCBzZGZUZXh0dXJlLmltYWdlLmhlaWdodCk7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZHbHlwaFNpemUudmFsdWUgPSB0ZXh0SW5mby5zZGZHbHlwaFNpemU7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZFeHBvbmVudC52YWx1ZSA9IHRleHRJbmZvLnNkZkV4cG9uZW50O1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthVG90YWxCb3VuZHMudmFsdWUuZnJvbUFycmF5KGJsb2NrQm91bmRzKTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVVzZUdseXBoQ29sb3JzLnZhbHVlID0gIWlzT3V0bGluZSAmJiAhIXRleHRJbmZvLmdseXBoQ29sb3JzO1xuXG4gICAgICAgIGxldCBkaXN0YW5jZU9mZnNldCA9IDA7XG4gICAgICAgIGxldCBibHVyUmFkaXVzID0gMDtcbiAgICAgICAgbGV0IHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgbGV0IGZpbGxPcGFjaXR5O1xuICAgICAgICBsZXQgc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgbGV0IHN0cm9rZUNvbG9yO1xuICAgICAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXRZID0gMDtcblxuICAgICAgICBpZiAoaXNPdXRsaW5lKSB7XG4gICAgICAgICAgbGV0IHtvdXRsaW5lV2lkdGgsIG91dGxpbmVPZmZzZXRYLCBvdXRsaW5lT2Zmc2V0WSwgb3V0bGluZUJsdXIsIG91dGxpbmVPcGFjaXR5fSA9IHRoaXM7XG4gICAgICAgICAgZGlzdGFuY2VPZmZzZXQgPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZVdpZHRoKSB8fCAwO1xuICAgICAgICAgIGJsdXJSYWRpdXMgPSBNYXRoLm1heCgwLCB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZUJsdXIpIHx8IDApO1xuICAgICAgICAgIGZpbGxPcGFjaXR5ID0gb3V0bGluZU9wYWNpdHk7XG4gICAgICAgICAgb2Zmc2V0WCA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lT2Zmc2V0WCkgfHwgMDtcbiAgICAgICAgICBvZmZzZXRZID0gdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVPZmZzZXRZKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cm9rZVdpZHRoID0gTWF0aC5tYXgoMCwgdGhpcy5fcGFyc2VQZXJjZW50KHRoaXMuc3Ryb2tlV2lkdGgpIHx8IDApO1xuICAgICAgICAgIGlmIChzdHJva2VXaWR0aCkge1xuICAgICAgICAgICAgc3Ryb2tlQ29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yO1xuICAgICAgICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZUNvbG9yLnZhbHVlLnNldChzdHJva2VDb2xvciA9PSBudWxsID8gZGVmYXVsdFN0cm9rZUNvbG9yIDogc3Ryb2tlQ29sb3IpO1xuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eSA9IHRoaXMuc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgICAgIGlmIChzdHJva2VPcGFjaXR5ID09IG51bGwpIHN0cm9rZU9wYWNpdHkgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWxsT3BhY2l0eSA9IHRoaXMuZmlsbE9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICB1bmlmb3Jtcy51VHJvaWthRGlzdGFuY2VPZmZzZXQudmFsdWUgPSBkaXN0YW5jZU9mZnNldDtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVBvc2l0aW9uT2Zmc2V0LnZhbHVlLnNldChvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUJsdXJSYWRpdXMudmFsdWUgPSBibHVyUmFkaXVzO1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthU3Ryb2tlV2lkdGgudmFsdWUgPSBzdHJva2VXaWR0aDtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZU9wYWNpdHkudmFsdWUgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthRmlsbE9wYWNpdHkudmFsdWUgPSBmaWxsT3BhY2l0eSA9PSBudWxsID8gMSA6IGZpbGxPcGFjaXR5O1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthQ3VydmVSYWRpdXMudmFsdWUgPSB0aGlzLmN1cnZlUmFkaXVzIHx8IDA7XG5cbiAgICAgICAgbGV0IGNsaXBSZWN0ID0gdGhpcy5jbGlwUmVjdDtcbiAgICAgICAgaWYgKGNsaXBSZWN0ICYmIEFycmF5LmlzQXJyYXkoY2xpcFJlY3QpICYmIGNsaXBSZWN0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZS5mcm9tQXJyYXkoY2xpcFJlY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGNsaXBwaW5nIC0gY2hvb3NlIGEgZmluaXRlIHJlY3QgdGhhdCBzaG91bGRuJ3QgZXZlciBiZSByZWFjaGVkIGJ5IG92ZXJmbG93aW5nIGdseXBocyBvciBvdXRsaW5lc1xuICAgICAgICAgIGNvbnN0IHBhZCA9ICh0aGlzLmZvbnRTaXplIHx8IDAuMSkgKiAxMDA7XG4gICAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLnNldChcbiAgICAgICAgICAgIGJsb2NrQm91bmRzWzBdIC0gcGFkLFxuICAgICAgICAgICAgYmxvY2tCb3VuZHNbMV0gLSBwYWQsXG4gICAgICAgICAgICBibG9ja0JvdW5kc1syXSArIHBhZCxcbiAgICAgICAgICAgIGJsb2NrQm91bmRzWzNdICsgcGFkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlb21ldHJ5LmFwcGx5Q2xpcFJlY3QodW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZEZWJ1Zy52YWx1ZSA9ICEhdGhpcy5kZWJ1Z1NERjtcbiAgICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQgPSAhIXRoaXMuZGVwdGhPZmZzZXQ7XG4gICAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0gdGhpcy5kZXB0aE9mZnNldCB8fCAwO1xuXG4gICAgICAvLyBTaG9ydGN1dCBmb3Igc2V0dGluZyBtYXRlcmlhbCBjb2xvciB2aWEgYGNvbG9yYCBwcm9wIG9uIHRoZSBtZXNoOyB0aGlzIGlzXG4gICAgICAvLyBhcHBsaWVkIG9ubHkgdG8gdGhlIGRlcml2ZWQgbWF0ZXJpYWwgdG8gYXZvaWQgbXV0YXRpbmcgYSBzaGFyZWQgYmFzZSBtYXRlcmlhbC5cbiAgICAgIGNvbnN0IGNvbG9yID0gaXNPdXRsaW5lID8gKHRoaXMub3V0bGluZUNvbG9yIHx8IDApIDogdGhpcy5jb2xvcjtcblxuICAgICAgaWYgKGNvbG9yID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIG1hdGVyaWFsLmNvbG9yOyAvL2luaGVyaXQgZnJvbSBiYXNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2xvck9iaiA9IG1hdGVyaWFsLmhhc093blByb3BlcnR5KCdjb2xvcicpID8gbWF0ZXJpYWwuY29sb3IgOiAobWF0ZXJpYWwuY29sb3IgPSBuZXcgdGhyZWUuQ29sb3IoKSk7XG4gICAgICAgIGlmIChjb2xvciAhPT0gY29sb3JPYmouX2lucHV0IHx8IHR5cGVvZiBjb2xvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjb2xvck9iai5zZXQoY29sb3JPYmouX2lucHV0ID0gY29sb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGJhc2Ugb3JpZW50YXRpb25cbiAgICAgIGxldCBvcmllbnQgPSB0aGlzLm9yaWVudGF0aW9uIHx8IGRlZmF1bHRPcmllbnQ7XG4gICAgICBpZiAob3JpZW50ICE9PSBtYXRlcmlhbC5fb3JpZW50YXRpb24pIHtcbiAgICAgICAgbGV0IHJvdE1hdCA9IHVuaWZvcm1zLnVUcm9pa2FPcmllbnQudmFsdWU7XG4gICAgICAgIG9yaWVudCA9IG9yaWVudC5yZXBsYWNlKC9bXi0reHl6XS9nLCAnJyk7XG4gICAgICAgIGxldCBtYXRjaCA9IG9yaWVudCAhPT0gZGVmYXVsdE9yaWVudCAmJiBvcmllbnQubWF0Y2goL14oWy0rXSkoW3h5el0pKFstK10pKFt4eXpdKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgbGV0IFssIGhTaWduLCBoQXhpcywgdlNpZ24sIHZBeGlzXSA9IG1hdGNoO1xuICAgICAgICAgIHRlbXBWZWMzYS5zZXQoMCwgMCwgMClbaEF4aXNdID0gaFNpZ24gPT09ICctJyA/IDEgOiAtMTtcbiAgICAgICAgICB0ZW1wVmVjM2Iuc2V0KDAsIDAsIDApW3ZBeGlzXSA9IHZTaWduID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgdGVtcE1hdDQubG9va0F0KG9yaWdpbiwgdGVtcFZlYzNhLmNyb3NzKHRlbXBWZWMzYiksIHRlbXBWZWMzYik7XG4gICAgICAgICAgcm90TWF0LnNldEZyb21NYXRyaXg0KHRlbXBNYXQ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3RNYXQuaWRlbnRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRlcmlhbC5fb3JpZW50YXRpb24gPSBvcmllbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3BhcnNlUGVyY2VudCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdmFsdWUubWF0Y2goL14oLT9bXFxkLl0rKSUkLyk7XG4gICAgICAgIGxldCBwY3QgPSBtYXRjaCA/IHBhcnNlRmxvYXQobWF0Y2hbMV0pIDogTmFOO1xuICAgICAgICB2YWx1ZSA9IChpc05hTihwY3QpID8gMCA6IHBjdCAvIDEwMCkgKiB0aGlzLmZvbnRTaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlIGEgcG9pbnQgaW4gbG9jYWwgc3BhY2UgdG8gYW4geC95IGluIHRoZSB0ZXh0IHBsYW5lLlxuICAgICAqL1xuICAgIGxvY2FsUG9zaXRpb25Ub1RleHRDb29yZHMocG9zaXRpb24sIHRhcmdldCA9IG5ldyB0aHJlZS5WZWN0b3IyKCkpIHtcbiAgICAgIHRhcmdldC5jb3B5KHBvc2l0aW9uKTsgLy9zaW1wbGUgbm9uLWN1cnZlZCBjYXNlIGlzIDE6MVxuICAgICAgY29uc3QgciA9IHRoaXMuY3VydmVSYWRpdXM7XG4gICAgICBpZiAocikgeyAvL2ZsYXR0ZW4gdGhlIGN1cnZlXG4gICAgICAgIHRhcmdldC54ID0gTWF0aC5hdGFuMihwb3NpdGlvbi54LCBNYXRoLmFicyhyKSAtIE1hdGguYWJzKHBvc2l0aW9uLnopKSAqIE1hdGguYWJzKHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZSBhIHBvaW50IGluIHdvcmxkIHNwYWNlIHRvIGFuIHgveSBpbiB0aGUgdGV4dCBwbGFuZS5cbiAgICAgKi9cbiAgICB3b3JsZFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgdGhyZWUuVmVjdG9yMigpKSB7XG4gICAgICB0ZW1wVmVjM2EuY29weShwb3NpdGlvbik7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbFBvc2l0aW9uVG9UZXh0Q29vcmRzKHRoaXMud29ybGRUb0xvY2FsKHRlbXBWZWMzYSksIHRhcmdldClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGUgQ3VzdG9tIHJheWNhc3RpbmcgdG8gdGVzdCBhZ2FpbnN0IHRoZSB3aG9sZSB0ZXh0IGJsb2NrJ3MgbWF4IHJlY3Rhbmd1bGFyIGJvdW5kc1xuICAgICAqIFRPRE8gaXMgdGhlcmUgYW55IHJlYXNvbiB0byBtYWtlIHRoaXMgbW9yZSBncmFudWxhciwgbGlrZSB3aXRoaW4gaW5kaXZpZHVhbCBsaW5lIG9yIGdseXBoIHJlY3RzP1xuICAgICAqL1xuICAgIHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG4gICAgICBjb25zdCB7dGV4dFJlbmRlckluZm8sIGN1cnZlUmFkaXVzfSA9IHRoaXM7XG4gICAgICBpZiAodGV4dFJlbmRlckluZm8pIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGV4dFJlbmRlckluZm8uYmxvY2tCb3VuZHM7XG4gICAgICAgIGNvbnN0IHJheWNhc3RNZXNoID0gY3VydmVSYWRpdXMgPyBnZXRDdXJ2ZWRSYXljYXN0TWVzaCgpIDogZ2V0RmxhdFJheWNhc3RNZXNoKCk7XG4gICAgICAgIGNvbnN0IGdlb20gPSByYXljYXN0TWVzaC5nZW9tZXRyeTtcbiAgICAgICAgY29uc3Qge3Bvc2l0aW9uLCB1dn0gPSBnZW9tLmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXYuY291bnQ7IGkrKykge1xuICAgICAgICAgIGxldCB4ID0gYm91bmRzWzBdICsgKHV2LmdldFgoaSkgKiAoYm91bmRzWzJdIC0gYm91bmRzWzBdKSk7XG4gICAgICAgICAgY29uc3QgeSA9IGJvdW5kc1sxXSArICh1di5nZXRZKGkpICogKGJvdW5kc1szXSAtIGJvdW5kc1sxXSkpO1xuICAgICAgICAgIGxldCB6ID0gMDtcbiAgICAgICAgICBpZiAoY3VydmVSYWRpdXMpIHtcbiAgICAgICAgICAgIHogPSBjdXJ2ZVJhZGl1cyAtIE1hdGguY29zKHggLyBjdXJ2ZVJhZGl1cykgKiBjdXJ2ZVJhZGl1cztcbiAgICAgICAgICAgIHggPSBNYXRoLnNpbih4IC8gY3VydmVSYWRpdXMpICogY3VydmVSYWRpdXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvc2l0aW9uLnNldFhZWihpLCB4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgICAgICBnZW9tLmJvdW5kaW5nU3BoZXJlID0gdGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZTtcbiAgICAgICAgZ2VvbS5ib3VuZGluZ0JveCA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdCb3g7XG4gICAgICAgIHJheWNhc3RNZXNoLm1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcbiAgICAgICAgcmF5Y2FzdE1lc2gubWF0ZXJpYWwuc2lkZSA9IHRoaXMubWF0ZXJpYWwuc2lkZTtcbiAgICAgICAgdGVtcEFycmF5Lmxlbmd0aCA9IDA7XG4gICAgICAgIHJheWNhc3RNZXNoLnJheWNhc3QocmF5Y2FzdGVyLCB0ZW1wQXJyYXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRlbXBBcnJheVtpXS5vYmplY3QgPSB0aGlzO1xuICAgICAgICAgIGludGVyc2VjdHMucHVzaCh0ZW1wQXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29weShzb3VyY2UpIHtcbiAgICAgIC8vIFByZXZlbnQgY29weWluZyB0aGUgZ2VvbWV0cnkgcmVmZXJlbmNlIHNvIHdlIGRvbid0IGVuZCB1cCBzaGFyaW5nIGF0dHJpYnV0ZXMgYmV0d2VlbiBpbnN0YW5jZXNcbiAgICAgIGNvbnN0IGdlb20gPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgc3VwZXIuY29weShzb3VyY2UpO1xuICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb207XG5cbiAgICAgIENPUFlBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpXG4gICAgfVxuICB9XG5cblxuICAvLyBDcmVhdGUgc2V0dGVycyBmb3IgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0ZXh0IGxheW91dDpcbiAgU1lOQ0FCTEVfUFJPUFMuZm9yRWFjaChwcm9wID0+IHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gJ19wcml2YXRlXycgKyBwcm9wO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpc1twcml2YXRlS2V5XVxuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXNbcHJpdmF0ZUtleV0pIHtcbiAgICAgICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5fbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLz09PSBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIGNhcmV0cyBhbmQgc2VsZWN0aW9uIHJhbmdlcyA9PT0vL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBUZXh0Q2FyZXRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSB4IHBvc2l0aW9uIG9mIHRoZSBjYXJldFxuICAgKiBAcHJvcGVydHkge251bWJlcn0geSAtIHkgcG9zaXRpb24gb2YgdGhlIGNhcmV0J3MgYm90dG9tXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIGNhcmV0XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaGFySW5kZXggLSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZyBvZiB0aGlzIGNhcmV0J3MgdGFyZ2V0XG4gICAqICAgY2hhcmFjdGVyOyB0aGUgY2FyZXQgd2lsbCBiZSBmb3IgdGhlIHBvc2l0aW9uIF9iZWZvcmVfIHRoYXQgY2hhcmFjdGVyLlxuICAgKi9cblxuICAvKipcbiAgICogR2l2ZW4gYSBsb2NhbCB4L3kgY29vcmRpbmF0ZSBpbiB0aGUgdGV4dCBibG9jayBwbGFuZSwgZmluZCB0aGUgbmVhcmVzdCBjYXJldCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm8gLSBhIHJlc3VsdCBvYmplY3QgZnJvbSBUZXh0QnVpbGRlciNnZXRUZXh0UmVuZGVySW5mb1xuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtUZXh0Q2FyZXQgfCBudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q2FyZXRBdFBvaW50KHRleHRSZW5kZXJJbmZvLCB4LCB5KSB7XG4gICAgbGV0IGNsb3Nlc3RDYXJldCA9IG51bGw7XG4gICAgY29uc3Qge2NhcmV0SGVpZ2h0fSA9IHRleHRSZW5kZXJJbmZvO1xuICAgIGNvbnN0IGNhcmV0c0J5Um93ID0gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbyk7XG5cbiAgICAvLyBGaW5kIG5lYXJlc3Qgcm93IGJ5IHkgZmlyc3RcbiAgICBsZXQgY2xvc2VzdFJvd1kgPSBJbmZpbml0eTtcbiAgICBjYXJldHNCeVJvdy5mb3JFYWNoKChjYXJldHMsIHJvd1kpID0+IHtcbiAgICAgIGlmIChNYXRoLmFicyh5IC0gKHJvd1kgKyBjYXJldEhlaWdodCAvIDIpKSA8IE1hdGguYWJzKHkgLSAoY2xvc2VzdFJvd1kgKyBjYXJldEhlaWdodCAvIDIpKSkge1xuICAgICAgICBjbG9zZXN0Um93WSA9IHJvd1k7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGVuIGZpbmQgY2xvc2VzdCBjYXJldCBieSB4IHdpdGhpbiB0aGF0IHJvd1xuICAgIGNhcmV0c0J5Um93LmdldChjbG9zZXN0Um93WSkuZm9yRWFjaChjYXJldCA9PiB7XG4gICAgICBpZiAoIWNsb3Nlc3RDYXJldCB8fCBNYXRoLmFicyh4IC0gY2FyZXQueCkgPCBNYXRoLmFicyh4IC0gY2xvc2VzdENhcmV0LngpKSB7XG4gICAgICAgIGNsb3Nlc3RDYXJldCA9IGNhcmV0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbG9zZXN0Q2FyZXRcbiAgfVxuXG5cbiAgY29uc3QgX3JlY3RzQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIC8qKlxuICAgKiBHaXZlbiBzdGFydCBhbmQgZW5kIGNoYXJhY3RlciBpbmRleGVzLCByZXR1cm4gYSBsaXN0IG9mIHJlY3RhbmdsZXMgY292ZXJpbmcgYWxsIHRoZVxuICAgKiBjaGFyYWN0ZXJzIHdpdGhpbiB0aGF0IHNlbGVjdGlvbi5cbiAgICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXIgaW4gdGhlIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgdGhlIHNlbGVjdGlvblxuICAgKiBAcmV0dXJuIHtBcnJheTx7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfT4gfCBudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmVjdHModGV4dFJlbmRlckluZm8sIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgcmVjdHM7XG4gICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICAvLyBDaGVjayBjYWNoZSAtIHRleHRSZW5kZXJJbmZvIGlzIGZyb3plbiBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgYmFzZWQgb24gaXRcbiAgICAgIGxldCBwcmV2UmVzdWx0ID0gX3JlY3RzQ2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgICAgIGlmIChwcmV2UmVzdWx0ICYmIHByZXZSZXN1bHQuc3RhcnQgPT09IHN0YXJ0ICYmIHByZXZSZXN1bHQuZW5kID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHByZXZSZXN1bHQucmVjdHNcbiAgICAgIH1cblxuICAgICAgY29uc3Qge2NhcmV0UG9zaXRpb25zLCBjYXJldEhlaWdodH0gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgICAgLy8gTm9ybWFsaXplXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgY29uc3QgcyA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgZW5kID0gcztcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBjYXJldFBvc2l0aW9ucy5sZW5ndGggKyAxKTtcblxuICAgICAgLy8gQnVpbGQgbGlzdCBvZiByZWN0cywgZXhwYW5kaW5nIHRoZSBjdXJyZW50IHJlY3QgZm9yIGFsbCBjaGFyYWN0ZXJzIGluIGEgcnVuIGFuZCBzdGFydGluZ1xuICAgICAgLy8gYSBuZXcgcmVjdCB3aGVuZXZlciByZWFjaGluZyBhIG5ldyBsaW5lIG9yIGEgbmV3IGJpZGkgZGlyZWN0aW9uXG4gICAgICByZWN0cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSZWN0ID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHgxID0gY2FyZXRQb3NpdGlvbnNbaSAqIDNdO1xuICAgICAgICBjb25zdCB4MiA9IGNhcmV0UG9zaXRpb25zW2kgKiAzICsgMV07XG4gICAgICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbih4MSwgeDIpO1xuICAgICAgICBjb25zdCByaWdodCA9IE1hdGgubWF4KHgxLCB4Mik7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IGNhcmV0UG9zaXRpb25zW2kgKiAzICsgMl07XG4gICAgICAgIGlmICghY3VycmVudFJlY3QgfHwgYm90dG9tICE9PSBjdXJyZW50UmVjdC5ib3R0b20gfHwgbGVmdCA+IGN1cnJlbnRSZWN0LnJpZ2h0IHx8IHJpZ2h0IDwgY3VycmVudFJlY3QubGVmdCkge1xuICAgICAgICAgIGN1cnJlbnRSZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogSW5maW5pdHksXG4gICAgICAgICAgICByaWdodDogLUluZmluaXR5LFxuICAgICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgICB0b3A6IGJvdHRvbSArIGNhcmV0SGVpZ2h0XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWN0cy5wdXNoKGN1cnJlbnRSZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UmVjdC5sZWZ0ID0gTWF0aC5taW4obGVmdCwgY3VycmVudFJlY3QubGVmdCk7XG4gICAgICAgIGN1cnJlbnRSZWN0LnJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIGN1cnJlbnRSZWN0LnJpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVyZ2UgYW55IG92ZXJsYXBwaW5nIHJlY3RzLCBlLmcuIHRob3NlIGZvcm1lZCBieSBhZGphY2VudCBiaWRpIHJ1bnNcbiAgICAgIHJlY3RzLnNvcnQoKGEsIGIpID0+IGIuYm90dG9tIC0gYS5ib3R0b20gfHwgYS5sZWZ0IC0gYi5sZWZ0KTtcbiAgICAgIGZvciAobGV0IGkgPSByZWN0cy5sZW5ndGggLSAxOyBpLS0gPiAwOykge1xuICAgICAgICBjb25zdCByZWN0QSA9IHJlY3RzW2ldO1xuICAgICAgICBjb25zdCByZWN0QiA9IHJlY3RzW2kgKyAxXTtcbiAgICAgICAgaWYgKHJlY3RBLmJvdHRvbSA9PT0gcmVjdEIuYm90dG9tICYmIHJlY3RBLmxlZnQgPD0gcmVjdEIucmlnaHQgJiYgcmVjdEEucmlnaHQgPj0gcmVjdEIubGVmdCkge1xuICAgICAgICAgIHJlY3RCLmxlZnQgPSBNYXRoLm1pbihyZWN0Qi5sZWZ0LCByZWN0QS5sZWZ0KTtcbiAgICAgICAgICByZWN0Qi5yaWdodCA9IE1hdGgubWF4KHJlY3RCLnJpZ2h0LCByZWN0QS5yaWdodCk7XG4gICAgICAgICAgcmVjdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9yZWN0c0NhY2hlLnNldCh0ZXh0UmVuZGVySW5mbywge3N0YXJ0LCBlbmQsIHJlY3RzfSk7XG4gICAgfVxuICAgIHJldHVybiByZWN0c1xuICB9XG5cbiAgY29uc3QgX2NhcmV0c0J5Um93Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIGZ1bmN0aW9uIGdyb3VwQ2FyZXRzQnlSb3codGV4dFJlbmRlckluZm8pIHtcbiAgICAvLyB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gICAgbGV0IGNhcmV0c0J5Um93ID0gX2NhcmV0c0J5Um93Q2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgICBpZiAoIWNhcmV0c0J5Um93KSB7XG4gICAgICBjb25zdCB7Y2FyZXRQb3NpdGlvbnMsIGNhcmV0SGVpZ2h0fSA9IHRleHRSZW5kZXJJbmZvO1xuICAgICAgY2FyZXRzQnlSb3cgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhcmV0UG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IHJvd1kgPSBjYXJldFBvc2l0aW9uc1tpICsgMl07XG4gICAgICAgIGxldCByb3dDYXJldHMgPSBjYXJldHNCeVJvdy5nZXQocm93WSk7XG4gICAgICAgIGlmICghcm93Q2FyZXRzKSB7XG4gICAgICAgICAgY2FyZXRzQnlSb3cuc2V0KHJvd1ksIHJvd0NhcmV0cyA9IFtdKTtcbiAgICAgICAgfVxuICAgICAgICByb3dDYXJldHMucHVzaCh7XG4gICAgICAgICAgeDogY2FyZXRQb3NpdGlvbnNbaV0sXG4gICAgICAgICAgeTogcm93WSxcbiAgICAgICAgICBoZWlnaHQ6IGNhcmV0SGVpZ2h0LFxuICAgICAgICAgIGNoYXJJbmRleDogaSAvIDNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBvbmUgbW9yZSBjYXJldCBhZnRlciB0aGUgZmluYWwgY2hhclxuICAgICAgICBpZiAoaSArIDMgPj0gY2FyZXRQb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgcm93Q2FyZXRzLnB1c2goe1xuICAgICAgICAgICAgeDogY2FyZXRQb3NpdGlvbnNbaSArIDFdLFxuICAgICAgICAgICAgeTogcm93WSxcbiAgICAgICAgICAgIGhlaWdodDogY2FyZXRIZWlnaHQsXG4gICAgICAgICAgICBjaGFySW5kZXg6IGkgLyAzICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9jYXJldHNCeVJvd0NhY2hlLnNldCh0ZXh0UmVuZGVySW5mbywgY2FyZXRzQnlSb3cpO1xuICAgIHJldHVybiBjYXJldHNCeVJvd1xuICB9XG5cbiAgZXhwb3J0cy5HbHlwaHNHZW9tZXRyeSA9IEdseXBoc0dlb21ldHJ5O1xuICBleHBvcnRzLlRleHQgPSBUZXh0O1xuICBleHBvcnRzLmNvbmZpZ3VyZVRleHRCdWlsZGVyID0gY29uZmlndXJlVGV4dEJ1aWxkZXI7XG4gIGV4cG9ydHMuY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWw7XG4gIGV4cG9ydHMuZHVtcFNERlRleHR1cmVzID0gZHVtcFNERlRleHR1cmVzO1xuICBleHBvcnRzLmdldENhcmV0QXRQb2ludCA9IGdldENhcmV0QXRQb2ludDtcbiAgZXhwb3J0cy5nZXRTZWxlY3Rpb25SZWN0cyA9IGdldFNlbGVjdGlvblJlY3RzO1xuICBleHBvcnRzLnByZWxvYWRGb250ID0gcHJlbG9hZEZvbnQ7XG4gIGV4cG9ydHMudHlwZXNldHRlcldvcmtlck1vZHVsZSA9IHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js\n");

/***/ })

};
;