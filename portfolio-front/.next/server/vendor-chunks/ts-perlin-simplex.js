/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ts-perlin-simplex";
exports.ids = ["vendor-chunks/ts-perlin-simplex"];
exports.modules = {

/***/ "(ssr)/./node_modules/ts-perlin-simplex/index.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-perlin-simplex/index.js ***!
  \*************************************************/
/***/ ((module) => {

eval("// https://gist.github.com/banksean/304522\n//\n// Ported from Stefan Gustavson's java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan's excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n\n/**\n * You can pass in a random number generator object if you like.\n * It is assumed to have a random() method.\n */\n\nNoise = {}\n\nNoise.SimplexNoise = function(r) {\n  if (r == undefined) r = Math;\n  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],\n                                 [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],\n                                 [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];\n  this.p = [];\n  for (var i=0; i<256; i++) {\n    this.p[i] = Math.floor(r.random()*256);\n  }\n  // To remove the need for index wrapping, double the permutation table length\n  this.perm = [];\n  for(var i=0; i<512; i++) {\n    this.perm[i]=this.p[i & 255];\n  }\n\n  // A lookup table to traverse the simplex around a given point in 4D.\n  // Details can be found where this table is used, in the 4D noise method.\n  this.simplex = [\n    [0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],\n    [0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],\n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],\n    [1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],\n    [1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],\n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],\n    [2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],\n    [2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];\n};\n\nNoise.SimplexNoise.prototype.dot = function(g, x, y) {\n  return g[0]*x + g[1]*y;\n};\n\nNoise.SimplexNoise.prototype.dot3 = function(g, x, y, z) {\n  return g[0]*x + g[1]*y + g[2]*z;\n};\n\nNoise.SimplexNoise.prototype.noise = function(xin, yin) {\n  var n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n  var F2 = 0.5*(Math.sqrt(3.0)-1.0);\n  var s = (xin+yin)*F2; // Hairy factor for 2D\n  var i = Math.floor(xin+s);\n  var j = Math.floor(yin+s);\n  var G2 = (3.0-Math.sqrt(3.0))/6.0;\n  var t = (i+j)*G2;\n  var X0 = i-t; // Unskew the cell origin back to (x,y) space\n  var Y0 = j-t;\n  var x0 = xin-X0; // The x,y distances from the cell origin\n  var y0 = yin-Y0;\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n  else {i1=0; j1=1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n  var y1 = y0 - j1 + G2;\n  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n  var y2 = y0 - 1.0 + 2.0 * G2;\n  // Work out the hashed gradient indices of the three simplex corners\n  var ii = i & 255;\n  var jj = j & 255;\n  var gi0 = this.perm[ii+this.perm[jj]] % 12;\n  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;\n  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;\n  // Calculate the contribution from the three corners\n  var t0 = 0.5 - x0*x0-y0*y0;\n  if(t0<0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient\n  }\n  var t1 = 0.5 - x1*x1-y1*y1;\n  if(t1<0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);\n  }\n  var t2 = 0.5 - x2*x2-y2*y2;\n  if(t2<0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n  return 70.0 * (n0 + n1 + n2);\n};\n\n// 3D simplex noise\nNoise.SimplexNoise.prototype.noise3d = function(xin, yin, zin) {\n  var n0, n1, n2, n3; // Noise contributions from the four corners\n  // Skew the input space to determine which simplex cell we're in\n  var F3 = 1.0/3.0;\n  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n  var i = Math.floor(xin+s);\n  var j = Math.floor(yin+s);\n  var k = Math.floor(zin+s);\n  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n  var t = (i+j+k)*G3;\n  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n  var Y0 = j-t;\n  var Z0 = k-t;\n  var x0 = xin-X0; // The x,y,z distances from the cell origin\n  var y0 = yin-Y0;\n  var z0 = zin-Z0;\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // Determine which simplex we are in.\n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n  if(x0>=y0) {\n    if(y0>=z0)\n      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n    }\n  else { // x0<y0\n    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n  }\n  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n  // c = 1/6.\n  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n  var y1 = y0 - j1 + G3;\n  var z1 = z0 - k1 + G3;\n  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n  var y2 = y0 - j2 + 2.0*G3;\n  var z2 = z0 - k2 + 2.0*G3;\n  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n  var y3 = y0 - 1.0 + 3.0*G3;\n  var z3 = z0 - 1.0 + 3.0*G3;\n  // Work out the hashed gradient indices of the four simplex corners\n  var ii = i & 255;\n  var jj = j & 255;\n  var kk = k & 255;\n  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12;\n  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12;\n  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12;\n  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12;\n  // Calculate the contribution from the four corners\n  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n  if(t0<0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);\n  }\n  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n  if(t1<0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);\n  }\n  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n  if(t2<0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);\n  }\n  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n  if(t3<0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);\n  }\n  // Add contributions from each corner to get the final noise value.\n  // The result is scaled to stay just inside [-1,1]\n  return 32.0*(n0 + n1 + n2 + n3);\n};\n\nmodule.exports = Noise;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHMtcGVybGluLXNpbXBsZXgvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxhQUFhLE1BQU0sT0FBTztBQUMxQixRQUFRLE1BQU0sWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsUUFBUSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sUUFBUTtBQUM5Qyx3QkFBd0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLFFBQVE7QUFDOUQsYUFBYSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sUUFBUTtBQUNuRDtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLFFBQVE7QUFDdEQscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxRQUFRO0FBQzNELFdBQVcsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWZyb250Ly4vbm9kZV9tb2R1bGVzL3RzLXBlcmxpbi1zaW1wbGV4L2luZGV4LmpzPzdlYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFua3NlYW4vMzA0NTIyXG4vL1xuLy8gUG9ydGVkIGZyb20gU3RlZmFuIEd1c3RhdnNvbidzIGphdmEgaW1wbGVtZW50YXRpb25cbi8vIGh0dHA6Ly9zdGFmZnd3dy5pdG4ubGl1LnNlL35zdGVndS9zaW1wbGV4bm9pc2Uvc2ltcGxleG5vaXNlLnBkZlxuLy8gUmVhZCBTdGVmYW4ncyBleGNlbGxlbnQgcGFwZXIgZm9yIGRldGFpbHMgb24gaG93IHRoaXMgY29kZSB3b3Jrcy5cbi8vXG4vLyBTZWFuIE1jQ3VsbG91Z2ggYmFua3NlYW5AZ21haWwuY29tXG5cbi8qKlxuICogWW91IGNhbiBwYXNzIGluIGEgcmFuZG9tIG51bWJlciBnZW5lcmF0b3Igb2JqZWN0IGlmIHlvdSBsaWtlLlxuICogSXQgaXMgYXNzdW1lZCB0byBoYXZlIGEgcmFuZG9tKCkgbWV0aG9kLlxuICovXG5cbk5vaXNlID0ge31cblxuTm9pc2UuU2ltcGxleE5vaXNlID0gZnVuY3Rpb24ocikge1xuICBpZiAociA9PSB1bmRlZmluZWQpIHIgPSBNYXRoO1xuICB0aGlzLmdyYWQzID0gW1sxLDEsMF0sWy0xLDEsMF0sWzEsLTEsMF0sWy0xLC0xLDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWzEsMCwxXSxbLTEsMCwxXSxbMSwwLC0xXSxbLTEsMCwtMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMCwxLDFdLFswLC0xLDFdLFswLDEsLTFdLFswLC0xLC0xXV07XG4gIHRoaXMucCA9IFtdO1xuICBmb3IgKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgICB0aGlzLnBbaV0gPSBNYXRoLmZsb29yKHIucmFuZG9tKCkqMjU2KTtcbiAgfVxuICAvLyBUbyByZW1vdmUgdGhlIG5lZWQgZm9yIGluZGV4IHdyYXBwaW5nLCBkb3VibGUgdGhlIHBlcm11dGF0aW9uIHRhYmxlIGxlbmd0aFxuICB0aGlzLnBlcm0gPSBbXTtcbiAgZm9yKHZhciBpPTA7IGk8NTEyOyBpKyspIHtcbiAgICB0aGlzLnBlcm1baV09dGhpcy5wW2kgJiAyNTVdO1xuICB9XG5cbiAgLy8gQSBsb29rdXAgdGFibGUgdG8gdHJhdmVyc2UgdGhlIHNpbXBsZXggYXJvdW5kIGEgZ2l2ZW4gcG9pbnQgaW4gNEQuXG4gIC8vIERldGFpbHMgY2FuIGJlIGZvdW5kIHdoZXJlIHRoaXMgdGFibGUgaXMgdXNlZCwgaW4gdGhlIDREIG5vaXNlIG1ldGhvZC5cbiAgdGhpcy5zaW1wbGV4ID0gW1xuICAgIFswLDEsMiwzXSxbMCwxLDMsMl0sWzAsMCwwLDBdLFswLDIsMywxXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMSwyLDMsMF0sXG4gICAgWzAsMiwxLDNdLFswLDAsMCwwXSxbMCwzLDEsMl0sWzAsMywyLDFdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFsxLDMsMiwwXSxcbiAgICBbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFxuICAgIFsxLDIsMCwzXSxbMCwwLDAsMF0sWzEsMywwLDJdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFsyLDMsMCwxXSxbMiwzLDEsMF0sXG4gICAgWzEsMCwyLDNdLFsxLDAsMywyXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMiwwLDMsMV0sWzAsMCwwLDBdLFsyLDEsMywwXSxcbiAgICBbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFxuICAgIFsyLDAsMSwzXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMywwLDEsMl0sWzMsMCwyLDFdLFswLDAsMCwwXSxbMywxLDIsMF0sXG4gICAgWzIsMSwwLDNdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFszLDEsMCwyXSxbMCwwLDAsMF0sWzMsMiwwLDFdLFszLDIsMSwwXV07XG59O1xuXG5Ob2lzZS5TaW1wbGV4Tm9pc2UucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGcsIHgsIHkpIHtcbiAgcmV0dXJuIGdbMF0qeCArIGdbMV0qeTtcbn07XG5cbk5vaXNlLlNpbXBsZXhOb2lzZS5wcm90b3R5cGUuZG90MyA9IGZ1bmN0aW9uKGcsIHgsIHksIHopIHtcbiAgcmV0dXJuIGdbMF0qeCArIGdbMV0qeSArIGdbMl0qejtcbn07XG5cbk5vaXNlLlNpbXBsZXhOb2lzZS5wcm90b3R5cGUubm9pc2UgPSBmdW5jdGlvbih4aW4sIHlpbikge1xuICB2YXIgbjAsIG4xLCBuMjsgLy8gTm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG4gIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cbiAgdmFyIEYyID0gMC41KihNYXRoLnNxcnQoMy4wKS0xLjApO1xuICB2YXIgcyA9ICh4aW4reWluKSpGMjsgLy8gSGFpcnkgZmFjdG9yIGZvciAyRFxuICB2YXIgaSA9IE1hdGguZmxvb3IoeGluK3MpO1xuICB2YXIgaiA9IE1hdGguZmxvb3IoeWluK3MpO1xuICB2YXIgRzIgPSAoMy4wLU1hdGguc3FydCgzLjApKS82LjA7XG4gIHZhciB0ID0gKGkraikqRzI7XG4gIHZhciBYMCA9IGktdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkpIHNwYWNlXG4gIHZhciBZMCA9IGotdDtcbiAgdmFyIHgwID0geGluLVgwOyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICB2YXIgeTAgPSB5aW4tWTA7XG4gIC8vIEZvciB0aGUgMkQgY2FzZSwgdGhlIHNpbXBsZXggc2hhcGUgaXMgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUuXG4gIC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi5cbiAgdmFyIGkxLCBqMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIChtaWRkbGUpIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGopIGNvb3Jkc1xuICBpZih4MD55MCkge2kxPTE7IGoxPTA7fSAvLyBsb3dlciB0cmlhbmdsZSwgWFkgb3JkZXI6ICgwLDApLT4oMSwwKS0+KDEsMSlcbiAgZWxzZSB7aTE9MDsgajE9MTt9ICAgICAgLy8gdXBwZXIgdHJpYW5nbGUsIFlYIG9yZGVyOiAoMCwwKS0+KDAsMSktPigxLDEpXG4gIC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZFxuICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuICAvLyBjID0gKDMtc3FydCgzKSkvNlxuICB2YXIgeDEgPSB4MCAtIGkxICsgRzI7IC8vIE9mZnNldHMgZm9yIG1pZGRsZSBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMjtcbiAgdmFyIHgyID0geDAgLSAxLjAgKyAyLjAgKiBHMjsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG4gIHZhciB5MiA9IHkwIC0gMS4wICsgMi4wICogRzI7XG4gIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXG4gIHZhciBpaSA9IGkgJiAyNTU7XG4gIHZhciBqaiA9IGogJiAyNTU7XG4gIHZhciBnaTAgPSB0aGlzLnBlcm1baWkrdGhpcy5wZXJtW2pqXV0gJSAxMjtcbiAgdmFyIGdpMSA9IHRoaXMucGVybVtpaStpMSt0aGlzLnBlcm1bamorajFdXSAlIDEyO1xuICB2YXIgZ2kyID0gdGhpcy5wZXJtW2lpKzErdGhpcy5wZXJtW2pqKzFdXSAlIDEyO1xuICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG4gIHZhciB0MCA9IDAuNSAtIHgwKngwLXkwKnkwO1xuICBpZih0MDwwKSBuMCA9IDAuMDtcbiAgZWxzZSB7XG4gICAgdDAgKj0gdDA7XG4gICAgbjAgPSB0MCAqIHQwICogdGhpcy5kb3QodGhpcy5ncmFkM1tnaTBdLCB4MCwgeTApOyAgLy8gKHgseSkgb2YgZ3JhZDMgdXNlZCBmb3IgMkQgZ3JhZGllbnRcbiAgfVxuICB2YXIgdDEgPSAwLjUgLSB4MSp4MS15MSp5MTtcbiAgaWYodDE8MCkgbjEgPSAwLjA7XG4gIGVsc2Uge1xuICAgIHQxICo9IHQxO1xuICAgIG4xID0gdDEgKiB0MSAqIHRoaXMuZG90KHRoaXMuZ3JhZDNbZ2kxXSwgeDEsIHkxKTtcbiAgfVxuICB2YXIgdDIgPSAwLjUgLSB4Mip4Mi15Mip5MjtcbiAgaWYodDI8MCkgbjIgPSAwLjA7XG4gIGVsc2Uge1xuICAgIHQyICo9IHQyO1xuICAgIG4yID0gdDIgKiB0MiAqIHRoaXMuZG90KHRoaXMuZ3JhZDNbZ2kyXSwgeDIsIHkyKTtcbiAgfVxuICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXG4gIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHJldHVybiB2YWx1ZXMgaW4gdGhlIGludGVydmFsIFstMSwxXS5cbiAgcmV0dXJuIDcwLjAgKiAobjAgKyBuMSArIG4yKTtcbn07XG5cbi8vIDNEIHNpbXBsZXggbm9pc2Vcbk5vaXNlLlNpbXBsZXhOb2lzZS5wcm90b3R5cGUubm9pc2UzZCA9IGZ1bmN0aW9uKHhpbiwgeWluLCB6aW4pIHtcbiAgdmFyIG4wLCBuMSwgbjIsIG4zOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG4gIHZhciBGMyA9IDEuMC8zLjA7XG4gIHZhciBzID0gKHhpbit5aW4remluKSpGMzsgLy8gVmVyeSBuaWNlIGFuZCBzaW1wbGUgc2tldyBmYWN0b3IgZm9yIDNEXG4gIHZhciBpID0gTWF0aC5mbG9vcih4aW4rcyk7XG4gIHZhciBqID0gTWF0aC5mbG9vcih5aW4rcyk7XG4gIHZhciBrID0gTWF0aC5mbG9vcih6aW4rcyk7XG4gIHZhciBHMyA9IDEuMC82LjA7IC8vIFZlcnkgbmljZSBhbmQgc2ltcGxlIHVuc2tldyBmYWN0b3IsIHRvb1xuICB2YXIgdCA9IChpK2oraykqRzM7XG4gIHZhciBYMCA9IGktdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseikgc3BhY2VcbiAgdmFyIFkwID0gai10O1xuICB2YXIgWjAgPSBrLXQ7XG4gIHZhciB4MCA9IHhpbi1YMDsgLy8gVGhlIHgseSx6IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICB2YXIgeTAgPSB5aW4tWTA7XG4gIHZhciB6MCA9IHppbi1aMDtcbiAgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuICB2YXIgaTEsIGoxLCBrMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXG4gIHZhciBpMiwgajIsIGsyOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICBpZih4MD49eTApIHtcbiAgICBpZih5MD49ejApXG4gICAgICB7IGkxPTE7IGoxPTA7IGsxPTA7IGkyPTE7IGoyPTE7IGsyPTA7IH0gLy8gWCBZIFogb3JkZXJcbiAgICAgIGVsc2UgaWYoeDA+PXowKSB7IGkxPTE7IGoxPTA7IGsxPTA7IGkyPTE7IGoyPTA7IGsyPTE7IH0gLy8gWCBaIFkgb3JkZXJcbiAgICAgIGVsc2UgeyBpMT0wOyBqMT0wOyBrMT0xOyBpMj0xOyBqMj0wOyBrMj0xOyB9IC8vIFogWCBZIG9yZGVyXG4gICAgfVxuICBlbHNlIHsgLy8geDA8eTBcbiAgICBpZih5MDx6MCkgeyBpMT0wOyBqMT0wOyBrMT0xOyBpMj0wOyBqMj0xOyBrMj0xOyB9IC8vIFogWSBYIG9yZGVyXG4gICAgZWxzZSBpZih4MDx6MCkgeyBpMT0wOyBqMT0xOyBrMT0wOyBpMj0wOyBqMj0xOyBrMj0xOyB9IC8vIFkgWiBYIG9yZGVyXG4gICAgZWxzZSB7IGkxPTA7IGoxPTE7IGsxPTA7IGkyPTE7IGoyPTE7IGsyPTA7IH0gLy8gWSBYIFogb3JkZXJcbiAgfVxuICAvLyBBIHN0ZXAgb2YgKDEsMCwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jLC1jKSBpbiAoeCx5LHopLFxuICAvLyBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmRcbiAgLy8gYSBzdGVwIG9mICgwLDAsMSkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKC1jLC1jLDEtYykgaW4gKHgseSx6KSwgd2hlcmVcbiAgLy8gYyA9IDEvNi5cbiAgdmFyIHgxID0geDAgLSBpMSArIEczOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMztcbiAgdmFyIHoxID0gejAgLSBrMSArIEczO1xuICB2YXIgeDIgPSB4MCAtIGkyICsgMi4wKkczOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgdmFyIHkyID0geTAgLSBqMiArIDIuMCpHMztcbiAgdmFyIHoyID0gejAgLSBrMiArIDIuMCpHMztcbiAgdmFyIHgzID0geDAgLSAxLjAgKyAzLjAqRzM7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gIHZhciB5MyA9IHkwIC0gMS4wICsgMy4wKkczO1xuICB2YXIgejMgPSB6MCAtIDEuMCArIDMuMCpHMztcbiAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xuICB2YXIgaWkgPSBpICYgMjU1O1xuICB2YXIgamogPSBqICYgMjU1O1xuICB2YXIga2sgPSBrICYgMjU1O1xuICB2YXIgZ2kwID0gdGhpcy5wZXJtW2lpK3RoaXMucGVybVtqait0aGlzLnBlcm1ba2tdXV0gJSAxMjtcbiAgdmFyIGdpMSA9IHRoaXMucGVybVtpaStpMSt0aGlzLnBlcm1bamorajErdGhpcy5wZXJtW2trK2sxXV1dICUgMTI7XG4gIHZhciBnaTIgPSB0aGlzLnBlcm1baWkraTIrdGhpcy5wZXJtW2pqK2oyK3RoaXMucGVybVtraytrMl1dXSAlIDEyO1xuICB2YXIgZ2kzID0gdGhpcy5wZXJtW2lpKzErdGhpcy5wZXJtW2pqKzErdGhpcy5wZXJtW2trKzFdXV0gJSAxMjtcbiAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZm91ciBjb3JuZXJzXG4gIHZhciB0MCA9IDAuNiAtIHgwKngwIC0geTAqeTAgLSB6MCp6MDtcbiAgaWYodDA8MCkgbjAgPSAwLjA7XG4gIGVsc2Uge1xuICAgIHQwICo9IHQwO1xuICAgIG4wID0gdDAgKiB0MCAqIHRoaXMuZG90Myh0aGlzLmdyYWQzW2dpMF0sIHgwLCB5MCwgejApO1xuICB9XG4gIHZhciB0MSA9IDAuNiAtIHgxKngxIC0geTEqeTEgLSB6MSp6MTtcbiAgaWYodDE8MCkgbjEgPSAwLjA7XG4gIGVsc2Uge1xuICAgIHQxICo9IHQxO1xuICAgIG4xID0gdDEgKiB0MSAqIHRoaXMuZG90Myh0aGlzLmdyYWQzW2dpMV0sIHgxLCB5MSwgejEpO1xuICB9XG4gIHZhciB0MiA9IDAuNiAtIHgyKngyIC0geTIqeTIgLSB6Mip6MjtcbiAgaWYodDI8MCkgbjIgPSAwLjA7XG4gIGVsc2Uge1xuICAgIHQyICo9IHQyO1xuICAgIG4yID0gdDIgKiB0MiAqIHRoaXMuZG90Myh0aGlzLmdyYWQzW2dpMl0sIHgyLCB5MiwgejIpO1xuICB9XG4gIHZhciB0MyA9IDAuNiAtIHgzKngzIC0geTMqeTMgLSB6Myp6MztcbiAgaWYodDM8MCkgbjMgPSAwLjA7XG4gIGVsc2Uge1xuICAgIHQzICo9IHQzO1xuICAgIG4zID0gdDMgKiB0MyAqIHRoaXMuZG90Myh0aGlzLmdyYWQzW2dpM10sIHgzLCB5MywgejMpO1xuICB9XG4gIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gc3RheSBqdXN0IGluc2lkZSBbLTEsMV1cbiAgcmV0dXJuIDMyLjAqKG4wICsgbjEgKyBuMiArIG4zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9pc2U7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ts-perlin-simplex/index.js\n");

/***/ })

};
;